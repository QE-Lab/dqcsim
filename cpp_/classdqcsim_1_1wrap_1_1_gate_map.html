<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.19"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DQCsim: dqcsim::wrap::GateMap&lt; Unbound, Bound &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DQCsim
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.19 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedqcsim.html">dqcsim</a></li><li class="navelem"><a class="el" href="namespacedqcsim_1_1wrap.html">wrap</a></li><li class="navelem"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdqcsim_1_1wrap_1_1_gate_map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">dqcsim::wrap::GateMap&lt; Unbound, Bound &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classdqcsim_1_1wrap_1_1_gate.html" title="Represents any kind of gate with qubits bound to it.">Gate</a> map wrapper class.  
 <a href="classdqcsim_1_1wrap_1_1_gate_map.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for dqcsim::wrap::GateMap&lt; Unbound, Bound &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classdqcsim_1_1wrap_1_1_gate_map.png" usemap="#dqcsim::wrap::GateMap_3C_20Unbound_2C_20Bound_20_3E_map" alt=""/>
  <map id="dqcsim::wrap::GateMap_3C_20Unbound_2C_20Bound_20_3E_map" name="dqcsim::wrap::GateMap_3C_20Unbound_2C_20Bound_20_3E_map">
<area href="classdqcsim_1_1wrap_1_1_handle.html" title="Base class for wrapping any handle." alt="dqcsim::wrap::Handle" shape="rect" coords="0,0,260,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abfe6c5268739501b6f6c47acec8c5f02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#abfe6c5268739501b6f6c47acec8c5f02">GateMap</a> (<a class="el" href="namespacedqcsim_1_1wrap.html#af0961c9cf3940114db65b8d7260021e0">HandleIndex</a> <a class="el" href="classdqcsim_1_1wrap_1_1_handle.html#ac80648089082d159656cafa3610f5442">handle</a>) noexcept</td></tr>
<tr class="memdesc:abfe6c5268739501b6f6c47acec8c5f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the given gate map handle.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#abfe6c5268739501b6f6c47acec8c5f02">More...</a><br /></td></tr>
<tr class="separator:abfe6c5268739501b6f6c47acec8c5f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe67890a4a06249ae4d192bc354db4ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#afe67890a4a06249ae4d192bc354db4ab">GateMap</a> (bool strip_qubit_refs=false, bool strip_data=false)</td></tr>
<tr class="memdesc:afe67890a4a06249ae4d192bc354db4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new gate map.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#afe67890a4a06249ae4d192bc354db4ab">More...</a><br /></td></tr>
<tr class="separator:afe67890a4a06249ae4d192bc354db4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2549454c5ead26a287a80612c42b39e7"><td class="memItemLeft" align="right" valign="top"><a id="a2549454c5ead26a287a80612c42b39e7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GateMap</b> (const <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a> &amp;)=delete</td></tr>
<tr class="separator:a2549454c5ead26a287a80612c42b39e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991627df933a41912876fee501e1fb20"><td class="memItemLeft" align="right" valign="top"><a id="a991627df933a41912876fee501e1fb20"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a> &amp;)=delete</td></tr>
<tr class="separator:a991627df933a41912876fee501e1fb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b43000ab834935f54e0ecb72c6a20f"><td class="memItemLeft" align="right" valign="top"><a id="aa8b43000ab834935f54e0ecb72c6a20f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#aa8b43000ab834935f54e0ecb72c6a20f">GateMap</a> (<a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:aa8b43000ab834935f54e0ecb72c6a20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move constructor. <br /></td></tr>
<tr class="separator:aa8b43000ab834935f54e0ecb72c6a20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788ccd2ec80ced369cb27ad89e9bfd65"><td class="memItemLeft" align="right" valign="top"><a id="a788ccd2ec80ced369cb27ad89e9bfd65"></a>
<a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#a788ccd2ec80ced369cb27ad89e9bfd65">operator=</a> (<a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a788ccd2ec80ced369cb27ad89e9bfd65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move assignment. <br /></td></tr>
<tr class="separator:a788ccd2ec80ced369cb27ad89e9bfd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23bbfe4ca9bd7174c397e820dc9187d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#ae23bbfe4ca9bd7174c397e820dc9187d">with_unitary</a> (Unbound &amp;&amp;key, <a class="el" href="namespacedqcsim_1_1wrap.html#acf8e6d9f573b415987645369e3160838">PredefinedGate</a> gate, int num_controls=-1, double epsilon=0.000001, bool ignore_global_phase=true)</td></tr>
<tr class="memdesc:ae23bbfe4ca9bd7174c397e820dc9187d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a unitary gate mapping for the given DQCsim-defined gate.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#ae23bbfe4ca9bd7174c397e820dc9187d">More...</a><br /></td></tr>
<tr class="separator:ae23bbfe4ca9bd7174c397e820dc9187d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7169020352ab88c6184eff4c6f883da5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#a7169020352ab88c6184eff4c6f883da5">with_unitary</a> (const Unbound &amp;key, <a class="el" href="namespacedqcsim_1_1wrap.html#acf8e6d9f573b415987645369e3160838">PredefinedGate</a> gate, int num_controls=-1, double epsilon=0.000001, bool ignore_global_phase=true)</td></tr>
<tr class="memdesc:a7169020352ab88c6184eff4c6f883da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a unitary gate mapping for the given DQCsim-defined gate.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#a7169020352ab88c6184eff4c6f883da5">More...</a><br /></td></tr>
<tr class="separator:a7169020352ab88c6184eff4c6f883da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb18294932137773a4b0cadc2077d61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#a1eb18294932137773a4b0cadc2077d61">with_unitary</a> (Unbound &amp;&amp;key, <a class="el" href="classdqcsim_1_1wrap_1_1_matrix.html">Matrix</a> &amp;&amp;matrix, int num_controls=-1, double epsilon=0.000001, bool ignore_global_phase=true)</td></tr>
<tr class="memdesc:a1eb18294932137773a4b0cadc2077d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a unitary gate mapping for the given unitary matrix.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#a1eb18294932137773a4b0cadc2077d61">More...</a><br /></td></tr>
<tr class="separator:a1eb18294932137773a4b0cadc2077d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618abbd318bfed9438e0311562627292"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#a618abbd318bfed9438e0311562627292">with_unitary</a> (const Unbound &amp;key, const <a class="el" href="classdqcsim_1_1wrap_1_1_matrix.html">Matrix</a> &amp;matrix, int num_controls=-1, double epsilon=0.000001, bool ignore_global_phase=true)</td></tr>
<tr class="memdesc:a618abbd318bfed9438e0311562627292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a unitary gate mapping for the given unitary matrix.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#a618abbd318bfed9438e0311562627292">More...</a><br /></td></tr>
<tr class="separator:a618abbd318bfed9438e0311562627292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc35bae271d4893c5796185dc6dcc599"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#abc35bae271d4893c5796185dc6dcc599">with_unitary</a> (Unbound &amp;&amp;key, const std::shared_ptr&lt; <a class="el" href="classdqcsim_1_1wrap_1_1_custom_unitary_gate_converter.html">CustomUnitaryGateConverter</a> &gt; &amp;converter)</td></tr>
<tr class="memdesc:abc35bae271d4893c5796185dc6dcc599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a custom unitary gate mapping.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#abc35bae271d4893c5796185dc6dcc599">More...</a><br /></td></tr>
<tr class="separator:abc35bae271d4893c5796185dc6dcc599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca04fae4d2a597b7940536ab470584c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#a6ca04fae4d2a597b7940536ab470584c">with_unitary</a> (const Unbound &amp;key, const std::shared_ptr&lt; <a class="el" href="classdqcsim_1_1wrap_1_1_custom_unitary_gate_converter.html">CustomUnitaryGateConverter</a> &gt; &amp;converter)</td></tr>
<tr class="memdesc:a6ca04fae4d2a597b7940536ab470584c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a custom unitary gate mapping.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#a6ca04fae4d2a597b7940536ab470584c">More...</a><br /></td></tr>
<tr class="separator:a6ca04fae4d2a597b7940536ab470584c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8011e8ba5932786bd1fc71ffb6e2550"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#af8011e8ba5932786bd1fc71ffb6e2550">with_measure</a> (Unbound &amp;&amp;key, <a class="el" href="namespacedqcsim_1_1wrap.html#aa3eed997b0e55a7760985ba1592fd262">PauliBasis</a> basis=<a class="el" href="namespacedqcsim_1_1wrap.html#aa3eed997b0e55a7760985ba1592fd262a02129bb861061d1a052c592e2dc6b383">PauliBasis::Z</a>, double epsilon=0.000001, int num_measures=-1)</td></tr>
<tr class="memdesc:af8011e8ba5932786bd1fc71ffb6e2550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a measurement gate mapping.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#af8011e8ba5932786bd1fc71ffb6e2550">More...</a><br /></td></tr>
<tr class="separator:af8011e8ba5932786bd1fc71ffb6e2550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d791327e9e2c7c8ad3c2e8a6f66611c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#a8d791327e9e2c7c8ad3c2e8a6f66611c">with_measure</a> (const Unbound &amp;key, <a class="el" href="namespacedqcsim_1_1wrap.html#aa3eed997b0e55a7760985ba1592fd262">PauliBasis</a> basis=<a class="el" href="namespacedqcsim_1_1wrap.html#aa3eed997b0e55a7760985ba1592fd262a02129bb861061d1a052c592e2dc6b383">PauliBasis::Z</a>, double epsilon=0.000001, int num_measures=-1)</td></tr>
<tr class="memdesc:a8d791327e9e2c7c8ad3c2e8a6f66611c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a measurement gate mapping.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#a8d791327e9e2c7c8ad3c2e8a6f66611c">More...</a><br /></td></tr>
<tr class="separator:a8d791327e9e2c7c8ad3c2e8a6f66611c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaceb3105ad65d4e294d32e6680bfd1bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#aaceb3105ad65d4e294d32e6680bfd1bd">with_measure</a> (Unbound &amp;&amp;key, <a class="el" href="classdqcsim_1_1wrap_1_1_matrix.html">Matrix</a> &amp;&amp;basis, double epsilon=0.000001, int num_measures=-1)</td></tr>
<tr class="memdesc:aaceb3105ad65d4e294d32e6680bfd1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a measurement gate mapping.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#aaceb3105ad65d4e294d32e6680bfd1bd">More...</a><br /></td></tr>
<tr class="separator:aaceb3105ad65d4e294d32e6680bfd1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5caf62041d17735e7410254b2d016bd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#a5caf62041d17735e7410254b2d016bd5">with_measure</a> (const Unbound &amp;key, const <a class="el" href="classdqcsim_1_1wrap_1_1_matrix.html">Matrix</a> &amp;basis, double epsilon=0.000001, int num_measures=-1)</td></tr>
<tr class="memdesc:a5caf62041d17735e7410254b2d016bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a measurement gate mapping.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#a5caf62041d17735e7410254b2d016bd5">More...</a><br /></td></tr>
<tr class="separator:a5caf62041d17735e7410254b2d016bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5f24a4b845534417df5ca9e87e76a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#aff5f24a4b845534417df5ca9e87e76a4">with_prep</a> (Unbound &amp;&amp;key, <a class="el" href="namespacedqcsim_1_1wrap.html#aa3eed997b0e55a7760985ba1592fd262">PauliBasis</a> basis=<a class="el" href="namespacedqcsim_1_1wrap.html#aa3eed997b0e55a7760985ba1592fd262a02129bb861061d1a052c592e2dc6b383">PauliBasis::Z</a>, double epsilon=0.000001, int num_targets=-1)</td></tr>
<tr class="memdesc:aff5f24a4b845534417df5ca9e87e76a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a prep gate mapping.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#aff5f24a4b845534417df5ca9e87e76a4">More...</a><br /></td></tr>
<tr class="separator:aff5f24a4b845534417df5ca9e87e76a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc95f1793c57ef888bf0a8c2b451434"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#a6fc95f1793c57ef888bf0a8c2b451434">with_prep</a> (const Unbound &amp;key, <a class="el" href="namespacedqcsim_1_1wrap.html#aa3eed997b0e55a7760985ba1592fd262">PauliBasis</a> basis=<a class="el" href="namespacedqcsim_1_1wrap.html#aa3eed997b0e55a7760985ba1592fd262a02129bb861061d1a052c592e2dc6b383">PauliBasis::Z</a>, double epsilon=0.000001, int num_targets=-1)</td></tr>
<tr class="memdesc:a6fc95f1793c57ef888bf0a8c2b451434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a prep gate mapping.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#a6fc95f1793c57ef888bf0a8c2b451434">More...</a><br /></td></tr>
<tr class="separator:a6fc95f1793c57ef888bf0a8c2b451434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae626505019b06ef37b9fe998595258d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#aae626505019b06ef37b9fe998595258d">with_prep</a> (Unbound &amp;&amp;key, <a class="el" href="classdqcsim_1_1wrap_1_1_matrix.html">Matrix</a> &amp;&amp;basis, double epsilon=0.000001, int num_targets=-1)</td></tr>
<tr class="memdesc:aae626505019b06ef37b9fe998595258d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a prep gate mapping.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#aae626505019b06ef37b9fe998595258d">More...</a><br /></td></tr>
<tr class="separator:aae626505019b06ef37b9fe998595258d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98cfd3b04998a3f3dd7293966b875e48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#a98cfd3b04998a3f3dd7293966b875e48">with_prep</a> (const Unbound &amp;key, const <a class="el" href="classdqcsim_1_1wrap_1_1_matrix.html">Matrix</a> &amp;basis, double epsilon=0.000001, int num_targets=-1)</td></tr>
<tr class="memdesc:a98cfd3b04998a3f3dd7293966b875e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a prep gate mapping.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#a98cfd3b04998a3f3dd7293966b875e48">More...</a><br /></td></tr>
<tr class="separator:a98cfd3b04998a3f3dd7293966b875e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3106290207f64057a6885f7519727c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#a2a3106290207f64057a6885f7519727c">with_custom</a> (Unbound &amp;&amp;key, const std::shared_ptr&lt; <a class="el" href="classdqcsim_1_1wrap_1_1_custom_gate_converter.html">CustomGateConverter</a> &gt; &amp;converter)</td></tr>
<tr class="memdesc:a2a3106290207f64057a6885f7519727c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a custom gate mapping.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#a2a3106290207f64057a6885f7519727c">More...</a><br /></td></tr>
<tr class="separator:a2a3106290207f64057a6885f7519727c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099ee5d0ad8ca01f30dccbedf92fae5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#a099ee5d0ad8ca01f30dccbedf92fae5e">with_custom</a> (const Unbound &amp;key, const std::shared_ptr&lt; <a class="el" href="classdqcsim_1_1wrap_1_1_custom_gate_converter.html">CustomGateConverter</a> &gt; &amp;converter)</td></tr>
<tr class="memdesc:a099ee5d0ad8ca01f30dccbedf92fae5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a custom gate mapping.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#a099ee5d0ad8ca01f30dccbedf92fae5e">More...</a><br /></td></tr>
<tr class="separator:a099ee5d0ad8ca01f30dccbedf92fae5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc99a1d2cd6899d4aa5d090261aea5a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#afc99a1d2cd6899d4aa5d090261aea5a6">detect</a> (const <a class="el" href="classdqcsim_1_1wrap_1_1_gate.html">Gate</a> &amp;gate, const Unbound **unbound, <a class="el" href="classdqcsim_1_1wrap_1_1_qubit_set.html">QubitSet</a> *qubits, <a class="el" href="classdqcsim_1_1wrap_1_1_arb_data.html">ArbData</a> *params)</td></tr>
<tr class="memdesc:afc99a1d2cd6899d4aa5d090261aea5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the gate map to convert an incoming DQCsim gate to the plugin's <code>Unbound</code> representation.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#afc99a1d2cd6899d4aa5d090261aea5a6">More...</a><br /></td></tr>
<tr class="separator:afc99a1d2cd6899d4aa5d090261aea5a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad86c0ca6e987c472cce7eb091ec6f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdqcsim_1_1wrap_1_1_gate.html">Gate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#acad86c0ca6e987c472cce7eb091ec6f6">construct</a> (const Unbound &amp;unbound, <a class="el" href="classdqcsim_1_1wrap_1_1_qubit_set.html">QubitSet</a> &amp;&amp;qubits, <a class="el" href="classdqcsim_1_1wrap_1_1_arb_data.html">ArbData</a> &amp;&amp;params)</td></tr>
<tr class="memdesc:acad86c0ca6e987c472cce7eb091ec6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses a gate map object to construct a DQCsim gate from the plugin's representation.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#acad86c0ca6e987c472cce7eb091ec6f6">More...</a><br /></td></tr>
<tr class="separator:acad86c0ca6e987c472cce7eb091ec6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40931144476754cd6f98f3733b75b610"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdqcsim_1_1wrap_1_1_gate.html">Gate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#a40931144476754cd6f98f3733b75b610">construct</a> (const Unbound &amp;unbound, const <a class="el" href="classdqcsim_1_1wrap_1_1_qubit_set.html">QubitSet</a> &amp;qubits, const <a class="el" href="classdqcsim_1_1wrap_1_1_arb_data.html">ArbData</a> &amp;params)</td></tr>
<tr class="memdesc:a40931144476754cd6f98f3733b75b610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses a gate map object to construct a DQCsim gate from the plugin's representation.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#a40931144476754cd6f98f3733b75b610">More...</a><br /></td></tr>
<tr class="separator:a40931144476754cd6f98f3733b75b610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f94f570b5eb4d6069a2329c448c5c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdqcsim_1_1wrap_1_1_gate.html">Gate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#a29f94f570b5eb4d6069a2329c448c5c3">construct</a> (const Unbound &amp;unbound, <a class="el" href="classdqcsim_1_1wrap_1_1_qubit_set.html">QubitSet</a> &amp;&amp;qubits)</td></tr>
<tr class="memdesc:a29f94f570b5eb4d6069a2329c448c5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses a gate map object to construct a DQCsim gate from the plugin's representation.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#a29f94f570b5eb4d6069a2329c448c5c3">More...</a><br /></td></tr>
<tr class="separator:a29f94f570b5eb4d6069a2329c448c5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dcd42b878a99ce65975e5018009b4c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdqcsim_1_1wrap_1_1_gate.html">Gate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#a3dcd42b878a99ce65975e5018009b4c7">construct</a> (const Unbound &amp;unbound, const <a class="el" href="classdqcsim_1_1wrap_1_1_qubit_set.html">QubitSet</a> &amp;qubits)</td></tr>
<tr class="memdesc:a3dcd42b878a99ce65975e5018009b4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses a gate map object to construct a DQCsim gate from the plugin's representation.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#a3dcd42b878a99ce65975e5018009b4c7">More...</a><br /></td></tr>
<tr class="separator:a3dcd42b878a99ce65975e5018009b4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67575988d459616af16d0b5a993f4628"><td class="memItemLeft" align="right" valign="top">Bound&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#a67575988d459616af16d0b5a993f4628">convert</a> (const <a class="el" href="classdqcsim_1_1wrap_1_1_gate.html">Gate</a> &amp;gate)</td></tr>
<tr class="memdesc:a67575988d459616af16d0b5a993f4628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function for <code><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#afc99a1d2cd6899d4aa5d090261aea5a6" title="Uses the gate map to convert an incoming DQCsim gate to the plugin&#39;s Unbound representation.">detect()</a></code>, converting from DQCsim's gate representation directly to the plugin's <code>Bound</code> gate type.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#a67575988d459616af16d0b5a993f4628">More...</a><br /></td></tr>
<tr class="separator:a67575988d459616af16d0b5a993f4628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb46948aed935fcf963c039a88e008d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdqcsim_1_1wrap_1_1_gate.html">Gate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#afb46948aed935fcf963c039a88e008d7">convert</a> (const Bound &amp;bound)</td></tr>
<tr class="memdesc:afb46948aed935fcf963c039a88e008d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function for <code><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#acad86c0ca6e987c472cce7eb091ec6f6" title="Uses a gate map object to construct a DQCsim gate from the plugin&#39;s representation.">construct()</a></code>, converting directly from the plugin's <code>Bound</code> gate type to DQCsim's gate representation.  <a href="classdqcsim_1_1wrap_1_1_gate_map.html#afb46948aed935fcf963c039a88e008d7">More...</a><br /></td></tr>
<tr class="separator:afb46948aed935fcf963c039a88e008d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classdqcsim_1_1wrap_1_1_handle"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdqcsim_1_1wrap_1_1_handle')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classdqcsim_1_1wrap_1_1_handle.html">dqcsim::wrap::Handle</a></td></tr>
<tr class="memitem:a017acb13e17e75bfb6afc1ade1a1dc08 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_handle.html#a017acb13e17e75bfb6afc1ade1a1dc08">Handle</a> () noexcept</td></tr>
<tr class="memdesc:a017acb13e17e75bfb6afc1ade1a1dc08 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty wrapper.  <a href="classdqcsim_1_1wrap_1_1_handle.html#a017acb13e17e75bfb6afc1ade1a1dc08">More...</a><br /></td></tr>
<tr class="separator:a017acb13e17e75bfb6afc1ade1a1dc08 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961083860ae70e06a637ed21e97c0ff2 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_handle.html#a961083860ae70e06a637ed21e97c0ff2">Handle</a> (<a class="el" href="namespacedqcsim_1_1wrap.html#af0961c9cf3940114db65b8d7260021e0">HandleIndex</a> <a class="el" href="classdqcsim_1_1wrap_1_1_handle.html#ac80648089082d159656cafa3610f5442">handle</a>) noexcept</td></tr>
<tr class="memdesc:a961083860ae70e06a637ed21e97c0ff2 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps the given raw handle.  <a href="classdqcsim_1_1wrap_1_1_handle.html#a961083860ae70e06a637ed21e97c0ff2">More...</a><br /></td></tr>
<tr class="separator:a961083860ae70e06a637ed21e97c0ff2 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac666eb66355e59b7e7f5a8f2513d638f inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memItemLeft" align="right" valign="top"><a id="ac666eb66355e59b7e7f5a8f2513d638f"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_handle.html#ac666eb66355e59b7e7f5a8f2513d638f">~Handle</a> () noexcept</td></tr>
<tr class="memdesc:ac666eb66355e59b7e7f5a8f2513d638f inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the handle and its wrapper. <br /></td></tr>
<tr class="separator:ac666eb66355e59b7e7f5a8f2513d638f inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4de6ec2c21a79f09fae646b41438ee inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_handle.html#a7c4de6ec2c21a79f09fae646b41438ee">free</a> ()</td></tr>
<tr class="memdesc:a7c4de6ec2c21a79f09fae646b41438ee inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly delete the handle, allowing errors to be caught.  <a href="classdqcsim_1_1wrap_1_1_handle.html#a7c4de6ec2c21a79f09fae646b41438ee">More...</a><br /></td></tr>
<tr class="separator:a7c4de6ec2c21a79f09fae646b41438ee inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca807386b06662933cd3bd988374aeb inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_handle.html#a7ca807386b06662933cd3bd988374aeb">is_valid</a> () const noexcept</td></tr>
<tr class="memdesc:a7ca807386b06662933cd3bd988374aeb inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this wrapper (still) contains a valid handle.  <a href="classdqcsim_1_1wrap_1_1_handle.html#a7ca807386b06662933cd3bd988374aeb">More...</a><br /></td></tr>
<tr class="separator:a7ca807386b06662933cd3bd988374aeb inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad984600fbf911d62ea875779a2dac309 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedqcsim_1_1wrap.html#af0961c9cf3940114db65b8d7260021e0">HandleIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_handle.html#ad984600fbf911d62ea875779a2dac309">get_handle</a> () const noexcept</td></tr>
<tr class="memdesc:ad984600fbf911d62ea875779a2dac309 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the raw handle without relinquishing ownership.  <a href="classdqcsim_1_1wrap_1_1_handle.html#ad984600fbf911d62ea875779a2dac309">More...</a><br /></td></tr>
<tr class="separator:ad984600fbf911d62ea875779a2dac309 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3de91c4d3780d76771c0caf12f23b7 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedqcsim_1_1wrap.html#af0961c9cf3940114db65b8d7260021e0">HandleIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_handle.html#afb3de91c4d3780d76771c0caf12f23b7">take_handle</a> () noexcept</td></tr>
<tr class="memdesc:afb3de91c4d3780d76771c0caf12f23b7 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the raw handle and relinquishes ownership.  <a href="classdqcsim_1_1wrap_1_1_handle.html#afb3de91c4d3780d76771c0caf12f23b7">More...</a><br /></td></tr>
<tr class="separator:afb3de91c4d3780d76771c0caf12f23b7 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965e7c831b9d6a8a95ddf097fd37f9f1 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memItemLeft" align="right" valign="top"><a id="a965e7c831b9d6a8a95ddf097fd37f9f1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Handle</b> (const <a class="el" href="classdqcsim_1_1wrap_1_1_handle.html">Handle</a> &amp;)=delete</td></tr>
<tr class="separator:a965e7c831b9d6a8a95ddf097fd37f9f1 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528e8404d885811015be6859e3659ae6 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memItemLeft" align="right" valign="top"><a id="a528e8404d885811015be6859e3659ae6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classdqcsim_1_1wrap_1_1_handle.html">Handle</a> &amp;)=delete</td></tr>
<tr class="separator:a528e8404d885811015be6859e3659ae6 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c19adcbfac59bc6017dfdc5dc72a150 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_handle.html#a0c19adcbfac59bc6017dfdc5dc72a150">Handle</a> (<a class="el" href="classdqcsim_1_1wrap_1_1_handle.html">Handle</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a0c19adcbfac59bc6017dfdc5dc72a150 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor; simply moves ownership of the handle from the source object to the constructed object.  <a href="classdqcsim_1_1wrap_1_1_handle.html#a0c19adcbfac59bc6017dfdc5dc72a150">More...</a><br /></td></tr>
<tr class="separator:a0c19adcbfac59bc6017dfdc5dc72a150 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d2a2bd0f058184a9713c3510bc4197 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdqcsim_1_1wrap_1_1_handle.html">Handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_handle.html#a67d2a2bd0f058184a9713c3510bc4197">operator=</a> (<a class="el" href="classdqcsim_1_1wrap_1_1_handle.html">Handle</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a67d2a2bd0f058184a9713c3510bc4197 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor; simply moves ownership of the handle from the source object to the assignment target.  <a href="classdqcsim_1_1wrap_1_1_handle.html#a67d2a2bd0f058184a9713c3510bc4197">More...</a><br /></td></tr>
<tr class="separator:a67d2a2bd0f058184a9713c3510bc4197 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78024ff86a0215bf8c4aeaebf48efedc inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_handle.html#a78024ff86a0215bf8c4aeaebf48efedc">dump</a> () const</td></tr>
<tr class="memdesc:a78024ff86a0215bf8c4aeaebf48efedc inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing a debug dump of the handle.  <a href="classdqcsim_1_1wrap_1_1_handle.html#a78024ff86a0215bf8c4aeaebf48efedc">More...</a><br /></td></tr>
<tr class="separator:a78024ff86a0215bf8c4aeaebf48efedc inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154d90a3ed18ecd47d2abbc4eb688226 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedqcsim_1_1wrap.html#a306249d3867840f6028c135e7d6e3c76">HandleType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_handle.html#a154d90a3ed18ecd47d2abbc4eb688226">type</a> () const</td></tr>
<tr class="memdesc:a154d90a3ed18ecd47d2abbc4eb688226 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of this handle.  <a href="classdqcsim_1_1wrap_1_1_handle.html#a154d90a3ed18ecd47d2abbc4eb688226">More...</a><br /></td></tr>
<tr class="separator:a154d90a3ed18ecd47d2abbc4eb688226 inherit pub_methods_classdqcsim_1_1wrap_1_1_handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classdqcsim_1_1wrap_1_1_handle"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classdqcsim_1_1wrap_1_1_handle')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classdqcsim_1_1wrap_1_1_handle.html">dqcsim::wrap::Handle</a></td></tr>
<tr class="memitem:ac80648089082d159656cafa3610f5442 inherit pro_attribs_classdqcsim_1_1wrap_1_1_handle"><td class="memItemLeft" align="right" valign="top"><a id="ac80648089082d159656cafa3610f5442"></a>
<a class="el" href="namespacedqcsim_1_1wrap.html#af0961c9cf3940114db65b8d7260021e0">HandleIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdqcsim_1_1wrap_1_1_handle.html#ac80648089082d159656cafa3610f5442">handle</a></td></tr>
<tr class="memdesc:ac80648089082d159656cafa3610f5442 inherit pro_attribs_classdqcsim_1_1wrap_1_1_handle"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wrapped handle. <br /></td></tr>
<tr class="separator:ac80648089082d159656cafa3610f5442 inherit pro_attribs_classdqcsim_1_1wrap_1_1_handle"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Unbound, class Bound = Unbound&gt;<br />
class dqcsim::wrap::GateMap&lt; Unbound, Bound &gt;</h3>

<p><a class="el" href="classdqcsim_1_1wrap_1_1_gate.html" title="Represents any kind of gate with qubits bound to it.">Gate</a> map wrapper class. </p>
<p><a class="el" href="classdqcsim_1_1wrap_1_1_gate.html" title="Represents any kind of gate with qubits bound to it.">Gate</a> maps are used to convert between DQCsim's gate representation and your own, given that your representation consists of the following:</p>
<ul>
<li>a hashable <code>Unbound</code> type representing a kind of gate with some amount of quantum and/or classical arguments that have not been bound yet;</li>
<li>a number of qubit arguments, representable as a <code><a class="el" href="classdqcsim_1_1wrap_1_1_qubit_set.html" title="Represents an ordered set of qubit references.">QubitSet</a></code>;</li>
<li>a number of classical arguments, representable as an <code><a class="el" href="classdqcsim_1_1wrap_1_1_arb_data.html" title="Class wrapper for ArbData handles.">ArbData</a></code>.</li>
</ul>
<p>The template expects that the <code>Unbound</code> and <code>Bound</code> types define the following methods:</p>
<ul>
<li><code>Unbound</code> must define a move or copy constructor.</li>
<li><code>Unbound::operator==</code> must be implemented properly.</li>
<li><code>std::hash&lt;Unbound&gt;</code> must be implemented properly.</li>
<li>If <code>Bound Unbound::bind(QubitSet &amp;&amp;qubits, ArbData &amp;&amp;params) const</code> is implemented, you can use the <code>Bound convert(Gate &amp;&amp;gate)</code> method. This is just a shorthand for <code><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#afc99a1d2cd6899d4aa5d090261aea5a6" title="Uses the gate map to convert an incoming DQCsim gate to the plugin&#39;s Unbound representation.">detect()</a></code>, which you can always use.</li>
<li>If <code>Unbound Bound::get_unbound() const</code>, <code><a class="el" href="classdqcsim_1_1wrap_1_1_qubit_set.html" title="Represents an ordered set of qubit references.">QubitSet</a> Bound::get_qubits() const</code>, and <code><a class="el" href="classdqcsim_1_1wrap_1_1_arb_data.html" title="Class wrapper for ArbData handles.">ArbData</a> Bound::get_params() const</code> are implemented, you can use the <code><a class="el" href="classdqcsim_1_1wrap_1_1_gate.html" title="Represents any kind of gate with qubits bound to it.">Gate</a> convert(Bound &amp;&amp;bound)</code> method. This is just a shorthand for <code><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#acad86c0ca6e987c472cce7eb091ec6f6" title="Uses a gate map object to construct a DQCsim gate from the plugin&#39;s representation.">construct()</a></code>, which you can always use.</li>
</ul>
<p>Note that the <code>Unbound</code> and <code>Bound</code> types can be one and the same, and by default are.</p>
<p>DQCsim provides a number of predefined converters to detect and construct commonly used gates, but for more complex gates you'll of course have to define your own conversion functions.</p>
<p>For more information, refer to the C API documentation. </p>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l04750">4750</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abfe6c5268739501b6f6c47acec8c5f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe6c5268739501b6f6c47acec8c5f02">&#9670;&nbsp;</a></span>GateMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::<a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedqcsim_1_1wrap.html#af0961c9cf3940114db65b8d7260021e0">HandleIndex</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps the given gate map handle. </p>
<dl class="section note"><dt>Note</dt><dd>This constructor does not verify that the handle is actually valid.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The raw handle to wrap. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l04785">4785</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<a id="afe67890a4a06249ae4d192bc354db4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe67890a4a06249ae4d192bc354db4ab">&#9670;&nbsp;</a></span>GateMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::<a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strip_qubit_refs</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strip_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new gate map. </p>
<p><a class="el" href="classdqcsim_1_1wrap_1_1_gate.html" title="Represents any kind of gate with qubits bound to it.">Gate</a> maps objects retain a cache to speed up detection of similar DQCsim gates: if a gate is received for the second time, the cache will hit, avoiding recomputation of the detector functions. What constitutes "similar gates" is defined by the two booleans passed to this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strip_qubit_refs</td><td>If set, all qubit references associated with the gate will be invalidated (i.e., set to 0), such that for instance an X gate applied to qubit 1 will be considered equal to an X gate applied to qubit 2. </td></tr>
    <tr><td class="paramname">strip_data</td><td>If set, the <code><a class="el" href="classdqcsim_1_1wrap_1_1_arb_data.html" title="Class wrapper for ArbData handles.">ArbData</a></code> associated with the incoming gate is removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The constructed gate map. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When construction of the gate map fails. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If you get template errors, ensure that your <code>Unbound</code> type is hashable with <code>std::hash</code> and has a defined equality operator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l04807">4807</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae23bbfe4ca9bd7174c397e820dc9187d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23bbfe4ca9bd7174c397e820dc9187d">&#9670;&nbsp;</a></span>with_unitary() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a>&amp;&amp; <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::with_unitary </td>
          <td>(</td>
          <td class="paramtype">Unbound &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedqcsim_1_1wrap.html#acf8e6d9f573b415987645369e3160838">PredefinedGate</a>&#160;</td>
          <td class="paramname"><em>gate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_controls</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.000001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_global_phase</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a unitary gate mapping for the given DQCsim-defined gate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The <code>Unbound</code> object that refers to this type of gate in your representation. </td></tr>
    <tr><td class="paramname">gate</td><td>The predefined DQCsim gate to detect. </td></tr>
    <tr><td class="paramname">num_controls</td><td>The number of control qubits for this type of gate. If negative, the gate can be controlled with any number of qubits or not controlled; disambiguation is done based on the number of qubit arguments. If zero, the gate is always non-controlled. If positive, the gate always has the specified number of control qubits. </td></tr>
    <tr><td class="paramname">epsilon</td><td>The maximum RMS error used when detecting incoming gate matrices. Defaults to 1 ppm. </td></tr>
    <tr><td class="paramname">ignore_global_phase</td><td>Whether global phase should be ignored when detecting incoming gate matrices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>&amp;self</code>, to continue building. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When the gate map handle is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the key is equal to a the key for a previously added converter, the previous converter is silently overwritten. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you get template errors, ensure that your <code>Unbound</code> type has a move constructor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l04847">4847</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<a id="a7169020352ab88c6184eff4c6f883da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7169020352ab88c6184eff4c6f883da5">&#9670;&nbsp;</a></span>with_unitary() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a>&amp;&amp; <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::with_unitary </td>
          <td>(</td>
          <td class="paramtype">const Unbound &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedqcsim_1_1wrap.html#acf8e6d9f573b415987645369e3160838">PredefinedGate</a>&#160;</td>
          <td class="paramname"><em>gate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_controls</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.000001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_global_phase</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a unitary gate mapping for the given DQCsim-defined gate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The <code>Unbound</code> object that refers to this type of gate in your representation. </td></tr>
    <tr><td class="paramname">gate</td><td>The predefined DQCsim gate to detect. </td></tr>
    <tr><td class="paramname">num_controls</td><td>The number of control qubits for this type of gate. If negative, the gate can be controlled with any number of qubits or not controlled; disambiguation is done based on the number of qubit arguments. If zero, the gate is always non-controlled. If positive, the gate always has the specified number of control qubits. </td></tr>
    <tr><td class="paramname">epsilon</td><td>The maximum RMS error used when detecting incoming gate matrices. Defaults to 1 ppm. </td></tr>
    <tr><td class="paramname">ignore_global_phase</td><td>Whether global phase should be ignored when detecting incoming gate matrices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>&amp;self</code>, to continue building. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When the gate map handle is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the key is equal to a the key for a previously added converter, the previous converter is silently overwritten. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you get template errors, ensure that your <code>Unbound</code> type has a copy constructor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l04888">4888</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<a id="a1eb18294932137773a4b0cadc2077d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb18294932137773a4b0cadc2077d61">&#9670;&nbsp;</a></span>with_unitary() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a>&amp;&amp; <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::with_unitary </td>
          <td>(</td>
          <td class="paramtype">Unbound &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdqcsim_1_1wrap_1_1_matrix.html">Matrix</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_controls</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.000001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_global_phase</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a unitary gate mapping for the given unitary matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The <code>Unbound</code> object that refers to this type of gate in your representation. </td></tr>
    <tr><td class="paramname">matrix</td><td>The matrix to detect. </td></tr>
    <tr><td class="paramname">num_controls</td><td>The number of control qubits for this type of gate. If negative, the gate can be controlled with any number of qubits or not controlled; disambiguation is done based on the number of qubit arguments. If zero, the gate is always non-controlled. If positive, the gate always has the specified number of control qubits. </td></tr>
    <tr><td class="paramname">epsilon</td><td>The maximum RMS error used when detecting incoming gate matrices. Defaults to 1 ppm. </td></tr>
    <tr><td class="paramname">ignore_global_phase</td><td>Whether global phase should be ignored when detecting incoming gate matrices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>&amp;self</code>, to continue building. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When the gate map handle is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the key is equal to a the key for a previously added converter, the previous converter is silently overwritten. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you get template errors, ensure that your <code>Unbound</code> type has a move constructor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l04929">4929</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<a id="a618abbd318bfed9438e0311562627292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618abbd318bfed9438e0311562627292">&#9670;&nbsp;</a></span>with_unitary() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a>&amp;&amp; <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::with_unitary </td>
          <td>(</td>
          <td class="paramtype">const Unbound &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdqcsim_1_1wrap_1_1_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_controls</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.000001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_global_phase</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a unitary gate mapping for the given unitary matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The <code>Unbound</code> object that refers to this type of gate in your representation. </td></tr>
    <tr><td class="paramname">matrix</td><td>The matrix to detect. </td></tr>
    <tr><td class="paramname">num_controls</td><td>The number of control qubits for this type of gate. If negative, the gate can be controlled with any number of qubits or not controlled; disambiguation is done based on the number of qubit arguments. If zero, the gate is always non-controlled. If positive, the gate always has the specified number of control qubits. </td></tr>
    <tr><td class="paramname">epsilon</td><td>The maximum RMS error used when detecting incoming gate matrices. Defaults to 1 ppm. </td></tr>
    <tr><td class="paramname">ignore_global_phase</td><td>Whether global phase should be ignored when detecting incoming gate matrices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>&amp;self</code>, to continue building. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When the gate map handle is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the key is equal to a the key for a previously added converter, the previous converter is silently overwritten. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you get template errors, ensure that your <code>Unbound</code> type has a copy constructor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l04970">4970</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<a id="abc35bae271d4893c5796185dc6dcc599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc35bae271d4893c5796185dc6dcc599">&#9670;&nbsp;</a></span>with_unitary() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a>&amp;&amp; <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::with_unitary </td>
          <td>(</td>
          <td class="paramtype">Unbound &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdqcsim_1_1wrap_1_1_custom_unitary_gate_converter.html">CustomUnitaryGateConverter</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a custom unitary gate mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The <code>Unbound</code> object that refers to this type of gate in your representation. </td></tr>
    <tr><td class="paramname">converter</td><td>An object deriving from <code><a class="el" href="classdqcsim_1_1wrap_1_1_custom_unitary_gate_converter.html" title="Class that you can inherit from to make your own unitary gate converter for use within DQCsim.">CustomUnitaryGateConverter</a></code>, implemented by you to handle the conversion, wrapped in a <code>std::shared_ptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When the gate map handle is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the key is equal to a the key for a previously added converter, the previous converter is silently overwritten. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you get template errors, ensure that your <code>Unbound</code> type has a move constructor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l05003">5003</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<a id="a6ca04fae4d2a597b7940536ab470584c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca04fae4d2a597b7940536ab470584c">&#9670;&nbsp;</a></span>with_unitary() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a>&amp;&amp; <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::with_unitary </td>
          <td>(</td>
          <td class="paramtype">const Unbound &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdqcsim_1_1wrap_1_1_custom_unitary_gate_converter.html">CustomUnitaryGateConverter</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a custom unitary gate mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The <code>Unbound</code> object that refers to this type of gate in your representation. </td></tr>
    <tr><td class="paramname">converter</td><td>An object deriving from <code><a class="el" href="classdqcsim_1_1wrap_1_1_custom_unitary_gate_converter.html" title="Class that you can inherit from to make your own unitary gate converter for use within DQCsim.">CustomUnitaryGateConverter</a></code>, implemented by you to handle the conversion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>&amp;self</code>, to continue building. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When the gate map handle is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the key is equal to a the key for a previously added converter, the previous converter is silently overwritten. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you get template errors, ensure that your <code>Unbound</code> type has a copy constructor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l05035">5035</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<a id="af8011e8ba5932786bd1fc71ffb6e2550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8011e8ba5932786bd1fc71ffb6e2550">&#9670;&nbsp;</a></span>with_measure() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a>&amp;&amp; <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::with_measure </td>
          <td>(</td>
          <td class="paramtype">Unbound &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedqcsim_1_1wrap.html#aa3eed997b0e55a7760985ba1592fd262">PauliBasis</a>&#160;</td>
          <td class="paramname"><em>basis</em> = <code><a class="el" href="namespacedqcsim_1_1wrap.html#aa3eed997b0e55a7760985ba1592fd262a02129bb861061d1a052c592e2dc6b383">PauliBasis::Z</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.000001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_measures</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a measurement gate mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The <code>Unbound</code> object that refers to this type of gate in your representation. </td></tr>
    <tr><td class="paramname">basis</td><td>The measurement basis. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Maximum RMS deviation when detecting the above basis. </td></tr>
    <tr><td class="paramname">num_measures</td><td>The number of measurement qubits for this type of gate. If negative, the gate can measure any number of qubits at a time. If positive, the gate always has the specified number of measurement qubits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>&amp;self</code>, to continue building. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When the gate map handle is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the key is equal to a the key for a previously added converter, the previous converter is silently overwritten. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you get template errors, ensure that your <code>Unbound</code> type has a move constructor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l05071">5071</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<a id="a8d791327e9e2c7c8ad3c2e8a6f66611c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d791327e9e2c7c8ad3c2e8a6f66611c">&#9670;&nbsp;</a></span>with_measure() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a>&amp;&amp; <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::with_measure </td>
          <td>(</td>
          <td class="paramtype">const Unbound &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedqcsim_1_1wrap.html#aa3eed997b0e55a7760985ba1592fd262">PauliBasis</a>&#160;</td>
          <td class="paramname"><em>basis</em> = <code><a class="el" href="namespacedqcsim_1_1wrap.html#aa3eed997b0e55a7760985ba1592fd262a02129bb861061d1a052c592e2dc6b383">PauliBasis::Z</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.000001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_measures</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a measurement gate mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The <code>Unbound</code> object that refers to this type of gate in your representation. </td></tr>
    <tr><td class="paramname">basis</td><td>The measurement basis. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Maximum RMS deviation when detecting the above basis. </td></tr>
    <tr><td class="paramname">num_measures</td><td>The number of measurement qubits for this type of gate. If negative, the gate can measure any number of qubits at a time. If positive, the gate always has the specified number of measurement qubits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>&amp;self</code>, to continue building. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When the gate map handle is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the key is equal to a the key for a previously added converter, the previous converter is silently overwritten. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you get template errors, ensure that your <code>Unbound</code> type has a copy constructor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l05106">5106</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<a id="aaceb3105ad65d4e294d32e6680bfd1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaceb3105ad65d4e294d32e6680bfd1bd">&#9670;&nbsp;</a></span>with_measure() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a>&amp;&amp; <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::with_measure </td>
          <td>(</td>
          <td class="paramtype">Unbound &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdqcsim_1_1wrap_1_1_matrix.html">Matrix</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.000001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_measures</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a measurement gate mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The <code>Unbound</code> object that refers to this type of gate in your representation. </td></tr>
    <tr><td class="paramname">basis</td><td>The measurement basis. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Maximum RMS deviation when detecting the above basis. </td></tr>
    <tr><td class="paramname">num_measures</td><td>The number of measurement qubits for this type of gate. If negative, the gate can measure any number of qubits at a time. If positive, the gate always has the specified number of measurement qubits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>&amp;self</code>, to continue building. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When the gate map handle is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the key is equal to a the key for a previously added converter, the previous converter is silently overwritten. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you get template errors, ensure that your <code>Unbound</code> type has a move constructor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l05141">5141</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<a id="a5caf62041d17735e7410254b2d016bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5caf62041d17735e7410254b2d016bd5">&#9670;&nbsp;</a></span>with_measure() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a>&amp;&amp; <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::with_measure </td>
          <td>(</td>
          <td class="paramtype">const Unbound &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdqcsim_1_1wrap_1_1_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.000001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_measures</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a measurement gate mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The <code>Unbound</code> object that refers to this type of gate in your representation. </td></tr>
    <tr><td class="paramname">basis</td><td>The measurement basis. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Maximum RMS deviation when detecting the above basis. </td></tr>
    <tr><td class="paramname">num_measures</td><td>The number of measurement qubits for this type of gate. If negative, the gate can measure any number of qubits at a time. If positive, the gate always has the specified number of measurement qubits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>&amp;self</code>, to continue building. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When the gate map handle is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the key is equal to a the key for a previously added converter, the previous converter is silently overwritten. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you get template errors, ensure that your <code>Unbound</code> type has a copy constructor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l05176">5176</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<a id="aff5f24a4b845534417df5ca9e87e76a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff5f24a4b845534417df5ca9e87e76a4">&#9670;&nbsp;</a></span>with_prep() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a>&amp;&amp; <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::with_prep </td>
          <td>(</td>
          <td class="paramtype">Unbound &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedqcsim_1_1wrap.html#aa3eed997b0e55a7760985ba1592fd262">PauliBasis</a>&#160;</td>
          <td class="paramname"><em>basis</em> = <code><a class="el" href="namespacedqcsim_1_1wrap.html#aa3eed997b0e55a7760985ba1592fd262a02129bb861061d1a052c592e2dc6b383">PauliBasis::Z</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.000001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_targets</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a prep gate mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The <code>Unbound</code> object that refers to this type of gate in your representation. </td></tr>
    <tr><td class="paramname">basis</td><td>The basis. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Maximum RMS deviation when detecting the above basis. </td></tr>
    <tr><td class="paramname">num_targets</td><td>The number of target qubits for this type of gate. If negative, the gate can prepare any number of qubits at a time. If positive, the gate always has the specified number of target qubits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>&amp;self</code>, to continue building. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When the gate map handle is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the key is equal to a the key for a previously added converter, the previous converter is silently overwritten. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you get template errors, ensure that your <code>Unbound</code> type has a move constructor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l05211">5211</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<a id="a6fc95f1793c57ef888bf0a8c2b451434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc95f1793c57ef888bf0a8c2b451434">&#9670;&nbsp;</a></span>with_prep() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a>&amp;&amp; <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::with_prep </td>
          <td>(</td>
          <td class="paramtype">const Unbound &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedqcsim_1_1wrap.html#aa3eed997b0e55a7760985ba1592fd262">PauliBasis</a>&#160;</td>
          <td class="paramname"><em>basis</em> = <code><a class="el" href="namespacedqcsim_1_1wrap.html#aa3eed997b0e55a7760985ba1592fd262a02129bb861061d1a052c592e2dc6b383">PauliBasis::Z</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.000001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_targets</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a prep gate mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The <code>Unbound</code> object that refers to this type of gate in your representation. </td></tr>
    <tr><td class="paramname">basis</td><td>The basis. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Maximum RMS deviation when detecting the above basis. </td></tr>
    <tr><td class="paramname">num_targets</td><td>The number of target qubits for this type of gate. If negative, the gate can prepare any number of qubits at a time. If positive, the gate always has the specified number of target qubits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>&amp;self</code>, to continue building. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When the gate map handle is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the key is equal to a the key for a previously added converter, the previous converter is silently overwritten. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you get template errors, ensure that your <code>Unbound</code> type has a move constructor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l05246">5246</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<a id="aae626505019b06ef37b9fe998595258d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae626505019b06ef37b9fe998595258d">&#9670;&nbsp;</a></span>with_prep() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a>&amp;&amp; <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::with_prep </td>
          <td>(</td>
          <td class="paramtype">Unbound &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdqcsim_1_1wrap_1_1_matrix.html">Matrix</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.000001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_targets</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a prep gate mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The <code>Unbound</code> object that refers to this type of gate in your representation. </td></tr>
    <tr><td class="paramname">basis</td><td>The basis. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Maximum RMS deviation when detecting the above basis. </td></tr>
    <tr><td class="paramname">num_targets</td><td>The number of target qubits for this type of gate. If negative, the gate can prepare any number of qubits at a time. If positive, the gate always has the specified number of target qubits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>&amp;self</code>, to continue building. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When the gate map handle is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the key is equal to a the key for a previously added converter, the previous converter is silently overwritten. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you get template errors, ensure that your <code>Unbound</code> type has a move constructor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l05281">5281</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<a id="a98cfd3b04998a3f3dd7293966b875e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98cfd3b04998a3f3dd7293966b875e48">&#9670;&nbsp;</a></span>with_prep() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a>&amp;&amp; <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::with_prep </td>
          <td>(</td>
          <td class="paramtype">const Unbound &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdqcsim_1_1wrap_1_1_matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>0.000001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_targets</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a prep gate mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The <code>Unbound</code> object that refers to this type of gate in your representation. </td></tr>
    <tr><td class="paramname">basis</td><td>The basis. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Maximum RMS deviation when detecting the above basis. </td></tr>
    <tr><td class="paramname">num_targets</td><td>The number of target qubits for this type of gate. If negative, the gate can prepare any number of qubits at a time. If positive, the gate always has the specified number of target qubits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>&amp;self</code>, to continue building. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When the gate map handle is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the key is equal to a the key for a previously added converter, the previous converter is silently overwritten. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you get template errors, ensure that your <code>Unbound</code> type has a move constructor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l05316">5316</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<a id="a2a3106290207f64057a6885f7519727c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3106290207f64057a6885f7519727c">&#9670;&nbsp;</a></span>with_custom() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a>&amp;&amp; <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::with_custom </td>
          <td>(</td>
          <td class="paramtype">Unbound &amp;&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdqcsim_1_1wrap_1_1_custom_gate_converter.html">CustomGateConverter</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a custom gate mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The <code>Unbound</code> object that refers to this type of gate in your representation. </td></tr>
    <tr><td class="paramname">converter</td><td>An object deriving from <code><a class="el" href="classdqcsim_1_1wrap_1_1_custom_gate_converter.html" title="Class that you can inherit from to make your own custom gate converter for use within DQCsim.">CustomGateConverter</a></code>, implemented by you to handle the conversion, wrapped in a <code>std::shared_ptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When the gate map handle is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the key is equal to a the key for a previously added converter, the previous converter is silently overwritten. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you get template errors, ensure that your <code>Unbound</code> type has a move constructor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l05347">5347</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<a id="a099ee5d0ad8ca01f30dccbedf92fae5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099ee5d0ad8ca01f30dccbedf92fae5e">&#9670;&nbsp;</a></span>with_custom() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">GateMap</a>&amp;&amp; <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::with_custom </td>
          <td>(</td>
          <td class="paramtype">const Unbound &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classdqcsim_1_1wrap_1_1_custom_gate_converter.html">CustomGateConverter</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a custom gate mapping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The <code>Unbound</code> object that refers to this type of gate in your representation. </td></tr>
    <tr><td class="paramname">converter</td><td>An object deriving from <code><a class="el" href="classdqcsim_1_1wrap_1_1_custom_gate_converter.html" title="Class that you can inherit from to make your own custom gate converter for use within DQCsim.">CustomGateConverter</a></code>, implemented by you to handle the conversion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>&amp;self</code>, to continue building. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When the gate map handle is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If the key is equal to a the key for a previously added converter, the previous converter is silently overwritten. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you get template errors, ensure that your <code>Unbound</code> type has a copy constructor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l05379">5379</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<a id="afc99a1d2cd6899d4aa5d090261aea5a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc99a1d2cd6899d4aa5d090261aea5a6">&#9670;&nbsp;</a></span>detect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::detect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdqcsim_1_1wrap_1_1_gate.html">Gate</a> &amp;&#160;</td>
          <td class="paramname"><em>gate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Unbound **&#160;</td>
          <td class="paramname"><em>unbound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdqcsim_1_1wrap_1_1_qubit_set.html">QubitSet</a> *&#160;</td>
          <td class="paramname"><em>qubits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdqcsim_1_1wrap_1_1_arb_data.html">ArbData</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses the gate map to convert an incoming DQCsim gate to the plugin's <code>Unbound</code> representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gate</td><td>The gate to detect. </td></tr>
    <tr><td class="paramname">unbound</td><td>If non-null and the incoming gate matches one of the detectors, this receives a const pointer to the internal <code>Unbound</code> record corresponding with the first detector that matched. If there is no match, this is left unchanged, allowing a default value to be supplied. </td></tr>
    <tr><td class="paramname">qubits</td><td>If non-null and the incoming gate matches one of the detectors, the given <code><a class="el" href="classdqcsim_1_1wrap_1_1_qubit_set.html" title="Represents an ordered set of qubit references.">QubitSet</a></code> is set to the qubit arguments for the matched gate. </td></tr>
    <tr><td class="paramname">params</td><td>If non-null and the incoming gate matches one of the detectors, the given <code><a class="el" href="classdqcsim_1_1wrap_1_1_arb_data.html" title="Class wrapper for ArbData handles.">ArbData</a></code> is set to the parameterization data object returned by the detector function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether a match occurred. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When one of the handles is invalid or one of the detector functions returned an error. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l05417">5417</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<a id="acad86c0ca6e987c472cce7eb091ec6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad86c0ca6e987c472cce7eb091ec6f6">&#9670;&nbsp;</a></span>construct() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdqcsim_1_1wrap_1_1_gate.html">Gate</a> <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">const Unbound &amp;&#160;</td>
          <td class="paramname"><em>unbound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdqcsim_1_1wrap_1_1_qubit_set.html">QubitSet</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>qubits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdqcsim_1_1wrap_1_1_arb_data.html">ArbData</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses a gate map object to construct a DQCsim gate from the plugin's representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unbound</td><td>The plugin's representation of the unbound gate. </td></tr>
    <tr><td class="paramname">qubits</td><td>The qubit arguments for the gate. </td></tr>
    <tr><td class="paramname">params</td><td>The parameterization data for the gate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The constructed DQCsim gate. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When <code>unbound</code> does not map to any converter function, the converter function returns an error, or one of the involved handles is invalid. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l05451">5451</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<a id="a40931144476754cd6f98f3733b75b610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40931144476754cd6f98f3733b75b610">&#9670;&nbsp;</a></span>construct() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdqcsim_1_1wrap_1_1_gate.html">Gate</a> <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">const Unbound &amp;&#160;</td>
          <td class="paramname"><em>unbound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdqcsim_1_1wrap_1_1_qubit_set.html">QubitSet</a> &amp;&#160;</td>
          <td class="paramname"><em>qubits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdqcsim_1_1wrap_1_1_arb_data.html">ArbData</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses a gate map object to construct a DQCsim gate from the plugin's representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unbound</td><td>The plugin's representation of the unbound gate. </td></tr>
    <tr><td class="paramname">qubits</td><td>The qubit arguments for the gate. </td></tr>
    <tr><td class="paramname">params</td><td>The parameterization data for the gate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The constructed DQCsim gate. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When <code>unbound</code> does not map to any converter function, the converter function returns an error, or one of the involved handles is invalid. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l05476">5476</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<a id="a29f94f570b5eb4d6069a2329c448c5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f94f570b5eb4d6069a2329c448c5c3">&#9670;&nbsp;</a></span>construct() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdqcsim_1_1wrap_1_1_gate.html">Gate</a> <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">const Unbound &amp;&#160;</td>
          <td class="paramname"><em>unbound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdqcsim_1_1wrap_1_1_qubit_set.html">QubitSet</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>qubits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses a gate map object to construct a DQCsim gate from the plugin's representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unbound</td><td>The plugin's representation of the unbound gate. </td></tr>
    <tr><td class="paramname">qubits</td><td>The qubit arguments for the gate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When <code>unbound</code> does not map to any converter function, the converter function returns an error, or one of the involved handles is invalid. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l05494">5494</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<a id="a3dcd42b878a99ce65975e5018009b4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dcd42b878a99ce65975e5018009b4c7">&#9670;&nbsp;</a></span>construct() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdqcsim_1_1wrap_1_1_gate.html">Gate</a> <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::construct </td>
          <td>(</td>
          <td class="paramtype">const Unbound &amp;&#160;</td>
          <td class="paramname"><em>unbound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdqcsim_1_1wrap_1_1_qubit_set.html">QubitSet</a> &amp;&#160;</td>
          <td class="paramname"><em>qubits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses a gate map object to construct a DQCsim gate from the plugin's representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unbound</td><td>The plugin's representation of the unbound gate. </td></tr>
    <tr><td class="paramname">qubits</td><td>The qubit arguments for the gate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The constructed DQCsim gate. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When <code>unbound</code> does not map to any converter function, the converter function returns an error, or one of the involved handles is invalid. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l05517">5517</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<a id="a67575988d459616af16d0b5a993f4628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67575988d459616af16d0b5a993f4628">&#9670;&nbsp;</a></span>convert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Bound <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::convert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdqcsim_1_1wrap_1_1_gate.html">Gate</a> &amp;&#160;</td>
          <td class="paramname"><em>gate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper function for <code><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#afc99a1d2cd6899d4aa5d090261aea5a6" title="Uses the gate map to convert an incoming DQCsim gate to the plugin&#39;s Unbound representation.">detect()</a></code>, converting from DQCsim's gate representation directly to the plugin's <code>Bound</code> gate type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gate</td><td>The gate to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted gate. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When the DQCsim gate cannot be represented in the plugin's representation, one of the handles is invalid, or one of the detector functions returned an error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If you get template errors, ensure that <code>Bound Unbound::bind(QubitSet &amp;&amp;qubits, ArbData &amp;&amp;params) const</code> exists. This method is used to convert from the return values of <code><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#afc99a1d2cd6899d4aa5d090261aea5a6" title="Uses the gate map to convert an incoming DQCsim gate to the plugin&#39;s Unbound representation.">detect()</a></code> to an instance of <code>Bound</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l05538">5538</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<a id="afb46948aed935fcf963c039a88e008d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb46948aed935fcf963c039a88e008d7">&#9670;&nbsp;</a></span>convert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Unbound , class Bound  = Unbound&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdqcsim_1_1wrap_1_1_gate.html">Gate</a> <a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html">dqcsim::wrap::GateMap</a>&lt; Unbound, Bound &gt;::convert </td>
          <td>(</td>
          <td class="paramtype">const Bound &amp;&#160;</td>
          <td class="paramname"><em>bound</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper function for <code><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#acad86c0ca6e987c472cce7eb091ec6f6" title="Uses a gate map object to construct a DQCsim gate from the plugin&#39;s representation.">construct()</a></code>, converting directly from the plugin's <code>Bound</code> gate type to DQCsim's gate representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bound</td><td>The plugin's gate representation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DQCsim's gate representation for the above. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When <code>bound</code> does not map to any converter function, the converter function returns an error, or one of the involved handles is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If you get template errors, ensure that <code>Unbound Bound::get_unbound() const</code>, <code><a class="el" href="classdqcsim_1_1wrap_1_1_qubit_set.html" title="Represents an ordered set of qubit references.">QubitSet</a> Bound::get_qubits() const</code>, and <code><a class="el" href="classdqcsim_1_1wrap_1_1_arb_data.html" title="Class wrapper for ArbData handles.">ArbData</a> Bound::get_params() const</code> are implemented. These methods are used to convert from the <code>Bound</code> gate to the inputs of <code><a class="el" href="classdqcsim_1_1wrap_1_1_gate_map.html#acad86c0ca6e987c472cce7eb091ec6f6" title="Uses a gate map object to construct a DQCsim gate from the plugin&#39;s representation.">construct()</a></code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dqcsim_source.html#l05563">5563</a> of file <a class="el" href="dqcsim_source.html">dqcsim</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="dqcsim_source.html">dqcsim</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.19
</small></address>
</body>
</html>
