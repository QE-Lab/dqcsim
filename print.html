<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>DQCsim</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction to DQCsim</a></li><li><ol class="section"><li class="expanded "><a href="intro/components.html"><strong aria-hidden="true">1.1.</strong> The components of a simulation</a></li><li><ol class="section"><li class="expanded "><a href="intro/frontend.html"><strong aria-hidden="true">1.1.1.</strong> Frontend use cases</a></li><li class="expanded "><a href="intro/backend.html"><strong aria-hidden="true">1.1.2.</strong> Backend use cases</a></li><li class="expanded "><a href="intro/operator.html"><strong aria-hidden="true">1.1.3.</strong> Operator use cases</a></li><li class="expanded "><a href="intro/host.html"><strong aria-hidden="true">1.1.4.</strong> Host use cases</a></li></ol></li><li class="expanded "><a href="intro/puzzle.html"><strong aria-hidden="true">1.2.</strong> Jigsaw puzzle analogy</a></li><li class="expanded "><a href="intro/interfaces.html"><strong aria-hidden="true">1.3.</strong> DQCsim's interfaces</a></li><li><ol class="section"><li class="expanded "><a href="intro/arbs.html"><strong aria-hidden="true">1.3.1.</strong> ArbData and ArbCmds</a></li><li class="expanded "><a href="intro/gatestream.html"><strong aria-hidden="true">1.3.2.</strong> Gate- and measurement streams</a></li><li class="expanded "><a href="intro/host-iface.html"><strong aria-hidden="true">1.3.3.</strong> The host interface</a></li><li class="expanded "><a href="intro/misc-iface.html"><strong aria-hidden="true">1.3.4.</strong> Miscellaneous interfaces</a></li></ol></li><li class="expanded "><a href="intro/reproducibility.html"><strong aria-hidden="true">1.4.</strong> Reproducibility</a></li></ol></li><li class="expanded "><a href="install/index.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li><ol class="section"><li class="expanded "><a href="install/plugins.html"><strong aria-hidden="true">2.1.</strong> Plugin distribution</a></li></ol></li><li class="expanded "><a href="cli/index.html"><strong aria-hidden="true">3.</strong> The command-line interface</a></li><li class="expanded "><a href="python-api/index.html"><strong aria-hidden="true">4.</strong> Python API</a></li><li><ol class="section"><li class="expanded "><a href="python-api/hello-world.html"><strong aria-hidden="true">4.1.</strong> Hello, world!</a></li><li class="expanded "><a href="python-api/debugging.html"><strong aria-hidden="true">4.2.</strong> Debugging</a></li><li class="expanded "><a href="python-api/sending-gates.html"><strong aria-hidden="true">4.3.</strong> Sending some gates</a></li><li class="expanded "><a href="python-api/simulations.html"><strong aria-hidden="true">4.4.</strong> Controlling simulations</a></li><li class="expanded "><a href="python-api/operator.html"><strong aria-hidden="true">4.5.</strong> Inserting an operator</a></li><li class="expanded "><a href="python-api/reference.html"><strong aria-hidden="true">4.6.</strong> Reference</a></li></ol></li><li class="expanded "><a href="cpp-api/index.html"><strong aria-hidden="true">5.</strong> C++ API</a></li><li class="expanded "><a href="c-api/index.html"><strong aria-hidden="true">6.</strong> C API</a></li><li><ol class="section"><li class="expanded "><a href="c-api/concepts.apigen.html"><strong aria-hidden="true">6.1.</strong> Concepts</a></li><li><ol class="section"><li class="expanded "><a href="c-api/handle.apigen.html"><strong aria-hidden="true">6.1.1.</strong> Handles: dqcs_handle_*</a></li><li class="expanded "><a href="c-api/memory-management.apigen.html"><strong aria-hidden="true">6.1.2.</strong> Memory management</a></li><li class="expanded "><a href="c-api/error.apigen.html"><strong aria-hidden="true">6.1.3.</strong> Error handling: dqcs_error_*</a></li><li class="expanded "><a href="c-api/callbacks.apigen.html"><strong aria-hidden="true">6.1.4.</strong> Callbacks</a></li></ol></li><li class="expanded "><a href="c-api/type-definitions.apigen.html"><strong aria-hidden="true">6.2.</strong> Type definitions: dqcs_*_t</a></li><li class="expanded "><a href="c-api/arb-cmd-cq.apigen.html"><strong aria-hidden="true">6.3.</strong> ArbData and ArbCmd objects</a></li><li><ol class="section"><li class="expanded "><a href="c-api/arb.apigen.html"><strong aria-hidden="true">6.3.1.</strong> ArbData objects: dqcs_arb_*</a></li><li class="expanded "><a href="c-api/cmd.apigen.html"><strong aria-hidden="true">6.3.2.</strong> ArbCmd objects: dqcs_cmd_*</a></li><li class="expanded "><a href="c-api/cq.apigen.html"><strong aria-hidden="true">6.3.3.</strong> ArbCmd queues: dqcs_cq_*</a></li></ol></li><li class="expanded "><a href="c-api/qbset.apigen.html"><strong aria-hidden="true">6.4.</strong> Qubits: dqcs_qbset_*</a></li><li class="expanded "><a href="c-api/gate.apigen.html"><strong aria-hidden="true">6.5.</strong> Gates: dqcs_gate_*</a></li><li class="expanded "><a href="c-api/measurements.apigen.html"><strong aria-hidden="true">6.6.</strong> Measurements</a></li><li><ol class="section"><li class="expanded "><a href="c-api/meas.apigen.html"><strong aria-hidden="true">6.6.1.</strong> Singular measurements: dqcs_meas_*</a></li><li class="expanded "><a href="c-api/mset.apigen.html"><strong aria-hidden="true">6.6.2.</strong> Measurement sets: dqcs_mset_*</a></li></ol></li><li class="expanded "><a href="c-api/plugins.apigen.html"><strong aria-hidden="true">6.7.</strong> Plugins</a></li><li><ol class="section"><li class="expanded "><a href="c-api/pdef.apigen.html"><strong aria-hidden="true">6.7.1.</strong> Defining a plugin: dqcs_pdef_*</a></li><li class="expanded "><a href="c-api/plugin-run.apigen.html"><strong aria-hidden="true">6.7.2.</strong> Running a plugin: dqcs_plugin_*</a></li><li class="expanded "><a href="c-api/plugin-interact.apigen.html"><strong aria-hidden="true">6.7.3.</strong> Interacting with DQCsim: dqcs_plugin_*</a></li><li class="expanded "><a href="c-api/log.apigen.html"><strong aria-hidden="true">6.7.4.</strong> Logging: dqcs_log_*</a></li></ol></li><li class="expanded "><a href="c-api/simulations.apigen.html"><strong aria-hidden="true">6.8.</strong> Simulations</a></li><li><ol class="section"><li class="expanded "><a href="c-api/pcfg.apigen.html"><strong aria-hidden="true">6.8.1.</strong> Configuring plugins: dqcs_pcfg_*</a></li><li class="expanded "><a href="c-api/tcfg.apigen.html"><strong aria-hidden="true">6.8.2.</strong> Running local plugins: dqcs_tcfg_*</a></li><li class="expanded "><a href="c-api/scfg.apigen.html"><strong aria-hidden="true">6.8.3.</strong> Configuring a simulation: dqcs_scfg_*</a></li><li class="expanded "><a href="c-api/sim.apigen.html"><strong aria-hidden="true">6.8.4.</strong> Running a simulation: dqcs_sim_*</a></li></ol></li><li class="expanded "><a href="c-api/reference.apigen.html"><strong aria-hidden="true">6.9.</strong> Reference</a></li></ol></li><li class="expanded "><a href="rust-api/index.html"><strong aria-hidden="true">7.</strong> Rust API</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">DQCsim</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 style="text-align: center">DQCsim</h1>
<p style="text-align: center; padding-bottom: 10px; font-size: larger; font-weight: bold">
The Delft Quantum & Classical simulator
</p>
<p style="text-align: center; padding-bottom: 20px">
DQCsim is a <i>framework</i> that can be used to tie <i>components</i> of
quantum computer simulators together in a <i>standardized</i> yet
<i>extensible</i>, <i>developer-friendly</i>, and <i>reproducible</i> way.
</p>
<table style="border: solid 1px rgba(0.5,0.5,0.5,0.1); background-color: rgba(0.5,0.5,0.5,0.03)">
<tr>
<td style="border-style: none; background-color: rgba(0.5,0.5,0.5,0.03); text-align: center; font-size: larger; padding-top: 20px; font-weight: bold">Framework</td>
<td style="border-style: none; background-color: rgba(0.5,0.5,0.5,0.03); text-align: center; font-size: larger; padding-top: 20px; font-weight: bold">Components</td>
<td style="border-style: none; background-color: rgba(0.5,0.5,0.5,0.03); text-align: center; font-size: larger; padding-top: 20px; font-weight: bold">Developer-friendly</td>
</tr>
<tr>
<td style="border-style: none; background-color: rgba(0.5,0.5,0.5,0.03); text-align: center; vertical-align: top; padding-bottom: 20px; font-size: smaller">
DQCsim only provides <a href="intro/interfaces.html">interfaces</a>
to tie simulator components together. That is, it does not contain any
simulation code on its own. DQCsim is all the boilerplate code that you don't
want to write when you're developing a new way to
<a href="intro/backend.html">simulate qubits</a>, a
<a href="intro/frontend.html">microarchitecture simulator</a>, an
<a href="intro/operator.html">error model</>, etc.
</td>
<td style="border-style: none; background-color: rgba(0.5,0.5,0.5,0.03); text-align: center; vertical-align: top; padding-bottom: 20px; font-size: smaller">
DQCsim abstracts a quantum computer simulation into four components:
<a href="intro/host.html">hosts</a>,
<a href="intro/frontend.html">frontends</a>,
<a href="intro/operator.html">operators</a>, and
<a href="intro/backend.html">backends</a>. These components are separate
operating system processes that each fulfill a well-defined function within the
simulation, thus splitting the simulation up into more manageable parts.
</td>
<td style="border-style: none; background-color: rgba(0.5,0.5,0.5,0.03); text-align: center; vertical-align: top; padding-bottom: 20px; font-size: smaller">
All the components can be written in <a href="python-api/index.html">Python</a>,
<a href="c-api/index.html">C</a>, <a href="cpp-api/index.html">C++</a>, or
<a href="rust-api/index.html">Rust</a>. Just use whichever language you
prefer &ndash; or any combination of those languages! DQCsim will automatically
tie everything together for you at runtime, so you can focus on writing quantum
algorithms instead of fighting CPython.
</td>
</tr>
<tr>
<td style="border-style: none; background-color: rgba(0.5,0.5,0.5,0.03); text-align: center; font-size: larger; padding-top: 20px; font-weight: bold">Standardized</td>
<td style="border-style: none; background-color: rgba(0.5,0.5,0.5,0.03); text-align: center; font-size: larger; padding-top: 20px; font-weight: bold">Extensible</td>
<td style="border-style: none; background-color: rgba(0.5,0.5,0.5,0.03); text-align: center; font-size: larger; padding-top: 20px; font-weight: bold">Reproducible</td>
</tr>
<tr>
<td style="border-style: none; background-color: rgba(0.5,0.5,0.5,0.03); text-align: center; vertical-align: top; padding-bottom: 30px; font-size: smaller">
DQCsim fully specifies a set of core features that each component
<a href="c-api/pdef.apigen.html#assigning-callback-functions">needs to
support</a>, as well as the interfaces used to drive them. Therefore, as long as the
components don't rely on any user-defined extra features in other components,
they can be swapped out without breaking anything.
</td>
<td style="border-style: none; background-color: rgba(0.5,0.5,0.5,0.03); text-align: center; vertical-align: top; padding-bottom: 30px; font-size: smaller">
Besides standardizing the basic features of each component, DQCsim provides
<a href="arbs.html">an interface</a> for users to implement their own features,
without needing to change anything in DQCsim's codebase. So don't panic about
DQCsim being written in Rust: you shouldn't need to read or write a single line
of code in here!
</td>
<td style="border-style: none; background-color: rgba(0.5,0.5,0.5,0.03); text-align: center; vertical-align: top; padding-bottom: 30px; font-size: smaller">
While quantum mechanics are inherently stochastic, simulating it
<a href="intro/reproducibility.html">needs not be</a>. DQCsim provides a
random generator to the components that should be more than random enough for
simulation purposes, while being reproducible when this is desirable, such as
while debugging.
</td>
</tr>
</table>
<h2 style="text-align: center">Interested?</h2>
<h1 style="text-align: center"><a href="intro/components.html">Keep reading!</a></h1>
<h3 style="text-align: center">(<a href="install/index.html">or skip directly to the install notes</a>)</h2>
<h1><a class="header" href="#the-components-of-a-simulation" id="the-components-of-a-simulation">The components of a simulation</a></h1>
<p>DQCsim divides a mixed quantum-classical simulation up into up to four
different types of components. Put briefly, these are:</p>
<ul>
<li>the <a href="intro/frontend.html"><em>frontend</em></a>, which deals with the
microarchitecture-specific classical part of the simulation;</li>
<li>the <a href="intro/backend.html"><em>backend</em></a>, which deals with simulating the quantum
mechanics behind the qubits, usually in a microarchitecture-agnostic way;</li>
<li>any number of <a href="intro/operator.html"><em>operators</em></a>, which sit between the frontend
and backend to monitor or modify the gate and measurement streams flowing
between them;</li>
<li>and an optional <a href="intro/host.html"><em>host</em></a> program, which treats the simulated
quantum computer as an accelerator.</li>
</ul>
<p>The frontend, backend, and operators are collectively referred to as <em>plugins</em>.
Frontend and operator plugins produce a stream of gates (<em>gatestream source</em>),
while operator and backend plugins consume such a stream (<em>gatestream sinks</em>).
The measurement stream flows in the opposite direction, in response to the
execution of a measurement gate. We'll commonly use <em>downstream</em> and <em>upstream</em>
to refer to stream directions between the plugins (or the next plugin over in
said direction); in this case the gatestream is used for the direction
reference. That is, in a simulation with just a frontend and a backend, the
backend is the downstream plugin for the frontend.</p>
<p>Which plugins are used for a simulation is decided by the host program when it
initializes the simulation. If you don't need any special host logic, you can
also use DQCsim's <a href="intro/../cli/index.html">command-line interface</a> to start the
simulation, which normally behaves like a host that just starts and stops a
simulation without interacting with it.</p>
<h2><a class="header" href="#process-boundaries" id="process-boundaries">Process boundaries</a></h2>
<p>The plugins and host programs are usually all separate processes. The host
side of DQCsim spawns these plugin processes and handles all communication
between them for you, so you don't need to think about it. This requires you to
fundamentally separate your host, frontend, and backend logic, which will help
others understand and reuse parts of your code later on. It also prevents
invalid memory accesses caused by bugs from propagating into other parts of the
simulation, which helps you locate the source of the problem faster.</p>
<p>Perhaps most importantly, the process boundaries let you program the components
in different languages. After all, different problems have different
requirements and different programmers solving them; there is no one language
that can solve everything efficiently! Normally such language boundaries are so
cumbersome that you have to pick a single language for the whole, but DQCsim
handles it all for you. There is absolutely zero difference between a plugin
written in C, C++, Python, or Rust from the perspective of another plugin in
the same simulation!</p>
<h2><a class="header" href="#null-plugins" id="null-plugins">Null plugins</a></h2>
<p>To simplify testing a little bit, particularly the regression tests of DQCsim
itself, DQCsim also provides a so-called &quot;null&quot; plugin of each type. The
frontend simply does nothing, the operator passes all gates and measurements
through unchanged, and the backend returns 50/50 measurement results but
otherwise does nothing.</p>
<h1><a class="header" href="#frontend-use-cases" id="frontend-use-cases">Frontend use cases</a></h1>
<p>Frontends can be subdivided into roughly three different classes: mixed
quantum/classical algorithms, interpreters, and microarchitecture simulators.</p>
<p>The first is the easiest. Instead of writing any kind of simulator, the source
code for the frontend is the algorithm itself. Python would usually be used for
this, since it avoids a compilation step. Whenever your algorithm has to apply
a gate, you simply call the appropriate DQCsim API to send a gate to the
downstream plugin. All that you then have to do to simulate the algorithm is
run <code>dqcsim my-algorithm.py [backend]</code>. That's it!</p>
<p>The second frontend plugin class is a plugin that loads a file written in some
domain-specific language for describing quantum algorithms, such as cQASM, and
interprets it into a DQCsim gate stream line by line. The command-line
interface of DQCsim has some &quot;sugaring&quot; built in that allows it to
automatically pick the appropriate interpreter plugin based on the algorithm's
file extension, so simulation is still as easy as
<code>dqcsim my-algorithm.my-dsl [backend]</code>.</p>
<p>The third class represents frontends that simulate classical hardware, either
functionally, cycle-accurately, or something in between. Such a plugin may for
instance be largely written in SystemC, or interface with other simulators such
as QuestaSim or GHDL. You can make this as easy or as complex as you need, as
long as the final output remains a gatestream.</p>
<p>Note that unlike most qubit simulators, DQCsim's gatestreams have a concept of
time built into them. This allows error models to model decoherence over time
in an intuitive way, without the frontend needing to insert an identity gate
for each qubit each cycle.</p>
<h1><a class="header" href="#backend-use-cases" id="backend-use-cases">Backend use cases</a></h1>
<p>The backend part of a DQCsim simulation is what people usually mean when they
talk about a quantum computer simulator: it simulates the behavior of qubits in
a quantum circuit.</p>
<p>There are various mathematical ways to go about doing this, with their own pros
and cons in terms of accuracy, simulation speed, and memory footprint. This is
primarily why being able to swap out the backend is very powerful.</p>
<p>Another big reason for wanting to swap out backends would be to get access to
different error models. However, it is strongly recommended to describe such
error models in the form of a operator plugins, if it's possible to describe
them by modifying or inserting additional gates.</p>
<h1><a class="header" href="#operator-use-cases" id="operator-use-cases">Operator use cases</a></h1>
<p>Following up on the above, a prime example of an operator plugin is an error
model. Any error model that can be described by modifying the unitary matrices
of the gates requested by the frontend, by inserting gates to model decoherence
over time, by modifying measurement results, or any combination thereof, can
be described this way. Separating the error models from the (perfect) qubit
simulation allows you to mix and match both error model and simulation accuracy
by just changing DQCsim's command line.</p>
<p>Operators are more powerful than that, though. Imagine for instance that you're
developing a new map-and-route algorithm. You have to test it at some point,
but adding a pass to any kind of compiler is notoriously difficult, especially
if the compiler is written in a language that you're not familiar with. You may
be inclined to throw your own quick-and-dirty program together instead, to be
able to iterate quickly while you debug your algorithm. Then you write your
paper, get a new idea (or deadline), and never get around to turning the
algorithm into something that someone else can use... at least not without
trudging through undocumented code to figure out how to use it. DQCsim
operators provide another alternative: writing an operator plugin should be
easier than starting from scratch, <em>and</em> it allows other people to use your
algorithm more easily since the interface is standardized! Operators have full
control over the way gates are passed through to the next plugin, so modifying
qubit indices or inserting swap gates is not a problem.</p>
<p>Operators are also useful for debugging. You might want to dump the gatestream
produced by your mapping algorithm in addition to just simulating it, for
instance. Easy – just write another operator that &quot;tee's&quot; the gatestream to a
file.</p>
<p>An operator also has the power to allocate additional qubits. You can for
instance model an upstream qubit as multiple downstream qubits to model some
error correction code. You can then easily test the effect of the code easily
by swapping out some error operators and the code operator itself.</p>
<h1><a class="header" href="#host-use-cases" id="host-use-cases">Host use cases</a></h1>
<p>There are two main use cases for host programs. The first – on the short
term probably the most useful – is to provide an easy way to code batch
simulations. Just write a couple nested loops around the simulation code that
swap out plugins or modify parameters and collect the results in some file or
database! DQCsim also lets you insert plugin <em>threads</em> into the simulation
pipeline, which provide you with an easy way to collect statistics from various
parts of the gatestream, without needing to compile and interface with a custom
plugin executable.</p>
<p>The second use case for host programs is to model quantum accelerators. In this
case, the host program is probably a larger software package, such as a genome
sequencing tool, that could be accelerated using a quantum chip. This chip may
not exist yet, but by loading DQCsim's host library you can still simulate
it... as long as it doesn't use too many qubits of course. DQCsim's host
interface is defined fairly generically, such that it should be possible to
make a drop-in replacement for the control systems of a real quantum computer
later on!</p>
<h1><a class="header" href="#jigsaw-puzzle-analogy" id="jigsaw-puzzle-analogy">Jigsaw puzzle analogy</a></h1>
<p>One way to represent the components of DQCsim is through jigsaw puzzle pieces.
Each piece represents a component, while the shapes on the sides of the pieces
represent the interfaces. Just like in a jigsaw puzzle, these interfaces must
match exactly for the program to work.</p>
<p>Within this analogy, DQCsim provides the following jigsaw pieces.</p>
<p style="text-align: center"><img src="intro/dqcsim-puzzle-pieces.svg" /></p>
<p>But you can't make a finished (rectangular) puzzle with those pieces alone; you
need to add some of your own. You can use the following shapes:</p>
<p style="text-align: center"><img src="intro/plugin-puzzle-pieces.svg" /></p>
<p>Here's an example of a finished puzzle:</p>
<p style="text-align: center"><img src="intro/example-puzzle.svg" /></p>
<p>You could decide not to use DQCsim's pieces at all, by just connecting a C
frontend to a C backend, for instance. This actually only sort of works outside
the analogy, since DQCsim's gatestream sink interface does not correspond
<em>exactly</em> to its source interface, but you get the idea. However, you can't
just connect a Python frontend to a C++ backend. It doesn't fit; you'd have to
make an adapter piece first. You also can't add host logic easily, and don't
get a command line parser for free. This is what DQCsim provides for you.</p>
<h1><a class="header" href="#dqcsims-interfaces" id="dqcsims-interfaces">DQCsim's interfaces</a></h1>
<p>The big thing for any framework from a user's perspective are the interfaces
that the framework provides. This section introduces the most important ones
conceptually. The exact interfaces differ for each programming language, so
for more detailed information refer to the API documentation chapters instead.</p>
<h2><a class="header" href="#contents" id="contents">Contents</a></h2>
<ul>
<li><a href="intro/arbs.html">ArbData and ArbCmds</a></li>
<li><a href="intro/gatestream.html">Gate- and measurement streams</a></li>
<li><a href="intro/host-iface.html">The host interface</a></li>
<li><a href="intro/misc-iface.html">Miscellaneous interfaces</a></li>
</ul>
<h1><a class="header" href="#arbdata-and-arbcmds" id="arbdata-and-arbcmds">ArbData and ArbCmds</a></h1>
<p>Before we get into defining the host and gatestream interfaces, we need to
define a generic objects through which data and user-defined commands can be
communicated. We've named these objects <code>ArbData</code> and <code>ArbCmd</code>s, short for
arbitrary data and arbitrary commands.</p>
<p>These objects are used wherever something needs to be communicated that DQCsim
doesn't necessarily need to know about. In some cases they'll be accompanied by
additional data that <em>is</em> defined/standardized by DQCsim, to prevent everyone
from rolling their own protocols for common stuff. After all, that would make
swapping out different plugins a lot of trouble.</p>
<h2><a class="header" href="#arbitrary-data" id="arbitrary-data">Arbitrary data</a></h2>
<p>An <code>ArbData</code> object consists of a <a href="https://en.wikipedia.org/wiki/JSON">JSON</a>-like
object (specifically <a href="https://en.wikipedia.org/wiki/CBOR">CBOR</a>, which is a
superset of JSON) and a list of binary strings. The JSON-like object can be
used to represent structured data, whereas the binary strings are intended for
unstructured data, or data that's structured in a way that doesn't mesh well
with JSON.</p>
<p>The advantage of JSON data is that it's &quot;annotated&quot; through dictionary keys. It
therefore lends itself better for backward- and forward-compatibility. JSON
objects are also easy to print and make sense of. However, they're rather
heavyweight. This introduces complexity into the plugins, and may therefore
slow down the simulation. In cases where this is a concern, using the binary
string list is probably a better option.</p>
<h2><a class="header" href="#arbitrary-commands" id="arbitrary-commands">Arbitrary commands</a></h2>
<p><code>ArbCmd</code>s expand on <code>ArbData</code> objects to not only communicate a bit of data,
but also intent. Think of them as remote procedure calls. The desired procedure
to be called is identified by two strings, called the interface ID and the
operation ID. Both of these must match exactly (case-sensitive) for a command
to be accepted. The difference between the two lies within how unsupported
procedures are handled:</p>
<ul>
<li>If the interface ID is known but the operation ID isn't, the target plugin
must return an error.</li>
<li>If the interface ID is not known to the target plugin, it must acknowledge
the request with an empty return value.</li>
</ul>
<p>This allows <code>ArbCmd</code>s to be used as hints (also known as pragmas) that get
silently ignored if they're not available or applicable.</p>
<p>To test if a plugin supports a certain interface programmatically, you can send
an <code>ArbCmd</code> with the respective interface ID and a dummy operation ID, such as
a single underscore. If this returns an error, the interface is supported, per
the default behavior described above.</p>
<p>When you need to make a new <code>ArbCmd</code>, it is recommended to set the interface ID
to the name of your plugin. Alternatively, if you intend to add support for
your interface in multiple plugins, come up with a sane name for the interface
as a whole. Make sure to document the interfaces your plugin supports!</p>
<h1><a class="header" href="#gate--and-measurement-streams" id="gate--and-measurement-streams">Gate- and measurement streams</a></h1>
<p>The gatestream interface connects frontends to backends, frontends to
operators, and operators to backends. There is a slight difference between
the three to do with the measurement path, but for the most part they are
the same. The following graphic shows the functions and callbacks used to
form the interface on either side.</p>
<p style="text-align: center"><img src="intro/gatestream.svg" /></p>
<p>The green datapaths only exist if the upstream plugin is an operator. The red
datapaths only exist if the downstream plugin is an operator.</p>
<h2><a class="header" href="#allocating-and-freeing-qubits" id="allocating-and-freeing-qubits">Allocating and freeing qubits</a></h2>
<p>DQCsim allows upstream plugins to allocate qubits within the downstream
plugins at all times. This was done to provide a means for qubit mapping
operators to determine whether upstream qubits are in use or not, and because
it seems obvious in general coming from the classical world. Similar to a
classical computer, a backend with limited resources must make map the qubits
that are actually in use appropriately.</p>
<p>The <code>alloc()</code> function takes the number of qubits that are to be allocated as
an argument, as well as a list of <code>ArbCmd</code>s. The <code>ArbCmd</code>s can for instance be
used for various things, such as assigning a name to qubit registers for
debugging purposes or specifying error model information on a per-qubit basis.
In response, DQCsim allocates unique indices for the requested qubits and
returns them to the algorithm immediately. It also asynchronously sends an
allocation request through the gatestream, which causes the <code>alloc()</code> callback
to be called on the other end. This function takes the qubit indices that
DQCsim allocated for the qubits and the list of <code>ArbCmd</code>s as argument.</p>
<p><code>free()</code> can be used to free previously allocated qubits. If these qubits are
still entangled, the backend should collapse the state in some way; however, it
is up to the backend to decide how to do this. <code>free()</code> only takes the list of
qubit indices that are to be freed as arguments.</p>
<p>Qubit indices are assigned by DQCsim in a deterministic way. The first
allocated qubit receives index 1. Subsequent allocations receive the next
index. This means that freed qubit indices are never reused; if a backend wants
to reuse indices internally, it must maintain its own mapping. Index 0 is
reserved for marking invalid qubits and the end of a qubit list in the C API.</p>
<h2><a class="header" href="#sending-gates" id="sending-gates">Sending gates</a></h2>
<p>DQCsim internally represents gates using the following pieces of data:</p>
<ul>
<li>an optional name;</li>
<li>a list of target qubits;</li>
<li>a list of control qubits;</li>
<li>a list of measured qubits;</li>
<li>an optional unitary matrix, sized appropriately for the number of qubits in
the target list;</li>
<li>an <code>ArbData</code> object that may contain classical arguments and/or additional
information specifying the behavior of the gate.</li>
</ul>
<p>It is not currently possible to send all the gates allowed by the above
representation through the C, C++, or Python APIs. Specifically, only the
following classes of gates can be constructed:</p>
<ul>
<li>unitary gates, which consist of one or more target qubits, a unitary matrix,
and zero or more control qubits;</li>
<li>z-basis measurement gates, which consist of one or more measured qubits and
nothing else;</li>
<li>custom gates, which have a name (required), zero or more target qubits, zero
or more control qubits, zero or more measured qubits, an optional gate
matrix, and <code>ArbData</code> information.</li>
</ul>
<p>A backend <em>must</em> process gates according to the following algorithm.</p>
<p>On the receiving end, the behavior is standardized as follows.</p>
<ul>
<li>If the gate does not have a name:
<ul>
<li>if there is a matrix:
<ul>
<li>turn the matrix into a controlled matrix with the appropriate number
of control qubits (which may be zero), and</li>
<li>apply the matrix to the concatenation of the control and target
qubits;</li>
</ul>
</li>
<li>measure every qubit in the <code>measures</code> list in the Z basis. Note that this
should be supported <em>in addition</em> to the application of a unitary gate.</li>
</ul>
</li>
<li>Otherwise, if the gate has a name recognized by the backend implementation,
the behavior is up to the backend implementation.</li>
<li>Otherwise, the backend should return an error.</li>
</ul>
<h2><a class="header" href="#measurement-results" id="measurement-results">Measurement results</a></h2>
<p>Measurement objects in DQCsim consist of the following:</p>
<ul>
<li>(usually) the index of the measured qubit;</li>
<li>the measured value, which may be zero, one, or undefined (to model a failed
measurement);</li>
<li>an <code>ArbData</code> object that may contain additional information about the
measurement.</li>
</ul>
<p>The upstream plugin will store the result of the latest measurement performed
on a per-qubit basis. This storage can be queried using the <code>get_measurement()</code>
function. Measuring the same qubit twice without calling <code>get_measurement()</code> in
between is fine; in this case, the result of the first measurement is
discarded.</p>
<p>DQCsim requires that every qubit in the <code>measures</code> list of a gate results in
exactly one measurement being returned. Furthermore, it is illegal to return
measurement data for a qubit that was not measured. This has to do with
internal optimizations in the communication protocol. DQCsim will check whether
you fulfill these requirements, and issue warnings if you don't. The stored
measurement results become undefined in a potentionally non-deterministic way
after violating the protocol in this way, so it is important to fix these
warnings when you get them.</p>
<p>Note that operators do not need to return all measurement results immediately.
Specifically, if they propagate the measurement gate further downstream in some
way, the qubits measured by that gate must <em>not</em> be returned immediately.
Instead, these measurement results pass through the <code>modify_measurement()</code>
callback when they become available. <code>modify_measurement()</code> takes one
measurement result as an argument and can return zero or more measurements,
which will then be passed on to the upstream plugin. The only thing that
matters, ultimately, is that the measurements received by the upstream plugin
correspond exactly to the qubits it measured.</p>
<h2><a class="header" href="#passing-time" id="passing-time">Passing time</a></h2>
<p>Gates in DQCsim are modeled as being performed sequentially and
instantaneously. Among other things, this allows operators to insert gates into
the gatestream at any time, without having to worry about violating boundary
conditions. However, DQCsim <em>does</em> have a basic concept of time.</p>
<p>Specifically, an integral cycle counter is maintained for every gatestream
interface. This cycle counter can be advanced by the specified number of cycles
using the <code>advance()</code> function, which results in the <code>advance()</code> callback being
called for the downstream plugin. Other than that, DQCsim does nothing with
this timing information.</p>
<p>This mechanism was introduced to provide a standardized way for upstream
plugins to specify how much time is passing to downstream plugins. This is
important specifically for error model operators, which may randomly insert
gates in response to the <code>advance()</code> callback to decohere the quantum state.</p>
<h2><a class="header" href="#gatestream-arbs" id="gatestream-arbs">Gatestream arbs</a></h2>
<p>In addition to the above, the upstream plugin can send <code>ArbCmd</code>s to the
downstream plugin. These operate like synchronous remote procedure calls,
taking an <code>ArbCmd</code> as argument and sending an <code>ArbData</code> or error message in
response.</p>
<p>This mechanism can for instance be used to tell the downstream plugin to dump
its quantum state for debug purposes.</p>
<h1><a class="header" href="#the-host-interface" id="the-host-interface">The host interface</a></h1>
<p>The host interface, also known as simulator or accelerator interface, connects
the host (or DQCsim command-line interface) to the frontend. Especially from
the perspective of the host, it intends to be as generic as possible –
sufficiently generic, even, to allow for drop-in replacements with a real
quantum computer control system once it becomes available. The following
graphic shows the functions and callbacks used to form the interface on either
side.</p>
<p style="text-align: center"><img src="intro/host-iface.svg" /></p>
<h2><a class="header" href="#algorithm-execution" id="algorithm-execution">Algorithm execution</a></h2>
<p>It is assumed that the quantum accelerator can only execute one algorithm at a
time; that is, it is single-threaded. However, multiple algorithms can be run
sequentially within the context of a simulation. It's also possible to control
multiple parallel quantum accelerators from a single program by simply
initializing DQCsim multiple times from different threads,</p>
<p>The host starts an algorithm by calling <code>start()</code>. This function takes an
<code>ArbData</code> as an argument, which may for instance be used to select which
algorithm to run for microarchitectures that allow multiple to be loaded in
memory at the same time. This call is asynchronous; that is, it requests that
the accelerator starts running, but does not wait for it to complete. Instead,
this waiting has to be done explicitly through a call to wait <code>wait()</code>. This
allows the quantum accelerator to run in parallel to the classical logic in
the host program, even though the quantum accelerator itself is
single-threaded.</p>
<p>Algorithm execution is modeled by means of a single callback on the frontend
side. This callback takes the <code>ArbData</code> passed to <code>start()</code> as an argument. It
also returns an <code>ArbData</code>; this response is returned to the host through the
return value of <code>wait()</code>.</p>
<h2><a class="header" href="#communication" id="communication">Communication</a></h2>
<p>While both the host and the quantum accelerator are running in parallel, they
can communicate with each other through two queues, one in either direction.
These queues carry <code>ArbData</code> objects as packets. The <code>send()</code> function
asynchronously pushes a message into the respective queue, while the <code>recv()</code>
returns a message from the queue. <code>recv()</code> will block until a message is
available.</p>
<h2><a class="header" href="#host-arbs" id="host-arbs">Host arbs</a></h2>
<p>In addition to the above, the host can send <code>ArbCmd</code>s to the accelerator. These
operate like synchronous remote procedure calls, taking an <code>ArbCmd</code> as argument
and sending an <code>ArbData</code> or error message in response.</p>
<p>This mechanism can for instance be used to model device memory access, or to
query implementation-specific information.</p>
<h1><a class="header" href="#miscellaneous-interfaces" id="miscellaneous-interfaces">Miscellaneous interfaces</a></h1>
<p>Besides the interfaces described previously, DQCsim provides some
miscellaneous services.</p>
<h2><a class="header" href="#plugin-construction-and-destruction" id="plugin-construction-and-destruction">Plugin construction and destruction</a></h2>
<p>Each type of plugin can define an <code>initialize()</code> and a <code>drop()</code> callback.
DQCsim will ensure that these callbacks are called respectively before and
after all other callbacks.</p>
<p>The <code>initialize()</code> callback takes a list of <code>ArbCmd</code>s as an argument. These
are configured by the host when the plugin is constructed. They can be regarded
as a specialization of host arbs that deals with initialization specifically.</p>
<h2><a class="header" href="#host-arbs-to-operators-and-backends" id="host-arbs-to-operators-and-backends">Host arbs to operators and backends</a></h2>
<p>In addition to the host being able to send arbs to the frontend, it can also
send arbs to the operator(s) and backend. The mechanism is the same.
Synchronization with respect to the rest of the simulation is guaranteed at all
times.</p>
<h2><a class="header" href="#logging" id="logging">Logging</a></h2>
<p>Each plugin has a <code>log()</code> function of some kind that allows it to send log
messages through DQCsim's centralized logging framework. Using this system
versus simply writing to stdout or stderr has the benefit of being
synchronized (since I/O streams are not thread-safe), and allows users to
filter out messages that they're not interested in.</p>
<h1><a class="header" href="#reproducibility" id="reproducibility">Reproducibility</a></h1>
<p>DQCsim provides various mechanisms that can be used to reproduce a previously
performed simulation. This is intended primarily for debugging. Say, for
instance, that the simulation returns a result that you were not expecting,
while you did'nt have the logging verbosity set high enough to debug it.
Without a way to precisely reproduce the simulation run, you may never get the
same result again if it was due to random chance!</p>
<h2><a class="header" href="#random-seed" id="random-seed">Random seed</a></h2>
<p>DQCsim provides each plugin with a pseudorandom number generator that is
guaranteed to return the same results every time for a specific random seed.
By default, the random seed is randomly generated using entropy from the system
clock, but you can also specify it manually to get deterministic simulations.</p>
<h2><a class="header" href="#reproduction-files" id="reproduction-files">Reproduction files</a></h2>
<p>More powerful than simply setting a random seed are reproduction files. A
reproduction file is a YAML description of a previously performed simulation,
containing all information needed to reproduce the simulation under normal
circumstances. Sometimes DQCsim may need some help from the user, for instance
when the simulation is to be reproduced on another computer, but in general it
should work out of the box.</p>
<p>The command-line interface allows you to reproduce a simulation either exactly
or as if you were reproducing a physical experiment. The seed specified in the
reproduction file is ignored in the latter case.</p>
<p>When you run a simulation using the command-line interface, a reproduction file
will be generated by default. In this case, the reproduction file is ultimately
little more than the options you specified on the command. However, it is
usually also possible to generate a reproduction file when a host program is
involved. In this case, DQCsim will record the functions it calls on the host
interface into the reproduction file, such that the command-line interface can
reproduce the simulation later. This takes any non-deterministic behavior of
the host program out of the equation.</p>
<h1><a class="header" href="#installation" id="installation">Installation</a></h1>
<p>Here's how to install DQCsim. If you're on Linux or macOS, it's easy: just
install Python 3.5+ and follow one of the three installation methods listed
below. If you're on Windows, you'll unfortunately have to wait, since DQCsim
has a <a href="https://github.com/servo/ipc-channel">dependency that doesn't support Windows</a>.</p>
<h2><a class="header" href="#recommended-method-requires-superuser-access" id="recommended-method-requires-superuser-access">Recommended method (requires superuser access)</a></h2>
<p>The recommended way to install DQCsim is through Python's package manager in
the usual way:</p>
<pre><code class="language-bash">$ sudo pip3 install dqcsim
</code></pre>
<p>Besides the Python module, this also installs the development headers and
dynamic libraries needed to develop C/C++ plugins or host programs. On most
distributions Python installs into <code>/usr/local</code>, which should be part of your
compiler's search paths already.</p>
<h2><a class="header" href="#installation-into-your-home-directory" id="installation-into-your-home-directory">Installation into your home directory</a></h2>
<p>If you don't have superuser access, you can also install to your home directory
as follows:</p>
<pre><code class="language-bash">$ pip3 install dqcsim --user
</code></pre>
<p>This will normally install the package into <code>~/.local</code>. You should probably
check if <code>~/.local/bin</code> is in your <code>$PATH</code> environment variable, otherwise the
command-line interface and plugins may not work out of the box. If you're
developing in C or C++, you'll also have to add the following to
<code>CFLAGS</code>: <code>-I ~/.local/include -L ~/.local/lib</code>.</p>
<h2><a class="header" href="#installation-into-a-venv" id="installation-into-a-venv">Installation into a venv</a></h2>
<p>You can also install into a
<a href="https://docs.python.org/3/library/venv.html#creating-virtual-environments">venv</a>.
This is particularly useful if you want to have multiple versions installed at
the same time. To create a venv and install into it, run the following:</p>
<pre><code class="language-bash">$ mkdir -p &lt;your-install-directory&gt;
$ cd &lt;your-install-directory&gt;
$ python3 -m venv &lt;your-install-directory&gt;
$ source &lt;your-install-directory&gt;/bin/activate
(venv) $ pip3 install dqcsim
</code></pre>
<p>To leave the <code>venv</code>, run</p>
<pre><code class="language-bash">(venv) $ deactivate
</code></pre>
<p>If you're developing in C or C++, you'll also have to add the following to
<code>CFLAGS</code>: <code>-I &lt;your-install-directory&gt;/include -L &lt;your-install-directory&gt;/lib</code>.</p>
<h1><a class="header" href="#plugin-distribution" id="plugin-distribution">Plugin distribution</a></h1>
<p>Since DQCsim is only a framework, installing <em>just</em> DQCsim doesn't let you do
much besides development. To get started with it quickly, you'll also need to
install some plugins.</p>
<p>This is currently TODO, because there are no supported plugins yet. However,
the current idea is that these will also be distributed through pip, with a
dependency on <code>dqcsim</code>. For instance, you should be able to install <code>dqcsim-qx</code>
through pip to get the QX simulator with appropriate DQCsim bindings.</p>
<h1><a class="header" href="#command-line-interface" id="command-line-interface">Command-line interface</a></h1>
<p>TODO</p>
<p>For now, just run <code>dqcsim --long-help</code> to get the built-in documentation.</p>
<h1><a class="header" href="#python-api" id="python-api">Python API</a></h1>
<p>The Python API allows you to use DQCsim using Python 3, in order to both
construct plugins and control simulations. It is built on top of the
<a href="python-api/../c-api/index.html">C API</a>, but adds a thick abstraction layer to turn it
into a Pythonic interface.</p>
<h2><a class="header" href="#how-to-read-this-chapter" id="how-to-read-this-chapter">How to read this chapter</a></h2>
<p>This chapter reads like a tutorial to DQCsim's Python API to get you coding
quickly. However, it doesn't even get close to documenting every single
feature. If you're looking for something more complete, check out the
generated API documentation <a href="python-api/../py_/dqcsim/index.html">here</a>.</p>
<p>The tutorial assumes that you already know what DQCsim is, and have a decent
understanding of the basic concepts. If you don't, start <a href="python-api/../index.html">here</a>.</p>
<h2><a class="header" href="#contents-1" id="contents-1">Contents</a></h2>
<ul>
<li><a href="python-api/hello-world.html">Hello, world!</a></li>
<li><a href="python-api/debugging.html">Debugging</a></li>
<li><a href="python-api/sending-gates.html">Sending some gates</a></li>
<li><a href="python-api/simulations.html">Controlling simulations</a></li>
<li><a href="python-api/operator.html">Inserting an operator</a></li>
<li><a href="python-api/reference.html">Reference</a></li>
</ul>
<h1><a class="header" href="#hello-world" id="hello-world">Hello, world!</a></h1>
<p>Let's start with a basic frontend plugin, <code>Hello, world!</code> style. This is all
you need:</p>
<pre><code class="language-python">from dqcsim.plugin import *

@plugin(&quot;My Plugin&quot;, &quot;Me!&quot;, &quot;0.1&quot;)
class MyPlugin(Frontend):
    def handle_run(self):
        self.info('Hello, world!')

MyPlugin().run()
</code></pre>
<p>This frontend just logs <code>Hello, world!</code> with the info loglevel when run. You
can use the command line to test it as follows:</p>
<pre><code class="language-shell">$ dqcsim my-plugin.py null
... Info dqcsim  Starting Simulation with seed: ...
... Info back    Running null backend initialization callback
... Info dqcsim  Executing 'start(...)' host call...
... Info dqcsim  Executing 'wait()' host call...
... Info front   Hello, world!
... Note dqcsim  'wait()' returned {}
... Info dqcsim  Reproduction file written to &quot;my-plugin.py.repro&quot;.
... Info dqcsim  Simulation completed successfully.
... Info dqcsim  PluginProcess exited with status code: 0
... Info dqcsim  PluginProcess exited with status code: 0
</code></pre>
<p>Note the <code>Hello, world!</code> line in the middle.</p>
<p>While you're debugging a plugin, you might want to change the log verbosities
around a little. For instance, the following will set the verbosity of your
plugin to the debug level, and the verbosity of the other plugins and DQCsim
itself to error.</p>
<pre><code class="language-shell">$ dqcsim -ld --plugin-level e --dqcsim-level e my-plugin.py -ld null
... Info front   Hello, world!
</code></pre>
<p>Take a few minutes to look through <code>dqcsim --long-help</code> to see what those
options mean and what else it can do for you, specifically on the subject of
logging!</p>
<h2><a class="header" href="#how-it-works" id="how-it-works">How it works</a></h2>
<p>Let's dissect the hello world plugin line by line.</p>
<pre><code class="language-python">from dqcsim.plugin import *
</code></pre>
<p>This loads the DQCsim plugin library and pulls it into our module's scope.
Specifically, we're using <code>Frontend</code> and <code>plugin</code> in this script.</p>
<pre><code class="language-python">@plugin(&quot;My Plugin&quot;, &quot;Me!&quot;, &quot;0.1&quot;)
class MyPlugin(Frontend):
</code></pre>
<p>These lines define a new plugin. Any plugin must derive from either <code>Frontend</code>,
<code>Operator</code>, or <code>Backend</code>; we're deriving from <code>Frontend</code> here.</p>
<p>The <code>@plugin</code> annotation specifies some metadata for the plugin, namely the
plugin's name, author, and version. The host can access this metadata to verify
that it loaded the right plugin. While DQCsim requires you to specify these
three strings, it doesn't actually do anything with it on its own.</p>
<pre><code class="language-python">def handle_run(self):
</code></pre>
<p>This function is called by DQCsim in response to the <code>start()</code> command from the
host. There are a couple more callbacks that frontend plugins can define, but
this is the most important one. It's also the only one that's required for a
frontend.</p>
<pre><code class="language-python">self.info('Hello, world!')
</code></pre>
<p>This function sends a log message back to DQCsim. You can also use <code>trace</code>,
<code>debug</code>, <code>note</code>, <code>warn</code>, <code>error</code>, or <code>fatal</code> to get a different loglevel. Any
arguments specified in addition to the first are passed to
<a href="https://docs.python.org/3.6/library/stdtypes.html#str.format"><code>str.format()</code></a>,
so you could for instance also call <code>self.info('Hello, {}!', username)</code> (if
<code>username</code> would be a thing here).</p>
<pre><code class="language-python">MyPlugin().run()
</code></pre>
<p>This line actually turns the Python script into a DQCsim plugin. Without it,
DQCsim would crash:</p>
<pre><code class="language-plaintext">Fatal dqcsim  plugin did not connect within specified timeout
</code></pre>
<p>After all, just defining a class doesn't really make a Python script do
anything!</p>
<p>The first part of the line, <code>MyPlugin()</code>, makes an instance of the plugin, but
doesn't start it yet. This is because there are multiple ways to start a
plugin, and it's also useful to pass instantiated but not-yet-started plugins
around during initialization.</p>
<p>The second part, <code>.run()</code>, actually starts the plugin. It also waits for it to
finish, and either returns <code>None</code> to indicate success or throws a
<code>RuntimeError</code> to indicate failure.</p>
<p>Plugins need a simulator to connect to. DQCsim passes this endpoint as a string
to the first command-line argument of a plugin process. <code>run()</code> let's you
specify the endpoint manually if you like, but if you don't, it takes it from
<code>sys.argv[1]</code> automatically, with appropriate error checking.</p>
<h1><a class="header" href="#debugging" id="debugging">Debugging</a></h1>
<p>Let's say we made a mistake in our hello world plugin. For instance,</p>
<pre><code class="language-python">from dqcsim.plugin import *

@plugin(&quot;My Plugin&quot;, &quot;Me!&quot;, &quot;0.1&quot;)
class MyPlugin(Frontend):
    def handle_run(self):
        self.ifo('Hello, world!')

MyPlugin().run()
</code></pre>
<p>Can you spot the typo? Running the plugin in DQCsim with its default settings
will help a little bit already:</p>
<pre><code class="language-console">$ dqcsim my-plugin.py null
...  Info dqcsim  Starting Simulation with seed: 9198852889345625466
...  Info back    Running null backend initialization callback
...  Info dqcsim  Executing 'start(...)' host call...
...  Info dqcsim  Executing 'wait()' host call...
... Error front   'MyPlugin' object has no attribute 'ifo'
...  Info dqcsim  Reproduction file written to &quot;my-plugin.py.repro&quot;.
... Fatal dqcsim  Simulation failed: 'MyPlugin' object has no attribute 'ifo'
...  Info dqcsim  PluginProcess exited with status code: 0
...  Info dqcsim  PluginProcess exited with status code: 0
</code></pre>
<p>Apparently we typed <code>self.ifo</code> somewhere. Easily fixed in this case... but
there's no traceback, or even a line number in the log. This is because
DQCsim's error handling system only propagates the error message itself,
without any metadata. Propagating things like tracebacks properly would be
pretty hard after all, with all the potential programming language boundaries.</p>
<p>The Python module <em>does</em> however log tracebacks of exceptions raised from
within your callback functions. They're simply suppressed by default, as
they're printed with the trace loglevel. To see them, you'll need to change
DQCsim's command line:</p>
<pre><code class="language-console">$ dqcsim -lt my-plugin.py null
...
... Trace ... Traceback (most recent call last):
...
... Trace ...   File &quot;my-plugin.py&quot;, line 6, in handle_run
... Trace ...     self.ifo('Hello, world!')
... Trace ... AttributeError: 'MyPlugin' object has no attribute 'ifo'
...
</code></pre>
<p>There are quite some messages to sift through with this verbosity, but the ones
you're looking for would normally also be in there. If it's not, DQCsim's
Python module is itself confused, either because you're doing something it
didn't expect, or because there is a bug somewhere. In this case you'll have to
narrow the problem down through trial and error.</p>
<h2><a class="header" href="#reproduction-files-1" id="reproduction-files-1">Reproduction files</a></h2>
<p>It's also possible that your exception only happens sometimes, because of some
non-deterministic quantum behavior being modelled, or because you're running
the plugin from a non-deterministic host program. In this case, you can try
using reproduction files. The command-line interface will output one by default
whenever you run a simulation, named after the frontend plugin with a <code>.repro</code>
suffix. So, in this case, the following command should reproduce the previous
run without any log message filtering.</p>
<pre><code class="language-console">$ dqcsim -lt --reproduce-exactly my-plugin.py.repro
</code></pre>
<h1><a class="header" href="#sending-some-gates" id="sending-some-gates">Sending some gates</a></h1>
<p>Let's change our plugin to make it do something more useful now. We'll
implement the
<a href="https://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm">Deutsch–Jozsa algorithm</a>
because it's nice and simple. Put briefly, this algorithm determines whether
a one-qubit to one-qubit oracle function is constant (<code>x -&gt; 0</code> or <code>x -&gt; 1</code>)
or balanced (<code>x -&gt; x</code> or <code>x -&gt; !x</code>) by only evaluating the function once.</p>
<p>Here's the plugin code:</p>
<pre><code class="language-python">from dqcsim.plugin import *

@plugin(&quot;Deutsch-Jozsa&quot;, &quot;Tutorial&quot;, &quot;0.1&quot;)
class MyPlugin(Frontend):

    def oracle_constant_0(self, qi, qo):
        &quot;&quot;&quot;x -&gt; 0 oracle function.&quot;&quot;&quot;
        pass

    def oracle_constant_1(self, qi, qo):
        &quot;&quot;&quot;x -&gt; 1 oracle function.&quot;&quot;&quot;
        self.x_gate(qo)

    def oracle_passthrough(self, qi, qo):
        &quot;&quot;&quot;x -&gt; x oracle function.&quot;&quot;&quot;
        self.cnot_gate(qi, qo)

    def oracle_invert(self, qi, qo):
        &quot;&quot;&quot;x -&gt; !x oracle function.&quot;&quot;&quot;
        self.cnot_gate(qi, qo)
        self.x_gate(qo)

    def deutsch_jozsa(self, qi, qo, oracle):
        &quot;&quot;&quot;Runs the Deutsch-Jozsa algorithm on the given oracle. The oracle is
        called with the input and output qubits as positional arguments.&quot;&quot;&quot;

        # Prepare the input qubit.
        self.prepare(qi)
        self.x_gate(qi)
        self.h_gate(qi)

        # Prepare the output qubit.
        self.prepare(qo)
        self.h_gate(qo)

        # Run the oracle function.
        oracle(qi, qo)

        # Measure the output.
        self.h_gate(qo)
        self.measure(qo)
        if self.get_measurement(qo).value:
            self.info('Oracle was balanced!')
        else:
            self.info('Oracle was constant!')

    def handle_run(self):
        qi, qo = self.allocate(2)

        self.info('Running Deutsch-Jozsa on x -&gt; 0...')
        self.deutsch_jozsa(qi, qo, self.oracle_constant_0)

        self.info('Running Deutsch-Jozsa on x -&gt; 1...')
        self.deutsch_jozsa(qi, qo, self.oracle_constant_1)

        self.info('Running Deutsch-Jozsa on x -&gt; x...')
        self.deutsch_jozsa(qi, qo, self.oracle_passthrough)

        self.info('Running Deutsch-Jozsa on x -&gt; !x...')
        self.deutsch_jozsa(qi, qo, self.oracle_invert)

        self.free(qi, qo)

MyPlugin().run()
</code></pre>
<p>The plugin runs the algorithm on all possible oracles in sequence. Observe that
we hardly had to duplicate any code to do that, by making clever use of
Python's expressivity! Also note that DQCsim's Python plugin provides you with
a number of built-in gate types. You can find the full list
<a href="python-api/../py_/dqcsim/plugin/index.html#dqcsim.plugin.GateStreamSource">here</a>.</p>
<p>You can run this example with the null backend provided by DQCsim as follows.</p>
<pre><code class="language-console">$ dqcsim my-plugin.py null
... Info dqcsim  Starting Simulation with seed: 17518393962103239508
... Info back    Running null backend initialization callback
... Info dqcsim  Executing 'start(...)' host call...
... Info dqcsim  Executing 'wait()' host call...
... Info front   Running Deutsch-Jozsa on x -&gt; 0...
... Info front   Oracle was constant!
... Info front   Running Deutsch-Jozsa on x -&gt; 1...
... Info front   Oracle was balanced!
... Info front   Running Deutsch-Jozsa on x -&gt; x...
... Info front   Oracle was balanced!
... Info front   Running Deutsch-Jozsa on x -&gt; !x...
... Info front   Oracle was constant!
... Note dqcsim  'wait()' returned {}
... Info dqcsim  Reproduction file written to &quot;my-plugin.py.repro&quot;.
... Info dqcsim  Simulation completed successfully.
... Info dqcsim  PluginProcess exited with status code: 0
... Info dqcsim  PluginProcess exited with status code: 0
</code></pre>
<p>Note that the null backend ignores all gates and just returns random
measurements, so the algorithm also just returns random results. To make the
algorithm work, you'll have to use a real backend.</p>
<h1><a class="header" href="#controlling-simulations" id="controlling-simulations">Controlling simulations</a></h1>
<p>Right now, our Deutsch-Jozsa algorithm always executes all oracles once and
logs the results. This is fine when you just want to run it once, but what if
you want to run it 1000 times, maybe with an error model in between, and apply
some statistics to the results? You could of course make a script that just
calls the DQCsim command line 1000 times and parses the stderr stream for every
call... but that would be a very fragile solution, and it'd be annoying to
make.</p>
<p>Instead, we can use DQCsim's host interface. Let's change the frontend plugin
to make use of this feature.</p>
<pre><code class="language-python">from dqcsim.plugin import *

@plugin(&quot;Deutsch-Jozsa&quot;, &quot;Tutorial&quot;, &quot;0.2&quot;)
class MyPlugin(Frontend):

    def oracle_constant_0(self, qi, qo):
        &quot;&quot;&quot;x -&gt; 0 oracle function.&quot;&quot;&quot;
        pass

    def oracle_constant_1(self, qi, qo):
        &quot;&quot;&quot;x -&gt; 1 oracle function.&quot;&quot;&quot;
        self.x_gate(qo)

    def oracle_passthrough(self, qi, qo):
        &quot;&quot;&quot;x -&gt; x oracle function.&quot;&quot;&quot;
        self.cnot_gate(qi, qo)

    def oracle_invert(self, qi, qo):
        &quot;&quot;&quot;x -&gt; !x oracle function.&quot;&quot;&quot;
        self.cnot_gate(qi, qo)
        self.x_gate(qo)

    def deutsch_jozsa(self, qi, qo, oracle):
        &quot;&quot;&quot;Runs the Deutsch-Jozsa algorithm on the given oracle. The oracle is
        called with the input and output qubits as positional arguments.&quot;&quot;&quot;

        # Prepare the input qubit.
        self.prepare(qi)
        self.x_gate(qi)
        self.h_gate(qi)

        # Prepare the output qubit.
        self.prepare(qo)
        self.h_gate(qo)

        # Run the oracle function.
        oracle(qi, qo)

        # Measure the output.
        self.h_gate(qo)
        self.measure(qo)
        if self.get_measurement(qo).value:
            self.send(result='balanced')
        else:
            self.send(result='constant')

    def handle_run(self, oracle='', runs=1):

        oracle = {
            '0': self.oracle_constant_0,
            '1': self.oracle_constant_1,
            'x': self.oracle_passthrough,
            '!x': self.oracle_invert,
        }.get(oracle, None)

        if oracle is None:
            raise ValueError('Please specify an oracle!')

        qi, qo = self.allocate(2)

        for _ in range(runs):
            self.deutsch_jozsa(qi, qo, oracle)

        self.free(qi, qo)

MyPlugin().run()
</code></pre>
<p>When we try to run this frontend with DQCsim's command line, you'll get an
error:</p>
<pre><code class="language-console">$ dqcsim my-plugin.py null
...  Info dqcsim  Starting Simulation with seed: 15043164643727486506
...  Info back    Running null backend initialization callback
...  Info dqcsim  Executing 'start(...)' host call...
...  Info dqcsim  Executing 'wait()' host call...
... Error front   Please specify an oracle!
...  Info dqcsim  Reproduction file written to &quot;my-plugin.py.repro&quot;.
... Fatal dqcsim  Simulation failed: Please specify an oracle!
...  Info dqcsim  PluginProcess exited with status code: 0
...  Info dqcsim  PluginProcess exited with status code: 0
</code></pre>
<p>Indeed, we've changed the algorithm such that our <code>handle_run()</code> callback wants
some arguments.</p>
<p>Remember how the <a href="python-api/../intro/host-iface.html#algorithm-execution"><code>start()</code> call takes an <code>ArbData</code> as argument</a>?
The Python module passes the contents of this <code>ArbData</code> as arguments to
<code>handle_run()</code>. Specifically, the binary strings are passed as positional
arguments (<code>*args</code>), and the toplevel entries in the JSON/CBOR object are
passed as keyword arguments (<code>**kwargs</code>). This abstraction is used all over
the place in the Python layer, including when you have to send an <code>ArbData</code>
with it, because it gives the callbacks a nice, Pythonic interface.</p>
<p>It's possible to tell the command-line interface to pass arguments to the
<code>start()</code> call as follows, though the syntax isn't very friendly:</p>
<pre><code class="language-console">$ dqcsim -C 'start:{&quot;oracle&quot;:&quot;x&quot;}' my-plugin.py null
... Info dqcsim  Starting Simulation with seed: 13451103132954817086
... Info back    Running null backend initialization callback
... Info dqcsim  Executing 'start(...)' host call...
... Info dqcsim  Executing 'wait()' host call...
... Note dqcsim  'wait()' returned {}
... Info dqcsim  Reproduction file written to &quot;my-plugin.py.repro&quot;.
... Info dqcsim  Simulation completed successfully.
... Info dqcsim  PluginProcess exited with status code: 0
... Info dqcsim  PluginProcess exited with status code: 0
</code></pre>
<p>Now we don't get an error anymore... but we also don't get any output. Look
again at the revised Python script: instead of logging the results, we <code>send()</code>
them. <code>send()</code> takes an <code>ArbData</code> as argument, and thus, like the syntax we
used for our <code>handle_run()</code> callback, we can construct it by passing positional
and keyword arguments.</p>
<p>To see the result, we need to make DQCsim call <code>recv()</code> before it exits. We can
do that through the command line as well:</p>
<pre><code class="language-console">$ dqcsim -C 'start:{&quot;oracle&quot;:&quot;x&quot;}' -C recv my-plugin.py null
... Info dqcsim  Starting Simulation with seed: 8371252716093296353
... Info back    Running null backend initialization callback
... Info dqcsim  Executing 'start(...)' host call...
... Info dqcsim  Executing 'recv()' host call...
... Note dqcsim  'recv()' returned {&quot;result&quot;:&quot;balanced&quot;}
... Info dqcsim  Executing 'wait()' host call...
... Note dqcsim  'wait()' returned {}
... Info dqcsim  Reproduction file written to &quot;my-plugin.py.repro&quot;.
... Info dqcsim  Simulation completed successfully.
... Info dqcsim  PluginProcess exited with status code: 0
... Info dqcsim  PluginProcess exited with status code: 0
</code></pre>
<p>Now <code>dqcsim</code> notes that the <code>recv()</code> call returned <code>{&quot;result&quot;:&quot;balanced&quot;}</code>,
which coincidentally is the correct output of the algorithm. Since we're still
using the <code>null</code> backend, the result is just 50/50.</p>
<h2><a class="header" href="#constructing-an-accompanying-host-program" id="constructing-an-accompanying-host-program">Constructing an accompanying host program</a></h2>
<p>It makes little sense to do all that work only to get a less convenient
command-line interface. Indeed, this mechanism is not intended to be used this
way. You should use it with a host program instead.</p>
<p>You can write this in any of the languages DQCsim supports, since it runs in a
different process. But since this is a Python tutorial, we'll use Python.</p>
<p>Here's an example of a host program that makes use of our modified frontend.</p>
<pre><code class="language-python">from dqcsim.host import *

runs = 1000
oracle = 'x'

with Simulator('my-plugin.py', 'null') as sim:
    sim.start(oracle=oracle, runs=runs)
    results = [sim.recv()['result'] for _ in range(runs)]
    sim.wait()

print('Number of balanced outcomes:', results.count('balanced'))
print('Number of constant outcomes:', results.count('constant'))
</code></pre>
<p>Calling this script may yield the following:</p>
<pre><code class="language-console">$ python3 simulate.py
... Info dqcsim  Starting Simulation with seed: 14750381695807274720
... Info back    Running null backend initialization callback
... Info dqcsim  PluginProcess exited with status code: 0
... Info dqcsim  PluginProcess exited with status code: 0
Number of balanced outcomes: 493
Number of constant outcomes: 507
</code></pre>
<p>Let's dissect this script.</p>
<pre><code class="language-python">from dqcsim.host import *
</code></pre>
<p>This line loads DQCsim's host library and brings it into scope. Specifically,
we're using the <code>Simulator</code> class.</p>
<pre><code class="language-python">runs = 1000
oracle = 'x'
</code></pre>
<p>These variables set the number of runs and the oracle under test.</p>
<pre><code class="language-python">with Simulator('my-plugin.py', 'null') as sim:
</code></pre>
<p>This line starts a simulation. You can call the <code>Simulator()</code> constructor in
<a href="python-api/../py_/dqcsim/host/index.html">many different ways</a>;
the one we're using here is very similar to the command line we used before.
However, instead of using strings to try to hack a list of host calls in there
(which isn't even supported by the constructor), we'll interact with the
simulation while it's running.</p>
<p>The <code>with</code> syntax used here is shorthand notation for the following:</p>
<pre><code class="language-python">sim = Simulator('my-plugin.py', 'null')
sim.simulate()
# block contents
sim.stop()
</code></pre>
<p>Calling the <code>Simulator()</code> constructor doesn't really do anything yet; it just
<em>configures</em> a simulation. In fact, you're free to use it more than once, as
long as you don't try to have multiple simulations running at the same time.</p>
<p>The <code>simulate()</code> function actually starts the simulation, in the sense that it
spawns the plugins and calls their initialization callbacks (if applicable),
but it doens't call our <code>handle_run()</code> callback yet. The <code>stop()</code> function
performs the inverse operation of <code>simulate()</code>; it ensures that all the spawned
processes get cleaned up.</p>
<pre><code class="language-python">sim.start(oracle=oracle, runs=runs)
</code></pre>
<p>This line actually starts the simulation. The keyword arguments specified are
used to construct the <code>ArbData</code> argument, which the plugin library unpacks into
keyword arguments again when it calls <code>handle_run()</code>.</p>
<pre><code class="language-python">results = [sim.recv()['result'] for _ in range(runs)]
</code></pre>
<p>This <a href="https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions">list comprehension</a>
calls <code>recv()</code> just as many times as the algorithm runs for, and records the
<code>result</code> key of the returned <code>ArbData</code> object into a list. These entries should
be either <code>'balanced'</code> or <code>'constant'</code>.</p>
<p>Note that there is a possibility of a deadlock here: if the algorithm wouldn't
call <code>send()</code> as often as we expect, everything would logically lock up.
DQCsim detects all possible kinds of deadlocks on the host interface however,
and immediately throws an exception instead. Try it out!</p>
<pre><code class="language-python">sim.wait()
</code></pre>
<p>This line waits for the <code>handle_run()</code> callback to return. <code>wait()</code> returns an
<code>ArbData</code> object corresponding to what the <code>handle_run()</code> returned, but we're
not using that feature, so we just discard it.</p>
<pre><code class="language-python">print('Number of balanced outcomes:', results.count('balanced'))
print('Number of constant outcomes:', results.count('constant'))
</code></pre>
<p>These two lines count the number of <code>'balanced'</code> vs. <code>'constant'</code> occurrences
in the result list. As we can see when we run the script, the chance is 50/50.
With a perfect qubit simulator backend you should get 1000 balanced and zero
constant outcomes. When you add an error model to the simulation, you might get
something in between.</p>
<p>Note that we're using regular print statements here, versus using DQCsim's log
system. In fact, we have to do this: DQCsim's log system is intended for the
plugins only. You can, however, instruct the <code>Simulator()</code> object to forward
the messages it receives to Python's <code>logging</code> library to get uniform output.
This is beyond the scope of this tutorial.</p>
<h1><a class="header" href="#inserting-an-operator" id="inserting-an-operator">Inserting an operator</a></h1>
<p>Now that we have a simulation to play around with, let's add an operator.</p>
<p>There are many types of operators conceivable. To keep things simple here,
we'll use an operator that just affects measurements as an example. Here's
the code:</p>
<pre><code class="language-python">from dqcsim.plugin import *

@plugin(&quot;Measurement-Error&quot;, &quot;Tutorial&quot;, &quot;0.1&quot;)
class MyOperator(Operator):

    def __init__(self):
        super().__init__()
        self.one_error = 0.0
        self.zero_error = 0.0

    def handle_host_measurementError_setOneError(self, value=0.0):
        self.one_error = value

    def handle_host_measurementError_setZeroError(self, value=0.0):
        self.zero_error = value

    def handle_measurement(self, measurement):
        if measurement.value == 1:
            measurement.value = self.random_float() &lt; self.one_error
        elif measurement.value == 0:
            measurement.value = self.random_float() &gt;= self.zero_error
        return measurement

MyOperator().run()
</code></pre>
<p>To use it within the simulation created in the previous section, replace
the following line:</p>
<pre><code class="language-python">with Simulator('my-plugin.py', 'null') as sim:
</code></pre>
<p>With this:</p>
<pre><code class="language-python">with Simulator('my-plugin.py', 'my-operator.py', 'null') as sim:
</code></pre>
<p>What this does should be obvious – it sticks the operator we just made in
between, assuming you used the same filename.</p>
<p>Running it doesn't change much though:</p>
<pre><code class="language-console">$ python3 simulate.py 
... Info dqcsim  Starting Simulation with seed: 14673804979996191647
... Info back    Running null backend initialization callback
... Info dqcsim  PluginProcess exited with status code: 0
... Info dqcsim  PluginProcess exited with status code: 0
... Info dqcsim  PluginProcess exited with status code: 0
Number of balanced outcomes: 498
Number of constant outcomes: 502
</code></pre>
<p>Still 50/50. Of course, that's because we never set any error rates.</p>
<h2><a class="header" href="#dissecting-the-new-plugin" id="dissecting-the-new-plugin">Dissecting the new plugin</a></h2>
<pre><code class="language-python">from dqcsim.plugin import *

@plugin(&quot;Measurement-Error&quot;, &quot;Tutorial&quot;, &quot;0.1&quot;)
class MyOperator(Operator):
    ...

MyOperator().run()
</code></pre>
<p>This part is the same as what we've seen before, except we've renamed some
things and are deriviing from <code>Operator</code> instead of <code>Frontend</code>. You'll see
these lines in every DQCsim plugin; it's the boilerplate code that turns an
otherwise regular Python script into a valid plugin.</p>
<pre><code class="language-python">def __init__(self):
    super().__init__()
    self.one_error = 0.0
    self.zero_error = 0.0
</code></pre>
<p>We've built the plugin such that we can set the measurement error rates.
Specifically, we specify two probabilities:</p>
<ul>
<li><code>one_error</code> is the chance that a qubit observed to be in the one state is
measured as zero;</li>
<li><code>zero_error</code> is the chance that a qubit observed to be in the zero state is
measured as one.</li>
</ul>
<p>We can store these parameters within our operator class by defining them in its
initializer, as done here.</p>
<p>Note specifically the <code>super().__init__()</code> line. It's often forgotten, but in
fact, you <em>have</em> to call this any time you override any Python class'
constructor, or your superclass' constructor will simply never be called. In
this case, not doing it will break DQCsim, although it will tell you what you
need to do to fix it in the error message.</p>
<pre><code class="language-python">def handle_host_measurementError_setOneError(self, value=0.0):
    self.one_error = value

def handle_host_measurementError_setZeroError(self, value=0.0):
    self.zero_error = value
</code></pre>
<p>These two functions provide entry points for any <code>ArbCmd</code>s sent to us by the
host or by the initialization callback (since we didn't override it). The
interface and operation IDs are in the handler's name, as is the source of
the command, which can be <code>host</code> or <code>upstream</code>.</p>
<p>The Python module detects which interfaces your plugin supports by looking for
handlers of the form <code>handle_host_&lt;interface&gt;_&lt;operation&gt;()</code> inside the plugin
constructor. Interface and operation IDs preferably don't contain any
underscores, because this makes the split between the interface and operation
ID ambiguous. In this case, the automatic detection algorithm will throw an
error, and ask you to specify which interfaces your plugin supports through a
keyword argument to the plugin's constructor.</p>
<p>In this case, the detection algorithm works just fine, and determines that the
plugin supports the <code>measurementError</code> interface. Within the interface, two
operations are defined, <code>setOneError</code> and <code>setZeroError</code>; any other operation
will return an error.</p>
<pre><code class="language-python">def handle_measurement(self, measurement):
    if measurement.value == 1:
        measurement.value = self.random_float() &lt; self.one_error
    elif measurement.value == 0:
        measurement.value = self.random_float() &gt;= self.zero_error
    return measurement
</code></pre>
<p>This function is the core of the plugin. If it exists, it is called by DQCsim
whenever a measurement passes through the operator, to allow the operator to
return a modified measurement instead. It can also turn a single measurement
into a list of measurements or block propagation of the measurement, but you
wouldn't need to do this unless you're making some complex mapping algorithm.</p>
<p>The implementation provided here modifies the measurement value based on the
perfect measurement received from downstream, DQCsim's random generator, and
the configured probabilities.</p>
<h2><a class="header" href="#testing-the-error-model" id="testing-the-error-model">Testing the error model</a></h2>
<p>Let's change the <code>Simulator()</code> arguments again. It's getting a little complex
now, so we'll fold it apart for clarity:</p>
<pre><code class="language-python">with Simulator(
    'my-plugin.py',
    (
        'my-operator.py',
        {
            'init': [
                ArbCmd('measurementError', 'setZeroError', value=0.5)
            ]
        }
    ),
    'null'
) as sim:
</code></pre>
<p>This adds an initialization command to our error model operator, that sets the
measurement error probability for a zero observation to <code>0.5</code>. When we run the
program now, we get something like this:</p>
<pre><code class="language-console">$ python3 simulate.py
... Info dqcsim  Starting Simulation with seed: 8830780357769760084
... Info back    Running null backend initialization callback
... Info dqcsim  PluginProcess exited with status code: 0
... Info dqcsim  PluginProcess exited with status code: 0
... Info dqcsim  PluginProcess exited with status code: 0
Number of balanced outcomes: 266
Number of constant outcomes: 734
</code></pre>
<p>Success – this is clearly not 50/50 anymore! Half of the balanced outcomes are
converted to constant by the error model, so the probability is 25/75 now.</p>
<p>To make the <code>Simulator()</code> syntax a bit more aesthetically pleasing, we can
configure the simulation in multiple steps, like this:</p>
<pre><code class="language-python">sim_config = Simulator('my-plugin.py', 'null')
sim_config.with_operator(
    'my-operator.py',
    init=ArbCmd('measurementError', 'setZeroError', value=0.5))
with sim_config as sim:
</code></pre>
<p>Functionally, this is exactly the same.</p>
<h2><a class="header" href="#changing-error-model-parameters-at-runtime" id="changing-error-model-parameters-at-runtime">Changing error model parameters at runtime</a></h2>
<p>Because our operator allows the values to be set with run-time <code>ArbCmd</code>s as
well, we can also do the following:</p>
<pre><code class="language-python">with Simulator('my-plugin.py', 'my-operator.py', 'null') as sim:
    sim.start(oracle=oracle, runs=runs)
    results = [sim.recv()['result'] for _ in range(runs)]
    sim.wait()

    sim.arb('op1', 'measurementError', 'setZeroError', value=0.5)

    sim.start(oracle=oracle, runs=runs)
    results += [sim.recv()['result'] for _ in range(runs)]
    sim.wait()
</code></pre>
<p>Now half of our simulation runs at 50/50 probability, and half of it at 25/75.
So we expect to get around 38/62. Indeed:</p>
<pre><code class="language-console">$ python3 simulate.py 
... Info dqcsim  Starting Simulation with seed: 6379995085809620608
... Info back    Running null backend initialization callback
... Info dqcsim  PluginProcess exited with status code: 0
... Info dqcsim  PluginProcess exited with status code: 0
... Info dqcsim  PluginProcess exited with status code: 0
Number of balanced outcomes: 722
Number of constant outcomes: 1278
</code></pre>
<p>Note however, that sending a new probability in the middle of our <code>recv()</code>
calls will <em>not</em> work. This is because the frontend does not wait for <code>recv()</code>
to be called; <code>send()</code> is asynchronous! To make that work, you'd have to have
the frontend wait for the host through a <code>recv()</code> call, or have the frontend
update the operator's parameters while it's running. In the latter case, you
also have to define <code>handle_upstream_*()</code> equivalents for the <code>handle_host_*()</code>
callbacks.</p>
<h1><a class="header" href="#reference" id="reference">Reference</a></h1>
<p>This is the end of the tutorial for now, but many more features are already
supported by DQCsim. More exhaustive documentation is available through
Python's builtin <code>help()</code>/docstring system, or on the pages generated from
this by <code>pdoc3</code> <a href="python-api/../py_/dqcsim/index.html">here</a>.</p>
<h1><a class="header" href="#c-api" id="c-api">C++ API</a></h1>
<p>The C++ API, once finished, will allow you to use DQCsim in a way that should
be intuitive for C++11 developers, in order to both construct plugins and
control simulations. However, this API is not anywhere near complete at this
time. To use DQCsim from C++, you'll need to use the
<a href="cpp-api/../c-api/index.html">C API</a>.</p>
<h1><a class="header" href="#c-api-1" id="c-api-1">C API</a></h1>
<p>The C API allows any language that supports C bindings to use DQCsim for making
plugins or host programs. It consists of a header file (<code>dqcsim.h</code>) and an
associated dynamic library (<code>libdqcsim.so</code> on Linux, <code>dqcsim.dylib</code> on macOS).
These will be installed automatically in the <code>include</code> and <code>lib</code> directories
that Python is aware of when DQCsim is installed using <code>pip3 install dqcsim</code>
(more detailed notes <a href="c-api/../install/index.html">here</a>).</p>
<h2><a class="header" href="#how-to-read-this-chapter-1" id="how-to-read-this-chapter-1">How to read this chapter</a></h2>
<p>The sections form a somewhat coherent story that runs you through the entire
API, starting with <a href="c-api/concepts.apigen.html">some conceptual things</a>, and followed
by a <a href="c-api/type-definitions.apigen.html">walkthrough</a> of the objects encapsulated by
the API using a bottom-up approach. The <a href="c-api/reference.apigen.html">final section</a>
summarizes all the functions/types exposed by the API in alphabetical order, in
case you're just looking for a searchable list.</p>
<p>The documentation assumes that you already know what DQCsim is, and have a
decent understanding of the basic concepts. If you don't, start
<a href="c-api/../index.html">here</a>.</p>
<h2><a class="header" href="#contents-2" id="contents-2">Contents</a></h2>
<ul>
<li><a href="c-api/concepts.apigen.html">Concepts</a></li>
<li><a href="c-api/type-definitions.apigen.html">Type definitions</a></li>
<li><a href="c-api/arb-cmd-cq.apigen.html">ArbData and ArbCmd objects</a></li>
<li><a href="c-api/qbset.apigen.html">Qubits</a></li>
<li><a href="c-api/gate.apigen.html">Gates</a></li>
<li><a href="c-api/measurements.apigen.html">Measurements</a></li>
<li><a href="c-api/plugins.apigen.html">Plugins</a></li>
<li><a href="c-api/simulations.apigen.html">Simulations</a></li>
<li><a href="c-api/reference.apigen.html">Reference</a></li>
</ul>
<h1><a class="header" href="#concepts" id="concepts">Concepts</a></h1>
<p>Let's start with some basic concepts you should be aware of before you start
using this API. The things in this chapter are either common to all API
functions, or the more specific documentation assumes you're aware of them.</p>
<h2><a class="header" href="#contents-3" id="contents-3">Contents</a></h2>
<ul>
<li><a href="c-api/handle.apigen.html">Handles</a></li>
<li><a href="c-api/memory-management.apigen.html">Memory management</a></li>
<li><a href="c-api/error.apigen.html">Error handling</a></li>
<li><a href="c-api/callbacks.apigen.html">Callbacks</a></li>
</ul>
<h1><a class="header" href="#handles" id="handles">Handles</a></h1>
<p>The API is based upon a handle system for referring to simulator data.
Handles are like cross-language references or pointers: they point to a
piece of data in the simulator, but don't contain it.</p>
<p>The usage of handles implies that the complex data structures contained
within the simulator never actually leave the simulator. Instead, when the
simulator needs to pass data to you, it returns a handle, which you can use
to access the contents of the referred structure through a number of API
calls. Similarly, when you need to pass something to the simulator, you
construct an object through a number of API calls, and then pass the handle
to the simulator.</p>
<h2><a class="header" href="#operating-on-handles" id="operating-on-handles">Operating on handles</a></h2>
<p>Handles can represent a number of different object types. Based on the type
of object the handle represents, different interfaces are supported. For
instance, <code>ArbCmd</code> objects support <code>handle</code>, <code>arb</code>, and <code>cmd</code>, while
<code>ArbData</code> objects only support <code>handle</code> and <code>arb</code>. You can find an
exhaustive list of all handle types and the interfaces they support in the
documentation for <code>dqcs_handle_type_t</code>. Note that all normal handles
support the <code>handle</code> interface.</p>
<p>The name of the API functions directly corresponds with the name of the
interface it requires the primary handle it operates on to have: the
functions have the form <code>dqcs_&lt;interface&gt;_*</code>.</p>
<h2><a class="header" href="#thread-safety" id="thread-safety">Thread-safety</a></h2>
<p>The global state that the API calls operate on is purely <em>thread-local</em>.
This means that you can't exchange API objects/handles between threads.
However, this also makes the API perfectly thread-safe.</p>
<h2><a class="header" href="#functions-common-to-all-handles" id="functions-common-to-all-handles">Functions common to all handles</a></h2>
<p>The following functions are available for all handle types.</p>
<details><summary><font color="green"><tt>dqcs_handle_delete()</tt></font><div style="margin-left: 16px">
<p>Destroys the object associated with a handle.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_handle_delete(dqcs_handle_t handle)
</code></pre>
<p>Returns 0 when successful, -1 otherwise.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_handle_delete_all()</tt></font><div style="margin-left: 16px">
<p>Deletes all handles for the current thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_handle_delete_all(void)
</code></pre>
<p>This can be used to clean stuff up at the end of <code>main()</code> or before an
<code>abort()</code> of some kind. If you don't clean up properly, you might get
undefined behavior or errors when DQCsim tries to do it for you.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_handle_dump()</tt></font><div style="margin-left: 16px">
<p>Returns a debug dump of the object associated with the given handle.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_handle_dump(dqcs_handle_t handle)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
description. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_handle_leak_check()</tt></font><div style="margin-left: 16px">
<p>Succeeds only if there are no live handles in the current thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_handle_leak_check(void)
</code></pre>
<p>This is intended for testing and for finding handle leaks. The error
message returned when handles remain contains dumps of the first 10
remaining handles.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_handle_type()</tt></font><div style="margin-left: 16px">
<p>Returns the type of object associated with the given handle.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_type_t dqcs_handle_type(dqcs_handle_t handle)
</code></pre>
</div></details>
<h1><a class="header" href="#memory-management" id="memory-management">Memory management</a></h1>
<p>For the most part, the API will handle memory allocation for you through
the handle system. However, it is usually up to you to free memory back up.
Failing to do this will usually not cause errors, but will adversely affect
memory usage and performance.</p>
<p>To prevent such memory leaks, pay close attention to the documentation of the
API calls you make. Most importantly, strings returned by DQCsim almost
always have to be deallocated by you through <code>free()</code>. The only exception to
that is <code>dqcs_error_get()</code>. You should also make sure that you delete handles
that you no longer need through <code>dqcs_handle_delete()</code>, though most of the
time DQCsim does this for you when you use a handle.</p>
<h1><a class="header" href="#error-handling" id="error-handling">Error handling</a></h1>
<p>Almost all API calls can fail, for instance because an invalid handle is
supplied. Since C does not support any kind of exceptions, such failures are
reported through the return value. Which value is used to indicate an error
depends on the return type; refer to the data type section for more
information. However, this value only indicates <em>something</em> went wrong, not
<em>what</em> went wrong. The following function can be used for that.</p>
<details><summary><font color="green"><tt>dqcs_error_get()</tt></font><div style="margin-left: 16px">
<p>Returns a pointer to the latest error message.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">const char *dqcs_error_get(void)
</code></pre>
<p>Call this to get extra information when another function returns a failure
code. The returned pointer is temporary and therefore should <strong>NOT</strong> be
<code>free()</code>d. It will become invalid when a new error occurs.</p>
</div></details>
<p>The mechanism for reporting errors to DQCsim from within a callback is the
same, but reversed: you first set the error string yourself, and then return
the value that indicates that an error occurred. You can set the error as
follows.</p>
<details><summary><font color="green"><tt>dqcs_error_set()</tt></font><div style="margin-left: 16px">
<p>Sets the latest error message string.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">void dqcs_error_set(const char *msg)
</code></pre>
<p>This must be called by callback functions when an error occurs within the
callback, otherwise the upstream result for <code>dqcs_error_get()</code> will be
undefined.</p>
<p>If <code>msg</code> is set to <code>NULL</code>, the error string is cleared instead.</p>
</div></details>
<h1><a class="header" href="#callbacks" id="callbacks">Callbacks</a></h1>
<p>In some places you can pass callbacks to the API. This is particularly
important for defining plugins: the callbacks ultimately define all your
plugin's functionality!</p>
<p>Depending on the callback, it may be called from a different thread than
the one you configured it with. This is clearly documented along with the
callback setter function and normally doesn't cause problems, but you should
keep it in mind.</p>
<p>In order to support closures in higher-level languages, all callback
setters take an optional cleanup callback and a <code>void*</code> to a piece of user
data. The cleanup callback is intended for cleaning up this user data if
necessary; it is called when DQCsim drops all references to the primary
callback, so it is guaranteed that the primary callback is never called
again when the cleanup. It is also guaranteed that the cleanup callback
is executed exactly once (unless the process dies spectacularly, in which
case it may not be called). However, very few guarantees are made about
which thread the cleanup callback is called from! If you use it, make sure
that it is thread-safe.</p>
<h1><a class="header" href="#type-definitions" id="type-definitions">Type definitions</a></h1>
<p>DQCsim defines some types and enumerations. These are documented below. Note
that DQCsim does <em>not</em> define any structures; all types used on the interface
are primitive. This should hopefully simplify using the bindings from languages
other than C, which may not support such things.</p>
<h2><a class="header" href="#return-codes" id="return-codes">Return codes</a></h2>
<p>Almost all functions in DQCsim can fail. They indicate failure through their
return value. For some types this return value is obvious; for instance, <code>NULL</code>
is used for functions that return a string or another kind of pointer. For
enumerations, the failure return value is usually 0 or -1. In other cases, the
failure return value will be listed in the function documentation.</p>
<p>There are two special cases: functions that return a boolean and functions that
don't otherwise return a value. These have the following two special
enumerations defined for them:</p>
<details><summary><font color="purple"><tt>dqcs_return_t</tt></font><div style="margin-left: 16px">
<p>Default return type for functions that don't need to return anything.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_return_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_FAILURE = -1</tt></font></summary><div style="margin-left: 16px">
The function has failed. More information may be obtained through
`dqcsim_explain()`.
</div></details>
<details><summary><font color="blue"><tt>DQCS_SUCCESS = 0</tt></font></summary><div style="margin-left: 16px">
The function did what it was supposed to.
</div></details>
</p>
</div></details>
<details><summary><font color="purple"><tt>dqcs_bool_return_t</tt></font><div style="margin-left: 16px">
<p>Return type for functions that normally return a boolean but can also fail.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_bool_return_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_BOOL_FAILURE = -1</tt></font></summary><div style="margin-left: 16px">
The function has failed. More information may be obtained through
`dqcsim_explain()`.
</div></details>
<details><summary><font color="blue"><tt>DQCS_FALSE = 0</tt></font></summary><div style="margin-left: 16px">
The function did what it was supposed to and returned false.
</div></details>
<details><summary><font color="blue"><tt>DQCS_TRUE = 1</tt></font></summary><div style="margin-left: 16px">
The function did what it was supposed to and returned true.
</div></details>
</p>
</div></details>
<h2><a class="header" href="#simulator-object-references" id="simulator-object-references">Simulator object references</a></h2>
<p>The following types are used to refer to simulator objects.</p>
<details><summary><font color="purple"><tt>dqcs_handle_t</tt></font><div style="margin-left: 16px">
<p>Type for a handle.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef unsigned long long dqcs_handle_t;
</code></pre>
<p>Handles are like pointers into DQCsim's internal structures: all API calls
use these to refer to objects. Besides the object, they contain type
information. This type can be retrieved using <code>dqcs_handle_type()</code>.</p>
<p>Handles are always positive integers, counting upwards from 1 upon
allocation, and they are not reused even after being deleted. Thus, every
subsequent object allocation returns a handle one greater than the
previous. Note however that DQCsim may allocate objects as well without
the user specifically requesting this, so external code should generally
<em>not</em> rely on this behavior unless otherwise noted. The value zero is
reserved for invalid references or error propagation.</p>
<p>Note that the scope for handles is thread-local. That is, data referenced
by a handle cannot be shared or moved between threads.</p>
<p>The value zero is reserved for invalid references or error propagation.</p>
</div></details>
<details><summary><font color="purple"><tt>dqcs_qubit_t</tt></font><div style="margin-left: 16px">
<p>Type for a qubit reference.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef unsigned long long dqcs_qubit_t;
</code></pre>
<p>Qubit references are exchanged between the frontend, operator, and backend
plugins to indicate which qubits a gate operates on. Note that this makes
them fundamentally different from handles, which are thread-local.</p>
<p>Qubit references are always positive integers, counting upwards from 1 upon
allocation, and they are not reused even after the qubit is deallocated.
Thus, every subsequent allocation returns a qubit reference one greater
than the previous. This is guaranteed behavior that external code can rely
upon. The value zero is reserved for invalid references or error
propagation.</p>
</div></details>
<details><summary><font color="purple"><tt>dqcs_plugin_state_t</tt></font><div style="margin-left: 16px">
<p>Type for a plugin state.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef void *dqcs_plugin_state_t;
</code></pre>
<p>This is an opaque type that is passed along to plugin implementation
callback functions, which those callbacks can then use to interact with the
plugin instance. User code shall not create or modify values of this type,
and shall only use the values when calling <code>dqcs_plugin_*</code> functions.</p>
</div></details>
<h2><a class="header" href="#timekeeping" id="timekeeping">Timekeeping</a></h2>
<p>DQCsim supports timed simulation using integral cycle numbers as a unit. The
following typedef is used to refer to such timestamps.</p>
<details><summary><font color="purple"><tt>dqcs_cycle_t</tt></font><div style="margin-left: 16px">
<p>Type for a simulation cycle timestamp.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef long long dqcs_cycle_t;
</code></pre>
<p>Timestamps count upward from zero. The type is signed to allow usage of -1
for errors, and to allow numerical differences to be represented.</p>
</div></details>
<h2><a class="header" href="#misc-enumerations" id="misc-enumerations">Misc. enumerations</a></h2>
<p>The following enumerations are used for various purposes within the API.</p>
<details><summary><font color="purple"><tt>dqcs_handle_type_t</tt></font><div style="margin-left: 16px">
<p>Enumeration of types that can be associated with a handle.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_handle_type_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_HTYPE_INVALID = 0</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle is invalid.
<p>This indicates one of the following:</p>
<ul>
<li>The handle value is invalid (zero or negative).</li>
<li>The handle has not been used yet.</li>
<li>The object associated with the handle was deleted.</li>
</ul>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_ARB_DATA = 100</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to an `ArbData` object.
<p>This means that the handle supports the <code>handle</code> and <code>arb</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_ARB_CMD = 101</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to an `ArbCmd` object.
<p>This means that the handle supports the <code>handle</code>, <code>arb</code>, and <code>cmd</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_ARB_CMD_QUEUE = 102</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a queue of `ArbCmd` object.
<p>This means that the handle supports the <code>handle</code>, <code>arb</code>, <code>cmd</code>, and
<code>cq</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_QUBIT_SET = 103</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a set of qubit references.
<p>This means that the handle supports the <code>handle</code> and <code>qbset</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_GATE = 104</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a quantum gate description.
<p>This means that the handle supports the <code>handle</code>, <code>gate</code>, and <code>arb</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_MEAS = 105</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a qubit measurement result.
<p>This means that the handle supports the <code>handle</code>, <code>meas</code>, and <code>arb</code>
interfaces. It can also be used in place of a qubit measurement result
set by functions that consume the object.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_MEAS_SET = 106</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a set of qubit measurement
results.
<p>This means that the handle supports the <code>handle</code> and <code>mset</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_FRONT_PROCESS_CONFIG = 200</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a frontend plugin process
configuration object.
<p>This means that the handle supports the <code>handle</code>, <code>pcfg</code>, and <code>xcfg</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_OPER_PROCESS_CONFIG = 201</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to an operator plugin process
configuration object.
<p>This means that the handle supports the <code>handle</code>, <code>pcfg</code>, and <code>xcfg</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_BACK_PROCESS_CONFIG = 203</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a backend plugin process
configuration object.
<p>This means that the handle supports the <code>handle</code>, <code>pcfg</code>, and <code>xcfg</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_FRONT_THREAD_CONFIG = 204</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a frontend plugin thread
configuration object.
<p>This means that the handle supports the <code>handle</code>, <code>tcfg</code>, and <code>xcfg</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_OPER_THREAD_CONFIG = 205</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to an operator plugin thread
configuration object.
<p>This means that the handle supports the <code>handle</code>, <code>tcfg</code>, and <code>xcfg</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_BACK_THREAD_CONFIG = 206</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a backend plugin thread
configuration object.
<p>This means that the handle supports the <code>handle</code>, <code>tcfg</code>, and <code>xcfg</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_SIM_CONFIG = 207</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a simulator configuration
object.
<p>This means that the handle supports the <code>handle</code> and <code>scfg</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_SIM = 208</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a simulator instance.
<p>This means that the handle supports the <code>handle</code> and <code>sim</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_FRONT_DEF = 300</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a frontend plugin
definition object.
<p>This means that the handle supports the <code>handle</code> and <code>pdef</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_OPER_DEF = 301</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to an operator plugin
definition object.
<p>This means that the handle supports the <code>handle</code> and <code>pdef</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_BACK_DEF = 302</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a backend plugin
definition object.
<p>This means that the handle supports the <code>handle</code> and <code>pdef</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_PLUGIN_JOIN = 303</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a plugin thread join handle.
<p>This means that the handle supports the <code>handle</code> and <code>pjoin</code>
interfaces.</p>
</div></details>
</p>
</div></details>
<details><summary><font color="purple"><tt>dqcs_loglevel_t</tt></font><div style="margin-left: 16px">
<p>Enumeration of loglevels and logging modes.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_loglevel_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_LOG_INVALID = -1</tt></font></summary><div style="margin-left: 16px">
Invalid loglevel. Used to indicate failure of an API that returns a
loglevel.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_OFF = 0</tt></font></summary><div style="margin-left: 16px">
Turns logging off.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_FATAL = 1</tt></font></summary><div style="margin-left: 16px">
This loglevel is to be used for reporting a fatal error, resulting from
the owner of the logger getting into an illegal state from which it
cannot recover. Such problems are also reported to the API caller via
Result::Err if applicable.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_ERROR = 2</tt></font></summary><div style="margin-left: 16px">
This loglevel is to be used for reporting or propagating a non-fatal
error caused by the API caller doing something wrong. Such problems are
also reported to the API caller via Result::Err if applicable.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_WARN = 3</tt></font></summary><div style="margin-left: 16px">
This loglevel is to be used for reporting that a called API/function is
telling us we did something wrong (that we weren't expecting), but we
can recover. For instance, for a failed connection attempt to something
that really should not be failing, we can still retry (and eventually
report critical or error if a retry counter overflows). Since we're
still trying to rectify things at this point, such problems are NOT
reported to the API/function caller via Result::Err.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_NOTE = 4</tt></font></summary><div style="margin-left: 16px">
This loglevel is to be used for reporting information specifically
requested by the user/API caller, such as the result of an API function
requested through the command line, or an explicitly captured
stdout/stderr stream.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_INFO = 5</tt></font></summary><div style="margin-left: 16px">
This loglevel is to be used for reporting information NOT specifically
requested by the user/API caller, such as a plugin starting up or
shutting down.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_DEBUG = 6</tt></font></summary><div style="margin-left: 16px">
This loglevel is to be used for reporting debugging information useful
for debugging the user of the API provided by the logged instance.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_TRACE = 7</tt></font></summary><div style="margin-left: 16px">
This loglevel is to be used for reporting debugging information useful
for debugging the internals of the logged instance. Such messages would
normally only be generated by debug builds, to prevent them from
impacting performance under normal circumstances.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_PASS = 8</tt></font></summary><div style="margin-left: 16px">
This is intended to be used when configuring the stdout/stderr capture
mode for a plugin process. Selecting it will prevent the stream from
being captured; it will just be the same stream as DQCsim's own
stdout/stderr. When used as the loglevel for a message, the message
itself is sent to stderr instead of passing into DQCsim's log system.
Using this for loglevel filters leads to undefined behavior.
</div></details>
</p>
</div></details>
<details><summary><font color="purple"><tt>dqcs_measurement_t</tt></font><div style="margin-left: 16px">
<p>Qubit measurement value.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_measurement_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_MEAS_INVALID = -1</tt></font></summary><div style="margin-left: 16px">
Error value used to indicate that something went wrong.
</div></details>
<details><summary><font color="blue"><tt>DQCS_MEAS_ZERO = 0</tt></font></summary><div style="margin-left: 16px">
Indicates that the qubit was measured to be zero.
</div></details>
<details><summary><font color="blue"><tt>DQCS_MEAS_ONE = 1</tt></font></summary><div style="margin-left: 16px">
Indicates that the qubit was measured to be one.
</div></details>
<details><summary><font color="blue"><tt>DQCS_MEAS_UNDEFINED = 2</tt></font></summary><div style="margin-left: 16px">
Indicates that the measurement value is unknown for whatever reason.
</div></details>
</p>
</div></details>
<details><summary><font color="purple"><tt>dqcs_path_style_t</tt></font><div style="margin-left: 16px">
<p>Reproduction file path style.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_path_style_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_PATH_STYLE_INVALID = -1</tt></font></summary><div style="margin-left: 16px">
Error value used to indicate that something went wrong.
</div></details>
<details><summary><font color="blue"><tt>DQCS_PATH_STYLE_KEEP = 0</tt></font></summary><div style="margin-left: 16px">
Specifies that paths should be saved the same way they were specified
on the command line.
</div></details>
<details><summary><font color="blue"><tt>DQCS_PATH_STYLE_RELATIVE = 1</tt></font></summary><div style="margin-left: 16px">
Specifies that all paths should be saved relative to DQCsim's working
directory.
</div></details>
<details><summary><font color="blue"><tt>DQCS_PATH_STYLE_ABSOLUTE = 2</tt></font></summary><div style="margin-left: 16px">
Specifies that all paths should be saved canonically, i.e. relative to
the root directory.
</div></details>
</p>
</div></details>
<details><summary><font color="purple"><tt>dqcs_plugin_type_t</tt></font><div style="margin-left: 16px">
<p>Enumeration of the three types of plugins.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_plugin_type_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_PTYPE_INVALID = -1</tt></font></summary><div style="margin-left: 16px">
Invalid plugin type. Used to indicate failure of an API that returns
a plugin type.
</div></details>
<details><summary><font color="blue"><tt>DQCS_PTYPE_FRONT = 0</tt></font></summary><div style="margin-left: 16px">
Frontend plugin.
</div></details>
<details><summary><font color="blue"><tt>DQCS_PTYPE_OPER = 1</tt></font></summary><div style="margin-left: 16px">
Operator plugin.
</div></details>
<details><summary><font color="blue"><tt>DQCS_PTYPE_BACK = 2</tt></font></summary><div style="margin-left: 16px">
Backend plugin.
</div></details>
</p>
</div></details>
<h1><a class="header" href="#arbdata-and-arbcmd-objects" id="arbdata-and-arbcmd-objects">ArbData and ArbCmd objects</a></h1>
<p><code>ArbData</code> and <code>ArbCmd</code> objects are generic objects that plugin developers may
use to expose custom functionality to the other plugins within the simulation.
DQCsim never does anything with the data contained in either object, but it
does define some basic structure to them.</p>
<h2><a class="header" href="#contents-4" id="contents-4">Contents</a></h2>
<ul>
<li><a href="c-api/arb.apigen.html"><code>ArbData</code> objects</a></li>
<li><a href="c-api/cmd.apigen.html"><code>ArbCmd</code> objects</a></li>
<li><a href="c-api/cq.apigen.html"><code>ArbCmd</code> queues</a></li>
</ul>
<h1><a class="header" href="#arbdata-objects" id="arbdata-objects">ArbData objects</a></h1>
<p><code>ArbData</code> objects are used to communicate custom data between plugins. They are
managed through the <code>dqcs_arb_*</code> functions. They are created using
<code>dqcs_arb_new()</code>:</p>
<details><summary><font color="green"><tt>dqcs_arb_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new <code>ArbData</code> object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_arb_new(void)
</code></pre>
<p>Returns the handle of the newly created <code>ArbData</code>. The <code>ArbData</code> is
initialized with JSON object <code>{}</code> and an empty binary argument list.</p>
<p><code>ArbData</code> objects support the <code>handle</code> and <code>arb</code> APIs.</p>
</div></details>
<p>Unlike most other objects, the data contained within one <code>ArbData</code> object can
also be copied to another <code>ArbData</code>.</p>
<details><summary><font color="green"><tt>dqcs_arb_assign()</tt></font><div style="margin-left: 16px">
<p>Copies the data from one object to another.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_assign(
    dqcs_handle_t dest,
    dqcs_handle_t src
)
</code></pre>
</div></details>
<h2><a class="header" href="#json-like-data" id="json-like-data">JSON-like data</a></h2>
<p>To prevent the API from exploding, DQCsim does not provide any functions to
manipulate the JSON data; you can only read and write the complete object in
one go.</p>
<details><summary><font color="green"><tt>dqcs_arb_json_get()</tt></font><div style="margin-left: 16px">
<p>Returns the JSON/CBOR object of an <code>ArbData</code> object in the form of a JSON
string.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_arb_json_get(dqcs_handle_t arb)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_json_set()</tt></font><div style="margin-left: 16px">
<p>Sets the JSON/CBOR object of an <code>ArbData</code> object by means of a JSON string.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_json_set(
    dqcs_handle_t arb,
    const char *json
)
</code></pre>
</div></details>
<p>You can also read and write the object using CBOR. This is potentially much
faster, because it's a binary format.</p>
<details><summary><font color="green"><tt>dqcs_arb_cbor_get()</tt></font><div style="margin-left: 16px">
<p>Returns the JSON/CBOR object of an <code>ArbData</code> object in the form of a CBOR
object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_arb_cbor_get(
    dqcs_handle_t arb,
    void *obj,
    size_t obj_size
)
</code></pre>
<p>If the actual size of the object differs from the specified object size,
this function will copy the minimum of the actual and specified sizes
number of bytes, and return what the actual size was.</p>
<p>If the specified object size is zero, <code>obj</code> is allowed to be <code>NULL</code>. You
can use this to query the size before allocating an object.</p>
<p>This function returns -1 on failure.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_cbor_set()</tt></font><div style="margin-left: 16px">
<p>Sets the JSON/CBOR object of an <code>ArbData</code> object by means of a CBOR object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_cbor_set(
    dqcs_handle_t arb,
    const void *obj,
    size_t obj_size
)
</code></pre>
</div></details>
<h2><a class="header" href="#binary-strings" id="binary-strings">Binary strings</a></h2>
<p>Unlike the JSON object, the binary string list (a.k.a. unstructured data) is
managed by DQCsim. Therefore, DQCsim provides all the list manipulation
functions.</p>
<p>You can access the strings using both C-style strings and buffers. The former
is easier, but is not binary safe: you cannot write binary strings with
embedded nulls this way, and DQCsim will throw an error if you try to read a
binary string with embedded nulls.</p>
<h3><a class="header" href="#string-style-access" id="string-style-access">String-style access</a></h3>
<details><summary><font color="green"><tt>dqcs_arb_get_str()</tt></font><div style="margin-left: 16px">
<p>Returns the unstructured string argument at the specified index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_arb_get_str(
    dqcs_handle_t arb,
    ssize_t index
)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_insert_str()</tt></font><div style="margin-left: 16px">
<p>Inserts an unstructured string argument into the list at the specified
index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_insert_str(
    dqcs_handle_t arb,
    ssize_t index,
    const char *s
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_pop_str()</tt></font><div style="margin-left: 16px">
<p>Pops an unstructured string argument from the back of the list.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_arb_pop_str(dqcs_handle_t arb)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>. If the failure is due to the
conversion from binary object to C string (i.e., embedded nulls), the
data is still popped and is thus lost.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_push_str()</tt></font><div style="margin-left: 16px">
<p>Pushes an unstructured string argument to the back of the list.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_push_str(
    dqcs_handle_t arb,
    const char *s
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_set_str()</tt></font><div style="margin-left: 16px">
<p>Replaces the unstructured argument at the specified index with the
specified string.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_set_str(
    dqcs_handle_t arb,
    ssize_t index,
    const char *s
)
</code></pre>
</div></details>
<h3><a class="header" href="#buffer-style-access" id="buffer-style-access">Buffer-style access</a></h3>
<details><summary><font color="green"><tt>dqcs_arb_get_raw()</tt></font><div style="margin-left: 16px">
<p>Returns the unstructured string argument at the specified index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_arb_get_raw(
    dqcs_handle_t arb,
    ssize_t index,
    void *obj,
    size_t obj_size
)
</code></pre>
<p>If the actual size of the object differs from the specified object size,
this function will copy the minimum of the actual and specified sizes
number of bytes, and return what the actual size was.</p>
<p>If the specified object size is zero, <code>obj</code> is allowed to be <code>NULL</code>. You
can use this to determine the size of the argument prior to actually
reading it, so you can allocate the right buffer size first.</p>
<p>This function returns -1 on failure.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_insert_raw()</tt></font><div style="margin-left: 16px">
<p>Inserts an unstructured raw argument into the list at the specified
index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_insert_raw(
    dqcs_handle_t arb,
    ssize_t index,
    const void *obj,
    size_t obj_size
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_pop_raw()</tt></font><div style="margin-left: 16px">
<p>Pops an unstructured raw argument from the back of the list.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_arb_pop_raw(
    dqcs_handle_t arb,
    void *obj,
    size_t obj_size
)
</code></pre>
<p>If the actual size of the object differs from the specified object size,
this function will copy the minimum of the actual and specified sizes
number of bytes, and return what the actual size was.</p>
<p>If the specified object size is zero, <code>obj</code> is allowed to be <code>NULL</code>. You
can use this if you don't need the contents of the argument and just want
to delete it.</p>
<p>Since this function removes the returned element, data will be lost if the
specified size is smaller than the actual size. To avoid this, first use
<code>dqcs_arb_get_size(handle, -1)</code> to query the size.</p>
<p>This function returns -1 on failure. If this is due to a <code>NULL</code> buffer
being passed, the data that was popped is lost.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_push_raw()</tt></font><div style="margin-left: 16px">
<p>Pushes an unstructured raw argument to the back of the list.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_push_raw(
    dqcs_handle_t arb,
    const void *obj,
    size_t obj_size
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_set_raw()</tt></font><div style="margin-left: 16px">
<p>Replaces the unstructured argument at the specified index with the
specified raw object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_set_raw(
    dqcs_handle_t arb,
    ssize_t index,
    const void *obj,
    size_t obj_size
)
</code></pre>
</div></details>
<h3><a class="header" href="#miscellaneous-list-manipulation" id="miscellaneous-list-manipulation">Miscellaneous list manipulation</a></h3>
<details><summary><font color="green"><tt>dqcs_arb_clear()</tt></font><div style="margin-left: 16px">
<p>Clears the unstructured argument list.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_clear(dqcs_handle_t arb)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_get_size()</tt></font><div style="margin-left: 16px">
<p>Returns the size in bytes of the unstructured string argument at the
specified index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_arb_get_size(
    dqcs_handle_t arb,
    ssize_t index
)
</code></pre>
<p>Returns -1 when the function fails.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_len()</tt></font><div style="margin-left: 16px">
<p>Returns the number of unstructured arguments, or -1 to indicate failure.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_arb_len(dqcs_handle_t arb)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_pop()</tt></font><div style="margin-left: 16px">
<p>Pops an unstructured argument from the back of the list without returning
it.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_pop(dqcs_handle_t arb)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_remove()</tt></font><div style="margin-left: 16px">
<p>Removes the specified unstructured string argument from the list.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_remove(
    dqcs_handle_t arb,
    ssize_t index
)
</code></pre>
</div></details>
<h1><a class="header" href="#arbcmd-objects" id="arbcmd-objects">ArbCmd objects</a></h1>
<p><code>ArbCmd</code> objects are created using <code>dqcs_cmd_new()</code>:</p>
<details><summary><font color="green"><tt>dqcs_cmd_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new <code>ArbCmd</code> object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_cmd_new(
    const char *iface,
    const char *oper
)
</code></pre>
<p>Returns the handle of the newly created <code>ArbCmd</code>. The <code>ArbCmd</code> is
initialized with the given interface and operation IDs, JSON object <code>{}</code>,
and an empty binary argument list. Upon failure, returns 0.</p>
<p><code>ArbCmd</code> objects support the <code>handle</code>, <code>arb</code>, and <code>cmd</code> interfaces.</p>
</div></details>
<p>The interface and operation IDs are immutable after construction. They can be
matched and read using the following functions.</p>
<details><summary><font color="green"><tt>dqcs_cmd_iface_cmp()</tt></font><div style="margin-left: 16px">
<p>Compares the interface ID of an <code>ArbCmd</code> with the given string.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_cmd_iface_cmp(
    dqcs_handle_t cmd,
    const char *iface
)
</code></pre>
<p>Returns -1 for failure, 0 for no match, or 1 for a match.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_cmd_iface_get()</tt></font><div style="margin-left: 16px">
<p>Returns the interface ID of an <code>ArbCmd</code>.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_cmd_iface_get(dqcs_handle_t cmd)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_cmd_oper_cmp()</tt></font><div style="margin-left: 16px">
<p>Compares the operation ID of an <code>ArbCmd</code> with the given string.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_cmd_oper_cmp(
    dqcs_handle_t cmd,
    const char *oper
)
</code></pre>
<p>Returns -1 for failure, 0 for no match, or 1 for a match.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_cmd_oper_get()</tt></font><div style="margin-left: 16px">
<p>Returns the operation ID of an <code>ArbCmd</code>.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_cmd_oper_get(dqcs_handle_t cmd)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<p>In addition to the IDs, <code>ArbCmd</code> objects carry an <code>ArbData</code> object along with
them as an argument. This object is accessed by applying <code>dqcs_arb_*()</code>
functions directly to the <code>ArbCmd</code> handle.</p>
<h1><a class="header" href="#arbcmd-queues" id="arbcmd-queues">ArbCmd queues</a></h1>
<p>Some interfaces allow multiple commands to be specified. This is done through
command queue objects.</p>
<h2><a class="header" href="#constructing-a-command-queue" id="constructing-a-command-queue">Constructing a command queue</a></h2>
<p>To construct a command queue, create a handle using <code>dqcs_cq_new()</code>, and then
push <code>ArbCmd</code> objects into it one by one using <code>dqcs_cq_push()</code>. To keep the
API simple, it is not possible to insert by index or override previously added
commands</p>
<details><summary><font color="green"><tt>dqcs_cq_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new <code>ArbCmd</code> queue object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_cq_new(void)
</code></pre>
<p>Returns the handle of the newly created <code>ArbCmd</code> queue. The queue is
initially empty. Queues implement a &quot;first-in, first-out&quot; model.</p>
<p><code>ArbCmd</code> queue objects support the <code>handle</code>, <code>arb</code>, <code>cmd</code>, and <code>cq</code> APIs.</p>
<p>The <code>arb</code> and <code>cmd</code> APIs refer to the <code>ArbCmd</code> at the front of the queue.
Use <code>dqcs_cq_next()</code> to remove the front entry, allowing access to the next
command.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_cq_push()</tt></font><div style="margin-left: 16px">
<p>Pushes an <code>ArbCmd</code> object into the given <code>ArbCmd</code> queue.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_cq_push(
    dqcs_handle_t cq,
    dqcs_handle_t cmd
)
</code></pre>
<p>This function returns -1 to indicate failure. The <code>ArbCmd</code> object specified
by <code>cmd</code> is moved into the queue. That is, the handle is consumed if and
only if the function succeeds.</p>
</div></details>
<h2><a class="header" href="#iterating-over-a-command-queue" id="iterating-over-a-command-queue">Iterating over a command queue</a></h2>
<p>Command queues can be iterated over as follows (note, only once!):</p>
<pre><code class="language-C">dqcs_handle_t queue = ...;
for (; dqcs_cq_len(queue) &gt; 0; dqcs_cq_next(queue)) {
    ...
}
</code></pre>
<p>Within the loop body, the <code>queue</code> variable can be used as if it's an <code>ArbCmd</code>
handle. The iteration happens in the same order in which <code>dqcs_cq_push()</code> was
called.</p>
<details><summary><font color="green"><tt>dqcs_cq_len()</tt></font><div style="margin-left: 16px">
<p>Returns the number of <code>ArbCmd</code> objects in the given <code>ArbCmd</code> queue.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_cq_len(dqcs_handle_t cq)
</code></pre>
<p>This function returns -1 to indicate failure.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_cq_next()</tt></font><div style="margin-left: 16px">
<p>Advances an <code>ArbCmd</code> queue to the next command.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_cq_next(dqcs_handle_t cq)
</code></pre>
<p>Use the <code>dqcs_arb_*</code> and <code>dqcs_cmd_*</code> interfaces to read out the command
before calling this function.</p>
<p>To iterate over a queue in C, use the following snippit:</p>
<pre><code class="language-C">for (; dqcs_cq_len(queue) &gt; 0; dqcs_cq_next(queue)) {
    dqcs_cmd_...(queue, ...)
    dqcs_arb_...(queue, ...)
}
</code></pre>
</div></details>
<h1><a class="header" href="#qubits" id="qubits">Qubits</a></h1>
<p>While DQCsim does not perform any quantum simulation on its own, and therefore
does not maintain any kind of state space to refer to or measure, it is still
very important to be able to <em>refer</em> to qubits. This is done using integers,
specifically of the type <code>dqcs_qubit_t</code>, in a way that is not dissimilar from
handles. The biggest difference compared to handles is that the entity that is
referred to is not owned by DQCsim, but rather by the downstream plugin.</p>
<h2><a class="header" href="#allocating-and-freeing-qubits-1" id="allocating-and-freeing-qubits-1">Allocating and freeing qubits</a></h2>
<p>To be as flexible as possible, DQCsim allows qubits to be allocated and freed
at any time. There is no physical analogue to this, but then again, a
conventional computer cannot create and destroy physical bits out of thin air,
either. This dynamic allocation intends to help solve two problems:</p>
<ul>
<li>Operator plugins that perform a logical-to-physical mapping need to know
which logical qubits are actually in use.</li>
<li>By doing allocation on-the-fly, a quantum algorithm doesn't need to specify
how many qubits it's going to need before it's started. It can for instance
interpret a file first, perform some classical computations, and determine
the qubit requirements based on that.</li>
<li>Quantum simulations take up a lot of memory. Depending on the
implementation, they may be able to use liveness information for
optimizations.</li>
</ul>
<p>The numbers assigned to the qubit references/handles are guaranteed to be
sequential and unique within a simulation. Zero is reserved, so the first
allocated qubit is always qubit 1. The second is qubit 2, and so on. Even if
we free both of those, the next qubit will still be qubit 3. Implementation
code can rely on this behavior if it wants.</p>
<p>Since qubits are owned by the downstream plugin, there is no function to ask
DQCsim itself for a new qubit. Instead, this is done using
<code>dqcs_plugin_allocate()</code>. Its inverse is <code>dqcs_plugin_free()</code>. These functions
require a plugin state, which is only available from within plugin callback
functions. Specifically, the functions can only be called by running frontend
or operator plugins.</p>
<h2><a class="header" href="#sets-of-qubits" id="sets-of-qubits">Sets of qubits</a></h2>
<p>Many things within DQCsim operate not on a single qubit, but on a set of
qubits. Such a set is represented through a <code>qbset</code> handle.</p>
<h3><a class="header" href="#constructing-a-qubit-set" id="constructing-a-qubit-set">Constructing a qubit set</a></h3>
<p>A qubit set can be constructed as follows. It is assumed that the qubits have
already been allocated.</p>
<pre><code class="language-C">dqcs_handle_t qbset = dqcs_qbset_new();
for (qubit = ...; ...; ...) {
    dqcs_qbset_push(qbset, qubit);
}
</code></pre>
<details><summary><font color="green"><tt>dqcs_qbset_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new set of qubit references.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_qbset_new(void)
</code></pre>
<p>Returns the handle of the newly created set. The set is initially empty.
Qubit sets are ordered, meaning that the order in which qubits are popped
from the set equals the order in which they were pushed. To iterate over a
set, simply make a copy and drain the copy using pop.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_qbset_push()</tt></font><div style="margin-left: 16px">
<p>Pushes a qubit reference into a qubit reference set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_qbset_push(
    dqcs_handle_t qbset,
    dqcs_qubit_t qubit
)
</code></pre>
<p>This function will fail if the specified qubit was already part of the set.</p>
</div></details>
<h3><a class="header" href="#iterating-over-a-qubit-set" id="iterating-over-a-qubit-set">Iterating over a qubit set</a></h3>
<p>Iterating over a qubit set can be done as follows.</p>
<pre><code class="language-C">dqcs_handle_t qbset = ...;
dqcs_qubit_t qubit = 0;
while (qubit = dqcs_qbset_pop(qbset)) {
    ...
}
dqcs_handle_delete(qbset);
</code></pre>
<details><summary><font color="green"><tt>dqcs_qbset_pop()</tt></font><div style="margin-left: 16px">
<p>Pops a qubit reference off of a qubit reference set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_qubit_t dqcs_qbset_pop(dqcs_handle_t qbset)
</code></pre>
<p>Qubits are popped in the same order in which they were pushed. That is,
they are FIFO-ordered.</p>
</div></details>
<p>Note that insertion order is maintained (in FIFO order). This means that qubit
sets can be used for specifying the target qubits of a multi-qubit gate.</p>
<p>Note also that iteration is destructive: the set will be empty when iteration
completes. If you need to iterate over a set multiple times, you can make a
copy first.</p>
<details><summary><font color="green"><tt>dqcs_qbset_copy()</tt></font><div style="margin-left: 16px">
<p>Returns a copy of the given qubit set, intended for non-destructive
iteration.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_qbset_copy(dqcs_handle_t qbset)
</code></pre>
</div></details>
<h3><a class="header" href="#querying-qubit-sets" id="querying-qubit-sets">Querying qubit sets</a></h3>
<p>You can also query qubit sets non-destructively using the following two
functions.</p>
<details><summary><font color="green"><tt>dqcs_qbset_contains()</tt></font><div style="margin-left: 16px">
<p>Returns whether the given qubit set contains the given qubit.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_qbset_contains(
    dqcs_handle_t qbset,
    dqcs_qubit_t qubit
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_qbset_len()</tt></font><div style="margin-left: 16px">
<p>Returns the number of qubits in the given set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_qbset_len(dqcs_handle_t qbset)
</code></pre>
<p>This function returns -1 to indicate failure.</p>
</div></details>
<h1><a class="header" href="#gates" id="gates">Gates</a></h1>
<p>The state of a quantum system is modified by means of quantum gates.</p>
<h2><a class="header" href="#constructing-gates" id="constructing-gates">Constructing gates</a></h2>
<p>DQCsim provides three types of gates:</p>
<ul>
<li>Unitary gates: these apply a gate matrix on one or more qubits.</li>
<li>Measurement gates: these cause the state of a qubit to be collapsed along
and measured in the Z basis.</li>
<li>Custom gates: anything else that the downstream plugin supports.</li>
</ul>
<p>These are constructed using the following functions.</p>
<details><summary><font color="green"><tt>dqcs_gate_new_unitary()</tt></font><div style="margin-left: 16px">
<p>Constructs a new unitary gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_new_unitary(
    dqcs_handle_t targets,
    dqcs_handle_t controls,
    const double *matrix,
    size_t matrix_len
)
</code></pre>
<p><code>targets</code> must be a handle to a non-empty qubit set. The qubits in this set
correspond with the supplied unitary matrix.</p>
<p><code>controls</code> optionally specifies a set of control qubits. You may pass 0 or
an empty qubit set if you don't need control qubits.</p>
<p><code>matrix</code> must point to an appropriately sized array of doubles,
representing the unitary matrix to be applied to the qubits in the
<code>targets</code> set. The matrix is specified in row-major form, using pairs of
doubles for the real vs. imaginary component of each entry. The size must
thus be <code>4**len(targets)</code> complex numbers = <code>2*4**len(targets)</code> doubles =
<code>16*4**len(targets)</code> bytes. <code>matrix_len</code> must be set to the number of
complex numbers.</p>
<p>The supplied matrix is only applied to the target qubits if all the control
qubits are or will be determined to be set. For instance, to encode a
CCNOT/Toffoli gate, you can specify one target qubits, two control qubits,
and [0, 1; 1, 0] (X) for the matrix. This is equivalent to extending the
matrix to the full Toffoli matrix and specifying all three qubits in the
targets set, or the midway solution using a CNOT matrix, but these
solutions may be less efficient depending on whether the simulator can
optimize its calculations for controlled gates.</p>
<p>Simulators are not required to apply the (hidden) global phase component of
the gate matrix in the same way it is specified; that is, if the simulator
can optimize its calculations by altering the global phase it is allowed
to.</p>
<p>If is up to the user to ensure that the specified matrix is unitary. This
is NOT checked by DQCsim. The simulator backend may or may not check this.</p>
<p>This function returns the handle to the gate, or 0 to indicate failure.
The <code>targets</code> qubit set and (if specified) the <code>controls</code> qubit set are
consumed/deleted by this function if and only if it succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_new_measurement()</tt></font><div style="margin-left: 16px">
<p>Constructs a new measurement gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_new_measurement(dqcs_handle_t measures)
</code></pre>
<p><code>measures</code> must be a handle to a qubit set. The qubits in this set are
measured in the Z-basis. To measure in other bases, first apply the
respective rotation, or use a custom gate.</p>
<p>This function returns the handle to the gate, or 0 to indicate failure.
The <code>measures</code> qubit set is consumed/deleted by this function if and only
if it succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_new_custom()</tt></font><div style="margin-left: 16px">
<p>Constructs a new custom gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_new_custom(
    const char *name,
    dqcs_handle_t targets,
    dqcs_handle_t controls,
    dqcs_handle_t measures,
    const double *matrix,
    size_t matrix_len
)
</code></pre>
<p>The functionality of custom gates is not specified by DQCsim. Instead, this
is left up to the plugins. Of course, for this to work, plugins that are
connected to each other must agree on the format used.</p>
<p><code>name</code> specifies the name of the gate. The name is used to indicate which
custom operation is to be applied.</p>
<p><code>targets</code> optionally specifies the set of target qubits. You may pass 0 or
an empty qubit set if you don't need target qubits.</p>
<p><code>controls</code> optionally specifies the set of control qubits. You may pass 0
or an empty qubit set if you don't need control qubits.</p>
<p><code>measures</code> optionally specifies the set of measured qubits. You may pass 0
or an empty qubit set if no qubits are measured. Note that the upstream
plugin expects exactly one measurement result for each qubit specified in
this set; anything else results in a warning and the measurement result
being set to undefined.</p>
<p><code>matrix</code> can point to an appropriately sized array of doubles, or be <code>NULL</code>
if no matrix is required. If a matrix is specified, at least one target
qubit is required, and the matrix must be appropriately sized for the
number of target qubits. The matrix is specified in row-major form, using
pairs of doubles for the real vs. imaginary component of each entry. The
size must thus be <code>4**len(targets)</code> complex numbers = <code>2*4**len(targets)</code>
doubles = <code>16*4**len(targets)</code> bytes. <code>matrix_len</code> must be set to the
number of complex numbers.</p>
<p>In addition to the above data, gate objects implement the <code>arb</code> interface
to allow user-specified classical information to be attached.</p>
<p>This function returns the handle to the gate, or 0 to indicate failure.
The specified qubit sets are consumed/deleted by this function if and only
if it succeeds.</p>
</div></details>
<h2><a class="header" href="#attached-classical-data" id="attached-classical-data">Attached classical data</a></h2>
<p>Classical information can be attached to any gate using the <code>ArbData</code>
protocol: gate handles support all the <code>dqcs_arb_*()</code> API calls. This is
primarily intended for custom gates.</p>
<h2><a class="header" href="#interpreting-gates" id="interpreting-gates">Interpreting gates</a></h2>
<p>Backend and operator plugins have to process incoming gates using the following
algorithm to be compliant with DQCsim's interface.</p>
<ul>
<li>
<p>If the gate has a name (equivalent to it being a custom gate), defer to the
custom gate logic identified by this name. Name matching should be
case-sensitive. If an unsupported/unknown gate is requested, an error must
be generated. The custom gate logic may make use of the <code>ArbData</code> attached
to the gate object.</p>
</li>
<li>
<p>If the gate doesn't have a name and doesn't have any <code>ArbData</code> attached:</p>
<ul>
<li>
<p>If the gate has target qubits, no control qubits, and a gate matrix,
apply the gate matrix to the target qubits.</p>
</li>
<li>
<p>If the gate has target qubits, control qubits, and a gate matrix,
convert the gate matrix into a controlled gate with the appropriate
number of control qubits, and then apply it to the concatenation of the
control and target qubit sets.</p>
</li>
<li>
<p>If the gate has measurement qubits, collapse the state of these qubits in
the Z basis and return the measurements. The random number generator
provided by DQCsim (or another PRNG seeded by DQCsim's RNG) should be
used to collapse the state.</p>
</li>
</ul>
</li>
<li>
<p>If the gate has no name but does have <code>ArbData</code>, the gate <em>may</em> be
interpreted in a customized way. For instance, this data can be used to
apply random errors to the gate. However, it is recommended to not change
the functionality too much; that's what custom gates are for.</p>
</li>
</ul>
<p>Note that the above implies that a gate can consist of both a unitary gate and
one or more measurements, to be applied in that order. It is currently however
impossible to construct such a gate using the C API.</p>
<p>The following functions can be used to read the data associated with a gate.</p>
<details><summary><font color="green"><tt>dqcs_gate_controls()</tt></font><div style="margin-left: 16px">
<p>Returns a handle to a new qubit reference set containing the qubits
that control this gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_controls(dqcs_handle_t gate)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_has_controls()</tt></font><div style="margin-left: 16px">
<p>Returns whether the specified gate has control qubits.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_gate_has_controls(dqcs_handle_t gate)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_has_matrix()</tt></font><div style="margin-left: 16px">
<p>Returns whether a unitary matrix is associated with this gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_gate_has_matrix(dqcs_handle_t gate)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_has_measures()</tt></font><div style="margin-left: 16px">
<p>Returns whether the specified gate measures any qubits.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_gate_has_measures(dqcs_handle_t gate)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_has_targets()</tt></font><div style="margin-left: 16px">
<p>Returns whether the specified gate has target qubits.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_gate_has_targets(dqcs_handle_t gate)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_is_custom()</tt></font><div style="margin-left: 16px">
<p>Returns whether the specified gate is a custom gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_gate_is_custom(dqcs_handle_t gate)
</code></pre>
<p>If this returns true, the type of gate is to be determined by matching its
name against a set of known gate types. If this returns false, the gate is
expected to be executed as follows, in this order:</p>
<ul>
<li>if there are target qubits, extend the supplied unitary matrix to
include the control qubits (if any), then apply it to the control +
target qubits;</li>
<li>measure each measured qubit (if any) in the Z basis.</li>
</ul>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_matrix()</tt></font><div style="margin-left: 16px">
<p>Returns a copy of the unitary matrix associated with this gate, if one
exists.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">double *dqcs_gate_matrix(dqcs_handle_t gate)
</code></pre>
<p>If this function succeeds, the matrix is returned in row-major form, using
pairs of doubles for the real vs. imaginary component of each entry. The
size will be <code>4**len(targets)</code> complex numbers = <code>2*4**len(targets)</code>
doubles = <code>16*4**len(targets)</code> bytes.</p>
<p>On success, this <strong>returns a newly allocated array containing the matrix.
Free it with <code>free()</code> when you're done with it to avoid memory leaks.</strong> On
failure, or if no matrix is associated with this gate, this returns <code>NULL</code>.
Use <code>dqcs_gate_has_matrix()</code> to disambiguate.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_matrix_len()</tt></font><div style="margin-left: 16px">
<p>Returns the size of the gate matrix associated with this gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_gate_matrix_len(dqcs_handle_t gate)
</code></pre>
<p>The size is returned in the form of the number of complex entries. That is,
the number of doubles is two times the return value, and the size in bytes
is 8 times the return value. 0 is returned when there is no matrix. -1 is
used to report errors.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_measures()</tt></font><div style="margin-left: 16px">
<p>Returns a handle to a new qubit reference set containing the qubits
measured by this gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_measures(dqcs_handle_t gate)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_name()</tt></font><div style="margin-left: 16px">
<p>Returns the name of a custom gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_gate_name(dqcs_handle_t gate)
</code></pre>
<p>This function fails if the gate is not a custom gate. Query
<code>dqcs_gate_is_custom()</code> to disambiguate between a non-custom gate and a
different error.</p>
<p>On success, this <strong>returns a newly allocated string containing the gate
name. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_targets()</tt></font><div style="margin-left: 16px">
<p>Returns a handle to a new qubit reference set containing the qubits
targetted by this gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_targets(dqcs_handle_t gate)
</code></pre>
</div></details>
<h1><a class="header" href="#measurements" id="measurements">Measurements</a></h1>
<p>Measurements are returned in response to measurement gates. While the
measurement result for a qubit is normally just a 0 or a 1 (or some other
boolean convention), DQCsim allows additional information to be attached,
and also allows an &quot;undefined&quot; state to model measurement failure.
Measurement objects/handles are used to encapsulate this. Furthermore, since
a single function call may have to return multiple measurements, measurement
sets are defined as well.</p>
<h2><a class="header" href="#contents-5" id="contents-5">Contents</a></h2>
<ul>
<li><a href="c-api/meas.apigen.html">Singular measurements</a></li>
<li><a href="c-api/mset.apigen.html">Measurement sets</a></li>
</ul>
<h1><a class="header" href="#singular-measurements" id="singular-measurements">Singular measurements</a></h1>
<p>Singular measurements, i.e. a single measurement for a single qubit, are
represented through <code>meas</code> handles.</p>
<h2><a class="header" href="#constructing-measurement-objects" id="constructing-measurement-objects">Constructing measurement objects</a></h2>
<p>Measurement objects are constructed using <code>dqcs_meas_new()</code>.</p>
<details><summary><font color="green"><tt>dqcs_meas_new()</tt></font><div style="margin-left: 16px">
<p>Constructs a new measurement object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_meas_new(
    dqcs_qubit_t qubit,
    dqcs_measurement_t value
)
</code></pre>
<p><code>qubit</code> must be set to the qubit that was measured, <code>value</code> must be set to
its value. The return value is the handle to the measurement object, or 0
if something went wrong.</p>
<p>Note that measurement objects implement the <code>arb</code> interface, so additional
data can be attached to the object.</p>
</div></details>
<p>They are also mutable after construction.</p>
<details><summary><font color="green"><tt>dqcs_meas_qubit_set()</tt></font><div style="margin-left: 16px">
<p>Sets the qubit reference associated with a measurement object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_meas_qubit_set(
    dqcs_handle_t meas,
    dqcs_qubit_t qubit
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_meas_value_set()</tt></font><div style="margin-left: 16px">
<p>Sets the measurement value associated with a measurement object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_meas_value_set(
    dqcs_handle_t meas,
    dqcs_measurement_t value
)
</code></pre>
</div></details>
<h2><a class="header" href="#attaching-custom-data" id="attaching-custom-data">Attaching custom data</a></h2>
<p>Measurement objects support the <code>ArbData</code> protocol for attaching custom data.
That is, all <code>dqcs_arb_*()</code> API calls can be applied to measurement handles.</p>
<h2><a class="header" href="#querying-measurement-objects" id="querying-measurement-objects">Querying measurement objects</a></h2>
<p>The measurement value and qubit reference can be queried from a measurement
object as follows.</p>
<details><summary><font color="green"><tt>dqcs_meas_qubit_get()</tt></font><div style="margin-left: 16px">
<p>Returns the qubit reference associated with a measurement object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_qubit_t dqcs_meas_qubit_get(dqcs_handle_t meas)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_meas_value_get()</tt></font><div style="margin-left: 16px">
<p>Returns the measurement value associated with a measurement object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_measurement_t dqcs_meas_value_get(dqcs_handle_t meas)
</code></pre>
</div></details>
<h1><a class="header" href="#measurement-sets" id="measurement-sets">Measurement sets</a></h1>
<p>A measurement set encapsulates measurement results for zero or more qubits. It
is therefore actually more like a map/dictionary than a set.</p>
<h2><a class="header" href="#constructing-measurement-sets" id="constructing-measurement-sets">Constructing measurement sets</a></h2>
<p>A measurement set can be constructed as follows.</p>
<pre><code class="language-C">dqcs_handle_t mset = dqcs_mset_new();
for (qubit, value = ...; ...; ...) {
    dqcs_handle_t meas = dqcs_meas_new(qubit, value);
    dqcs_mset_set(mset, meas);
    dqcs_handle_delete(meas);
}
</code></pre>
<details><summary><font color="green"><tt>dqcs_mset_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new set of qubit measurement results.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_mset_new(void)
</code></pre>
<p>Returns the handle of the newly created set. The set is initially empty.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_mset_set()</tt></font><div style="margin-left: 16px">
<p>Adds a measurement result to a measurement result set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_mset_set(
    dqcs_handle_t mset,
    dqcs_handle_t meas
)
</code></pre>
<p>If there was already a measurement for the specified qubit, the previous
measurement result is overwritten. The measurement result object is deleted
if and only if the function succeeds.</p>
</div></details>
<h2><a class="header" href="#iterating-over-measurement-sets" id="iterating-over-measurement-sets">Iterating over measurement sets</a></h2>
<p>Destructive iteration can be performed as follows if needed.</p>
<pre><code class="language-C">dqcs_handle_t mset = ...;
while ((dqcs_handle_t meas = dqcs_mset_take_any(mset))) {
    dqcs_qubit_t qubit = dqcs_meas_qubit_get(meas);
    dqcs_measurement_t value = dqcs_meas_value_get(meas);
    dqcs_handle_delete(meas);
    ...
}
</code></pre>
<p>To iterate nondestructively, one would have to construct a new measurement set
while iterating.</p>
<details><summary><font color="green"><tt>dqcs_mset_take_any()</tt></font><div style="margin-left: 16px">
<p>Returns the measurement result for any of the qubits contained in a
measurement result set and removes it from the set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_mset_take_any(dqcs_handle_t mset)
</code></pre>
<p>This is useful for iteration.</p>
</div></details>
<p>Note that insertion order is <em>not</em> preserved. Measurements can also be removed
from a measurement set in a controlled order using the following functions.</p>
<details><summary><font color="green"><tt>dqcs_mset_take()</tt></font><div style="margin-left: 16px">
<p>Returns the measurement result for the given qubit from a measurement
result set and removes it from the set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_mset_take(
    dqcs_handle_t mset,
    dqcs_qubit_t qubit
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_mset_remove()</tt></font><div style="margin-left: 16px">
<p>Removes the measurement result for the given qubit from a measurement
result set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_mset_remove(
    dqcs_handle_t mset,
    dqcs_qubit_t qubit
)
</code></pre>
</div></details>
<h2><a class="header" href="#querying-measurement-sets" id="querying-measurement-sets">Querying measurement sets</a></h2>
<p>Measurement sets can be queried nondestructively using the following functions.</p>
<details><summary><font color="green"><tt>dqcs_mset_contains()</tt></font><div style="margin-left: 16px">
<p>Returns whether the given qubit measurement set contains data for the given
qubit.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_mset_contains(
    dqcs_handle_t mset,
    dqcs_qubit_t qubit
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_mset_get()</tt></font><div style="margin-left: 16px">
<p>Returns a copy of the measurement result for the given qubit from a
measurement result set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_mset_get(
    dqcs_handle_t mset,
    dqcs_qubit_t qubit
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_mset_len()</tt></font><div style="margin-left: 16px">
<p>Returns the number of qubits measurements in the given measurement set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_mset_len(dqcs_handle_t mset)
</code></pre>
<p>This function returns -1 to indicate failure.</p>
</div></details>
<h1><a class="header" href="#plugins" id="plugins">Plugins</a></h1>
<p>Now that we have all the generic data structures out of the way, let's focus on
building DQCsim plugins.</p>
<h2><a class="header" href="#contents-6" id="contents-6">Contents</a></h2>
<ul>
<li><a href="c-api/pdef.apigen.html">Defining a plugin</a></li>
<li><a href="c-api/plugin-run.apigen.html">Running a plugin</a></li>
<li><a href="c-api/plugin-interact.html">Interacting with DQCsim</a></li>
</ul>
<h1><a class="header" href="#defining-a-plugin" id="defining-a-plugin">Defining a plugin</a></h1>
<p>Before a plugin can be started, it must be &quot;defined&quot;. This process is largely
concerned with installing callback functions and setting some metadata that is
common to all plugins.</p>
<h2><a class="header" href="#constructing-a-plugin-definition" id="constructing-a-plugin-definition">Constructing a plugin definition</a></h2>
<p>Plugin definitions are constructed using <code>dqcs_pdef_new()</code>. This function sets
the plugin type and the plugin metadata, which is immutable after the plugin
definition object has been constructed.</p>
<details><summary><font color="green"><tt>dqcs_pdef_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new <code>PluginDefinition</code> object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_pdef_new(
    dqcs_plugin_type_t typ,
    const char *name,
    const char *author,
    const char *version
)
</code></pre>
<p>Plugin definitions contain the callback functions/closures that define the
functionality of a plugin. They also contain some metadata to identify the
implementation, in the form of a name, author, and version string, that
must be specified when the definition is constructed. The callback
functions/closures are initialized to sane defaults for the requested
plugin type, but obviously one or more of these should be overridden to
make the plugin do something.</p>
<p>Once a definition object has been built, it can be used to spawn a plugin
thread or run a plugin in the main thread, given a DQCsim server URL for it
to connect to.</p>
</div></details>
<p>It is, however, possible to query the metadata and plugin type as follows.</p>
<details><summary><font color="green"><tt>dqcs_pdef_type()</tt></font><div style="margin-left: 16px">
<p>Returns the plugin type for the given plugin definition object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_plugin_type_t dqcs_pdef_type(dqcs_handle_t pdef)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_name()</tt></font><div style="margin-left: 16px">
<p>Returns the plugin name for the given plugin definition object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_pdef_name(dqcs_handle_t pdef)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_author()</tt></font><div style="margin-left: 16px">
<p>Returns the plugin author for the given plugin definition object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_pdef_author(dqcs_handle_t pdef)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_version()</tt></font><div style="margin-left: 16px">
<p>Returns the plugin version for the given plugin definition object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_pdef_version(dqcs_handle_t pdef)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<h2><a class="header" href="#assigning-callback-functions" id="assigning-callback-functions">Assigning callback functions</a></h2>
<p>Plugins without callback functions not only don't do anything, they'll crash!
The following matrix shows which functions are required (x), optional (o), and
not applicable (-):</p>
<table><thead><tr><th>Callback</th><th align="center">Frontend</th><th align="center">Operator</th><th align="center">Backend</th></tr></thead><tbody>
<tr><td><code>initialize</code></td><td align="center">o</td><td align="center">o</td><td align="center">o</td></tr>
<tr><td><code>drop</code></td><td align="center">o</td><td align="center">o</td><td align="center">o</td></tr>
<tr><td><code>run</code></td><td align="center">x</td><td align="center">-</td><td align="center">-</td></tr>
<tr><td><code>allocate</code></td><td align="center">-</td><td align="center">o</td><td align="center">o</td></tr>
<tr><td><code>free</code></td><td align="center">-</td><td align="center">o</td><td align="center">o</td></tr>
<tr><td><code>gate</code></td><td align="center">-</td><td align="center">o</td><td align="center">x</td></tr>
<tr><td><code>modify_measurement</code></td><td align="center">-</td><td align="center">o</td><td align="center">-</td></tr>
<tr><td><code>advance</code></td><td align="center">-</td><td align="center">o</td><td align="center">o</td></tr>
<tr><td><code>upstream_arb</code></td><td align="center">-</td><td align="center">o</td><td align="center">o</td></tr>
<tr><td><code>host_arb</code></td><td align="center">o</td><td align="center">o</td><td align="center">o</td></tr>
</tbody></table>
<p>These callback functions can be set using the following functions. Don't forget
to read the general callback information <a href="c-api/callbacks.apigen.html">here</a> as well.</p>
<details><summary><font color="green"><tt>dqcs_pdef_set_initialize_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the user logic initialization callback.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_initialize_cb(
    dqcs_handle_t pdef,
    dqcs_return_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t init_cmds
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>This is always called before any of the other callbacks are run. The
downstream plugin has already been initialized at this stage, so it is
legal to send it commands.</p>
<p>The default behavior is no-op.</p>
<p>Besides the common arguments, the callback receives a handle to an
<code>ArbCmd</code> queue (<code>dqcs_cq_*</code>, <code>dqcs_cmd_*</code>, and <code>dqcs_arb_*</code> interfaces)
containing user-defined initialization commands. This is a borrowed
handle; the caller will delete it.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning <code>DQCS_FAILURE</code>. Otherwise, it should
return <code>DQCS_SUCCESS</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_drop_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the user logic drop/cleanup callback.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_drop_cb(
    dqcs_handle_t pdef,
    dqcs_return_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>This is called when a plugin is gracefully terminated. It is not
recommended to execute any downstream instructions at this time, but it
is supported in case this is really necessary.</p>
<p>The default behavior is no-op.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning <code>DQCS_FAILURE</code>. Otherwise, it should
return <code>DQCS_SUCCESS</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_run_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the run callback for frontends.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_run_cb(
    dqcs_handle_t pdef,
    dqcs_handle_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t args
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>This is called in response to a <code>start()</code> host API call. The return
value is returned through the <code>wait()</code> host API call.</p>
<p>The default behavior is to fail with a &quot;not implemented&quot; error;
frontends backends should always override this. This callback is never
called for operator or backend plugins.</p>
<p>Besides the common arguments, the callback receives a handle to an
<code>ArbData</code> object containing the data that the host passed to <code>start()</code>.
This is a borrowed handle; the caller will delete it.</p>
<p>When the run callback is successful, it should return a valid <code>ArbData</code>
handle. This can be the same as the argument, but it can also be a new
object. This <code>ArbData</code> is returned to the host through <code>wait()</code>. This
<code>ArbData</code> object is deleted after the callback completes.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning 0. Otherwise, it should return a
valid <code>ArbData</code> handle.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_allocate_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the qubit allocation callback for operators and backends.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_allocate_cb(
    dqcs_handle_t pdef,
    dqcs_return_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t qubits,
        dqcs_handle_t alloc_cmds
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>The default for operators is to pass through to
<code>dqcs_plugin_allocate()</code>. The default for backends is no-op. This
callback is never called for frontend plugins.</p>
<p>Besides the common arguments, the callback receives a handle to a qubit
set containing the references that are to be used for the
to-be-allocated qubits and an <code>ArbCmd</code> queue containing user-defined
commands to optionally augment the behavior of the qubits. These are
borrowed handles; the caller will delete them.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning <code>DQCS_FAILURE</code>. Otherwise, it should
return <code>DQCS_SUCCESS</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_free_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the qubit deallocation callback for operators and backends.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_free_cb(
    dqcs_handle_t pdef,
    dqcs_return_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t qubits
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>The default for operators is to pass through to <code>dqcs_plugin_free()</code>.
The default for backends is no-op. This callback is never called for
frontend plugins.</p>
<p>Besides the common arguments, the callback receives a handle to a qubit
set containing the qubits that are to be freed. This is a borrowed
handle; the caller will delete it.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning <code>DQCS_FAILURE</code>. Otherwise, it should
return <code>DQCS_SUCCESS</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_gate_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the gate execution callback for operators and backends.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_gate_cb(
    dqcs_handle_t pdef,
    dqcs_handle_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t gate
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>Besides the common arguments, the callback receives a handle to the
to-be-executed gate. This is a borrowed handle; the caller will delete
it.</p>
<p>The callback must return one of the following things:</p>
<ul>
<li>a valid handle to a measurement set, created using
<code>dqcs_mset_new()</code> (this object is automatically deleted after the
callback returns);</li>
<li>a valid handle to a single qubit measurement, created using
<code>dqcs_meas_new()</code> (this object is automatically deleted after the
callback returns);</li>
<li>the handle to the supplied gate, a shortcut for not returning any
measurements (this is less clear than returning an empty measurement
set, but slightly faster); or</li>
<li>0 to report an error, after calling the error string using
<code>dqcs_set_error()</code>.</li>
</ul>
<p>Backend plugins must return a measurement result set containing exactly
those qubits specified in the measurement set. For operators, however,
the story is more complicated. Let's say we want to make a silly
operator that inverts all measurements. The trivial way to do
this would be to forward the gate, query all the measurement results
using <code>dqcs_plugin_get_measurement()</code>, invert them, stick them in a
measurement result set, and return that result set. However, this
approach is not very efficient, because <code>dqcs_plugin_get_measurement()</code>
has to wait for all downstream plugins to finish executing the gate,
forcing the OS to switch threads, etc. Instead, operators are allowed
to return only a subset (or none) of the measured qubits, as long as
they return the measurements as they arrive through the
<code>modify_measurement()</code> callback.</p>
<p>The default implementation for this callback for operators is to pass
the gate through to the downstream plugin and return an empty set of
measurements. Combined with the default implementation of
<code>modify_measurement()</code>, this behavior is sane. Backends must override
this callback; the default is to return a not-implemented error.</p>
<p>Note that for our silly example operator, the default behavior for this
function is sufficient; you'd only have to override
<code>modify_measurement()</code> to, well, modify the measurements.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_modify_measurement_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the measurement modification callback for operators.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_modify_measurement_cb(
    dqcs_handle_t pdef,
    dqcs_handle_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t meas
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>This callback is called for every measurement result received from the
downstream plugin, and returns the measurements that should be reported
to the upstream plugin. Note that the results from our plugin's
<code>dqcs_plugin_get_measurement()</code> and friends are consistent with the
results received from downstream; they are not affected by this
function.</p>
<p>The callback takes a handle to a single qubit measurement object as an
argument, and must return one of the following things:</p>
<ul>
<li>a valid handle to a measurement set, created using
<code>dqcs_mset_new()</code> (this object is automatically deleted after the
callback returns);</li>
<li>a valid handle to a single qubit measurement object, which may or
may not be the supplied one (this object is automatically deleted
after the callback returns); or</li>
<li>0 to report an error, after calling the error string using
<code>dqcs_set_error()</code>.</li>
</ul>
<p>This callback is somewhat special in that it is not allowed to call
any plugin command other than logging and the pseudorandom number
generator functions. This is because this function is called
asynchronously with respect to the downstream functions, making the
timing of these calls non-deterministic based on operating system
scheduling.</p>
<p>Note that while this function is called for only a single measurement
at a time, it is allowed to produce a vector of measurements. This
allows you to cancel propagation of the measurement by returning an
empty vector, to just modify the measurement data itself, or to
generate additional measurements from a single measurement. However,
if you need to modify the qubit references for operators that remap
qubits, take care to only send measurement data upstream when these
were explicitly requested through the associated upstream gate
function's <code>measured</code> list.</p>
<p>The default behavior for this callback is to return the measurement
without modification.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_advance_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the callback for advancing time for operators and backends.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_advance_cb(
    dqcs_handle_t pdef,
    dqcs_return_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_cycle_t cycles
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>The default behavior for operators is to pass through to
<code>dqcs_plugin_advance()</code>. The default for backends is no-op. This
callback is never called for frontend plugins.</p>
<p>Besides the common arguments, the callback receives an unsigned integer
specifying the number of cycles to advance by.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning <code>DQCS_FAILURE</code>. Otherwise, it should
return <code>DQCS_SUCCESS</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_upstream_arb_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the callback function for handling an arb from upstream for
operators and backends.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_upstream_arb_cb(
    dqcs_handle_t pdef,
    dqcs_handle_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t cmd
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>The default behavior for operators is to pass through to
<code>dqcs_plugin_arb()</code>; operators that do not support the requested
interface should always do this. The default for backends is no-op.
This callback is never called for frontend plugins.</p>
<p>Besides the common arguments, the callback receives a handle to the
<code>ArbCmd</code> object representing the request. It must return a valid
<code>ArbData</code> handle containing the response. Both objects are deleted
automatically after invocation.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning 0. Otherwise, it should return a valid
<code>ArbData</code> handle.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_host_arb_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the callback function function for handling an arb from the host.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_host_arb_cb(
    dqcs_handle_t pdef,
    dqcs_handle_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t cmd
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>The default behavior for this is no-op.</p>
<p>Besides the common arguments, the callback receives a handle to the
<code>ArbCmd</code> object representing the request. It must return a valid
<code>ArbData</code> handle containing the response. Both objects are deleted
automatically after invocation.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning 0. Otherwise, it should return a valid
<code>ArbData</code> handle.</p>
</div></details>
<h1><a class="header" href="#running-a-plugin" id="running-a-plugin">Running a plugin</a></h1>
<p>Once a plugin has been defined, it can be started. Normally, DQCsim will do
this in one way or another. There are three ways in which DQCsim can do this:</p>
<ul>
<li>by spawning a process;</li>
<li>by spawning a thread within the simulation process;</li>
<li>by letting you spawn the plugin.</li>
</ul>
<p>We'll go into this in greater depths when we get into simulation construction.
For now, I'll assume that the first thing has already happened, and the process
that was launched is the one that you're working on right now.</p>
<p>DQCsim will spawn a plugin process with a single command-line argument (in
addition to the process name as per convention). This argument identifies a
FIFO file or address of some kind that tells the DQCsim instance running in
the plugin process how to connect to the DQCsim instance that controls the
simulation. You don't need to know anything about the syntax of this argument;
all you need to do is pass it to <code>dqcs_plugin_run()</code>, along with a plugin
definition.</p>
<details><summary><font color="green"><tt>dqcs_plugin_run()</tt></font><div style="margin-left: 16px">
<p>Executes a plugin in the current thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_plugin_run(
    dqcs_handle_t pdef,
    const char *simulator
)
</code></pre>
<p><code>pdef</code> must be an appropriately populated plugin definition object.
Its callback functions will be called from the current thread, from within
the context of this function.</p>
<p><code>simulator</code> must be set to the address of our endpoint of the simulator
that's using the plugin; DQCsim normally passes this as the first command
line argument of the plugin process.</p>
<p>If the plugin starts, the <code>pdef</code> handle is consumed by this function,
regardless of whether the plugin eventually closes normally. The handle is
only left alive if <code>pdef</code> is not a plugin definition object.</p>
</div></details>
<p>If the function fails, your process should return a nonzero exit code; if it
succeeds, it should return 0. And that's it!</p>
<p>Some notes, though:</p>
<ul>
<li>If you spawned the process manually, you're in control of how the connection
endpoint string is passed. So you can do something else if you like, but
keep in mind that the command-line interface won't be able to use your
plugin in that case.</li>
<li>The connection endpoint is currently a FIFO file, so it cannot connect to
another machine.</li>
<li><code>dqcs_plugin_run()</code> is a blocking function call. If you're making some
awesome plugin server that needs to be able to run multiple plugin threads
at a time, you can also use the asynchronous equivalents below. This is
particularly useful in case you want to construct the plugin definition in
your main thread for some reason. However, you can currently only use a
plugin definition once; it is deleted by <code>dqcs_plugin_start()</code> as well as
<code>dqcs_plugin_run()</code>.</li>
</ul>
<details><summary><font color="green"><tt>dqcs_plugin_start()</tt></font><div style="margin-left: 16px">
<p>Executes a plugin in a worker thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_plugin_start(
    dqcs_handle_t pdef,
    const char *simulator
)
</code></pre>
<p>This function behaves the same as dqcs_plugin_log(), but is asynchronous;
it always returns immediately. Of course, this means that the callbacks in
<code>pdef</code> will be called from a different thread.</p>
<p>To wait for the thread to finish executing, call <code>dqcs_plugin_wait()</code> on
the returned join handle. Alternatively you can delete the join handle
object, which will detach the thread.</p>
<p>Note that <code>dqcs_log_*()</code> will only be available in the thread that the
plugin actually runs in.</p>
<p>This function returns 0 to indicate failure to start the plugin. Otherwise,
the join handle is returned.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_wait()</tt></font><div style="margin-left: 16px">
<p>Waits for a plugin worker thread to finish executing.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_plugin_wait(dqcs_handle_t pjoin)
</code></pre>
<p>Unless the join handle is invalid, this function returns success/failure
based on the result of the plugin execution. If the plugin thread is
joined, the join handle is deleted.</p>
</div></details>
<h1><a class="header" href="#interacting-with-dqcsim" id="interacting-with-dqcsim">Interacting with DQCsim</a></h1>
<p>When you start a plugin with <code>dqcs_plugin_run()</code> or <code>dqcs_plugin_start()</code>,
DQCsim will start calling the callbacks you provided. Each of these callbacks
takes a <code>dqcs_plugin_state_t</code> handle, which can be used to interact with
DQCsim and the downstream plugin(s) using the functions listed in this section.</p>
<h2><a class="header" href="#frontend-to-host-communication" id="frontend-to-host-communication">Frontend to host communication</a></h2>
<p>Within a frontend's <code>run</code> callback, the following two functions can be used to
send and receive <code>ArbData</code> messages to and from the host.</p>
<details><summary><font color="green"><tt>dqcs_plugin_send()</tt></font><div style="margin-left: 16px">
<p>Sends a message to the host.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_plugin_send(
    dqcs_plugin_state_t plugin,
    dqcs_handle_t arb
)
</code></pre>
<p>It is only legal to call this function from within the <code>run()</code> callback.
Any other source will result in an error.</p>
<p>The <code>cmd</code> handle is consumed by this function if and only if it succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_recv()</tt></font><div style="margin-left: 16px">
<p>Waits for a message from the host.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_plugin_recv(dqcs_plugin_state_t plugin)
</code></pre>
<p>It is only legal to call this function from within the <code>run()</code> callback.
Any other source will result in an error.</p>
<p>When successful, this function returns a new handle to the received
<code>ArbData</code> object. 0 is used to indicate that an error occurred.</p>
</div></details>
<p>The send function always returns immediately, but the receive function may
block to return control to the host if no messages were in the buffer. That
means that the latter can call into a different callback, such as <code>host_arb</code>.</p>
<h2><a class="header" href="#upstream-to-downstream-communication" id="upstream-to-downstream-communication">Upstream to downstream communication</a></h2>
<p>The following functions can be used by upstream plugins (frontends and
operators) to perform an operation on the downstream plugin. They correspond
one-to-one with the downstream callbacks.</p>
<details><summary><font color="green"><tt>dqcs_plugin_allocate()</tt></font><div style="margin-left: 16px">
<p>Allocate the given number of downstream qubits.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_plugin_allocate(
    dqcs_plugin_state_t plugin,
    uintptr_t num_qubits,
    dqcs_handle_t cq
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p><code>num_qubits</code> specifies the number of qubits that are to be allocated.</p>
<p><code>commands</code> must be 0 or a valid handle to an <code>ArbCmd</code> queue, containing a
list of commands that may be used to modify the behavior of the qubit
register; 0 is equivalent to zero commands. The queue is consumed by this
function, i.e. the handle becomes invalid, if and only if it succeeds.</p>
<p>If the function is successful, a new handle to the set of qubit references
representing the newly allocated register is returned. When the function
fails, 0 is returned.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_free()</tt></font><div style="margin-left: 16px">
<p>Free the given downstream qubits.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_plugin_free(
    dqcs_plugin_state_t plugin,
    dqcs_handle_t qbset
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p><code>qubits</code> must be a valid set of qubit references. The set is consumed by
this function, i.e. the handle becomes invalid, if and only if it succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_gate()</tt></font><div style="margin-left: 16px">
<p>Tells the downstream plugin to execute a gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_plugin_gate(
    dqcs_plugin_state_t plugin,
    dqcs_handle_t gate
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p><code>gate</code> must be a valid gate object. The object is consumed by this
function, i.e. the handle becomes invalid, if and only if it succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_advance()</tt></font><div style="margin-left: 16px">
<p>Tells the downstream plugin to run for the specified number of cycles.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_cycle_t dqcs_plugin_advance(
    dqcs_plugin_state_t plugin,
    dqcs_cycle_t cycles
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p>The return value is the new cycle counter. This function uses -1 to signal
an error.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_arb()</tt></font><div style="margin-left: 16px">
<p>Sends an arbitrary command downstream.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_plugin_arb(
    dqcs_plugin_state_t plugin,
    dqcs_handle_t cmd
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p>This function returns a new handle to an <code>ArbData</code> object representing the
return value of the <code>ArbCmd</code> when successful. Otherwise, it returns 0.</p>
</div></details>
<p>For performance reasons, all of the above functions except <code>dqcs_plugin_arb()</code>
are asynchronous. They send the associated request immediately, but it is down
to OS thread/process scheduling when the request is actually executed. This
means the following:</p>
<ul>
<li>The ordering of log messages sent by differing plugins depends on OS
scheduling.</li>
<li>Errors caused by these asynchronous functions cannot be propagated upstream.
Therefore, any error that <code>does</code> occur is necessarily fatal.</li>
</ul>
<p><code>dqcs_plugin_arb()</code> is exempt from this since it returns a value, so <code>ArbCmd</code>
errors are not necessarily fatal.</p>
<h2><a class="header" href="#querying-the-state-of-the-downstream-plugin" id="querying-the-state-of-the-downstream-plugin">Querying the state of the downstream plugin</a></h2>
<p>Measurement results requested through measurement gates need to be explicitly
fetched when they are needed through the following function. It always returns
the result of the most recent measurement gate for a specific qubit.</p>
<details><summary><font color="green"><tt>dqcs_plugin_get_measurement()</tt></font><div style="margin-left: 16px">
<p>Returns the latest measurement of the given downstream qubit.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_plugin_get_measurement(
    dqcs_plugin_state_t plugin,
    dqcs_qubit_t qubit
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p>If the function succeeds, it returns a new handle to a qubit measurement
result object. Otherwise it returns 0.</p>
</div></details>
<p>DQCsim also records some timing information whenever a measurement is
performed. This may be useful for calculating fidelity information within an
algorithm running in the presence of errors.</p>
<details><summary><font color="green"><tt>dqcs_plugin_get_cycles_since_measure()</tt></font><div style="margin-left: 16px">
<p>Returns the number of downstream cycles since the latest measurement of the
given downstream qubit.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_cycle_t dqcs_plugin_get_cycles_since_measure(
    dqcs_plugin_state_t plugin,
    dqcs_qubit_t qubit
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p>This function uses -1 to signal an error.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_get_cycles_between_measures()</tt></font><div style="margin-left: 16px">
<p>Returns the number of downstream cycles between the last two measurements
of the given downstream qubit.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_cycle_t dqcs_plugin_get_cycles_between_measures(
    dqcs_plugin_state_t plugin,
    dqcs_qubit_t qubit
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p>This function uses -1 to signal an error.</p>
</div></details>
<p>Finally, a simulation cycle counter is maintained. This is just an accumulation
of all the <code>dqcs_plugin_advance()</code> calls since the start of the simulation.</p>
<details><summary><font color="green"><tt>dqcs_plugin_get_cycle()</tt></font><div style="margin-left: 16px">
<p>Returns the current value of the downstream cycle counter.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_cycle_t dqcs_plugin_get_cycle(dqcs_plugin_state_t plugin)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p>This function uses -1 to signal an error.</p>
</div></details>
<h2><a class="header" href="#random-number-generation" id="random-number-generation">Random number generation</a></h2>
<p>To ensure that a DQCsim simulation can be deterministically reproduced, it is
strongly recommended to use the following random number generation functions.</p>
<details><summary><font color="green"><tt>dqcs_plugin_random_f64()</tt></font><div style="margin-left: 16px">
<p>Generates a random floating point number using the simulator random seed.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">double dqcs_plugin_random_f64(dqcs_plugin_state_t plugin)
</code></pre>
<p>The generated numbers are uniformly distributed in the range <code>[0,1&gt;</code>.</p>
<p>This function only fails if the <code>plugin</code> handle is invalid, in which case
it returns 0. Of course, 0 is also a valid (if rare) random return value.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_random_u64()</tt></font><div style="margin-left: 16px">
<p>Generates a random unsigned 64-bit number using the simulator random seed.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_plugin_random_u64(dqcs_plugin_state_t plugin)
</code></pre>
<p>This function only fails if the <code>plugin</code> handle is invalid, in which case
it returns 0. Of course, 0 is also a valid (if rare) random return value.</p>
</div></details>
<p>Particularly, these generators use a separate PRNG stream depending on whether
the callback they are executed from is synchronous to the upstream channel
(<code>modify_measurement</code>) or the downstream channel (all other callbacks). This is
important, because the ordering of upstream callbacks with respect to
downstream callbacks is dependent on OS scheduling.</p>
<p>If you only use downstream callbacks, it's also fine to seed your own PRNG
using the first number returned by <code>dqcs_plugin_random_u64()</code> in the <code>init</code>
callback. However, using a randomly seeded PRNG is strongly discouraged, since
it prevents a user from using a fixed random seed for reproduction.</p>
<h1><a class="header" href="#logging-1" id="logging-1">Logging</a></h1>
<p>DQCsim provides a centralized logging interface for plugins. This ensures that
log messages are processed in a consistent way among different plugins. It also
makes sure that messages don't print &quot;through&quot; each other, as they would when
stdout/stderr were used directly (these are not thread-safe).</p>
<p>The logging interface is only available from within threads that are hosting a
plugin (or the main thread of a plugin process) and the thread which started
the simulation.</p>
<h2><a class="header" href="#log-levels" id="log-levels">Log levels</a></h2>
<p>Every message has a severity level associated with it. These severities should
be interpreted as follows:</p>
<ul>
<li><code>trace</code> is intended for reporting debugging information useful for debugging
the internals of the originating plugin, but not necessarily for debugging
the plugins around it. Such messages would normally only be generated by
debug builds, to prevent them from impacting performance under normal
circumstances.</li>
<li><code>debug</code> is intended for reporting debugging information which may also be
useful when debugging the plugins around it, such as the arguments with
which a public API function was called.</li>
<li><code>info</code> is intended for reporting information that was <em>not</em> explicitly
requested by the user, such as a plugin starting up or shutting down.</li>
<li><code>note</code> is intended for reporting information that <em>was</em> explicitly requested
by the user/API caller, such as the result of an API function requested
through the command line, or an explicitly captured stdout/stderr stream. It
may also be used for reporting events that the user may not be expecting,
but are not exceptional enough to warrent issuing a warning.</li>
<li><code>warn</code> is intended for reporting that a third party did something
unexpected, but that an attempt will be made to work around the problem,
such as a failed connection attempt that we're going to retry.</li>
<li><code>error</code> is intended for reporting or propagating a non-fatal error, such as
a third party requesting usage of an unimplemented function.</li>
<li><code>fatal</code> is intended for reporting fatal errors, such as a third party
reporting an error for something that we really needed.</li>
</ul>
<h2><a class="header" href="#sending-log-messages" id="sending-log-messages">Sending log messages</a></h2>
<p>The preferred way for C programs to submit log messages is through the
following macros. These automatically add information such as line number and
source filename through the C preprocessor. They also fall back to writing to
<code>stderr</code> if logging fails for some reason. Their interface is just like
<code>printf</code>, but the final newline is implicit.</p>
<details><summary><font color="green"><tt>dqcs_log_trace()</tt></font><div style="margin-left: 16px">
<p>Convenience macro for calling <code>dqcs_log_format()</code> with trace loglevel and
automatically determined function name, filename, and line number.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">#define dqcs_log_trace(fmt, ...)          \
  dqcs_log_format(                        \
    DQCS_LOGLEVEL_PREFIX DQCS_LOG_TRACE,  \
    DQCS_LANGUAGE,                        \
    __FILE__,                             \
    __LINE__,                             \
    fmt,                                  \
    ##__VA_ARGS__                         \
  )
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_debug()</tt></font><div style="margin-left: 16px">
<p>Convenience macro for calling <code>dqcs_log_format()</code> with debug loglevel and
automatically determined function name, filename, and line number.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">#define dqcs_log_debug(fmt, ...)          \
  dqcs_log_format(                        \
    DQCS_LOGLEVEL_PREFIX DQCS_LOG_DEBUG,  \
    DQCS_LANGUAGE,                        \
    __FILE__,                             \
    __LINE__,                             \
    fmt,                                  \
    ##__VA_ARGS__                         \
  )
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_info()</tt></font><div style="margin-left: 16px">
<p>Convenience macro for calling <code>dqcs_log_format()</code> with info loglevel and
automatically determined function name, filename, and line number.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">#define dqcs_log_info(fmt, ...)           \
  dqcs_log_format(                        \
    DQCS_LOGLEVEL_PREFIX DQCS_LOG_INFO,   \
    DQCS_LANGUAGE,                        \
    __FILE__,                             \
    __LINE__,                             \
    fmt,                                  \
    ##__VA_ARGS__                         \
  )
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_note()</tt></font><div style="margin-left: 16px">
<p>Convenience macro for calling <code>dqcs_log_format()</code> with note loglevel and
automatically determined function name, filename, and line number.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">#define dqcs_log_note(fmt, ...)           \
  dqcs_log_format(                        \
    DQCS_LOGLEVEL_PREFIX DQCS_LOG_NOTE,   \
    DQCS_LANGUAGE,                        \
    __FILE__,                             \
    __LINE__,                             \
    fmt,                                  \
    ##__VA_ARGS__                         \
  )
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_warn()</tt></font><div style="margin-left: 16px">
<p>Convenience macro for calling <code>dqcs_log_format()</code> with warn loglevel and
automatically determined function name, filename, and line number.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">#define dqcs_log_warn(fmt, ...)           \
  dqcs_log_format(                        \
    DQCS_LOGLEVEL_PREFIX DQCS_LOG_WARN,   \
    DQCS_LANGUAGE,                        \
    __FILE__,                             \
    __LINE__,                             \
    fmt,                                  \
    ##__VA_ARGS__                         \
  )
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_error()</tt></font><div style="margin-left: 16px">
<p>Convenience macro for calling <code>dqcs_log_format()</code> with error loglevel and
automatically determined function name, filename, and line number.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">#define dqcs_log_error(fmt, ...)          \
  dqcs_log_format(                        \
    DQCS_LOGLEVEL_PREFIX DQCS_LOG_ERROR,  \
    DQCS_LANGUAGE,                        \
    __FILE__,                             \
    __LINE__,                             \
    fmt,                                  \
    ##__VA_ARGS__                         \
  )
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_fatal()</tt></font><div style="margin-left: 16px">
<p>Convenience macro for calling <code>dqcs_log_format()</code> with fatal loglevel and
automatically determined function name, filename, and line number.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">#define dqcs_log_fatal(fmt, ...)          \
  dqcs_log_format(                        \
    DQCS_LOGLEVEL_PREFIX DQCS_LOG_FATAL,  \
    DQCS_LANGUAGE,                        \
    __FILE__,                             \
    __LINE__,                             \
    fmt,                                  \
    ##__VA_ARGS__                         \
  )
</code></pre>
</div></details>
<p>To get more control over the metadata or to set the loglevel programmatically,
you can use the following function.</p>
<details><summary><font color="green"><tt>dqcs_log_format()</tt></font><div style="margin-left: 16px">
<p>Sends a log message using the current logger using printf-like formatting.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">void dqcs_log_format(
    dqcs_loglevel_t level,
    const char *module,
    const char *file,
    uint32_t line,
    const char *fmt,
    ...
)
</code></pre>
<p>This function is identical to <code>dqcs_log_raw()</code>, except instead of a single
string it takes a printf-like format string and varargs to compose the
message.</p>
</div></details>
<p>The above macros and functions ultimately call <code>dqcs_log_raw()</code>. This function
does not fall back to <code>stderr</code> if logging fails, and does not support
<code>printf</code>-style format strings. The latter may be useful for interfacing with
languages that don't support calling variadic functions.</p>
<details><summary><font color="green"><tt>dqcs_log_raw()</tt></font><div style="margin-left: 16px">
<p>Primitive API for sending a log message using the current logger.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_log_raw(
    dqcs_loglevel_t level,
    const char *module,
    const char *file,
    uint32_t line_nr,
    const char *message
)
</code></pre>
<p>Returns <code>DQCS_SUCCESS</code> if logging was successful, or <code>DQCS_FAILURE</code> if no
logger is available in the current thread or one of the arguments could not
be converted. Loggers are available in the simulation host thread and in
threads running plugins.</p>
<h2><a class="header" href="#formatting-and-fallback-to-stderr" id="formatting-and-fallback-to-stderr">Formatting and fallback to stderr</a></h2>
<p>As an alternative to this function, you can also use <code>dqcs_log_format()</code>.
This function differs from <code>dqcs_log_raw()</code> in two ways:</p>
<ul>
<li>Instead of the <code>message</code> string, a printf-style format string and
associated varargs are passed to construct the message.</li>
<li>When logging fails, this function falls back to writing to <code>stderr</code>
instead of returning the errors.</li>
</ul>
<h2><a class="header" href="#macros" id="macros">Macros</a></h2>
<p>From C and C++, these functions are normally not called directly. Instead,
the following macros are used:</p>
<pre><code class="language-C">dqcs_log_trace(&quot;trace message!&quot;);
dqcs_log_debug(&quot;debug message!&quot;);
dqcs_log_info(&quot;info message!&quot;);
dqcs_log_note(&quot;notice!&quot;);
dqcs_log_warn(&quot;warning!&quot;);
dqcs_log_error(&quot;error!&quot;);
dqcs_log_fatal(&quot;fatal error!&quot;);
</code></pre>
<p>These macros automatically set <code>file</code> to the C source filename and <code>line</code>
to the line number. <code>module</code> is hardcoded to &quot;C&quot; or &quot;CPP&quot; depending on
source file language. They use <code>dqcs_log_format()</code>, so they also support
printf-style formatting. For instance:</p>
<pre><code class="language-C">dqcs_note(&quot;answer to %s: %d&quot;, &quot;ultimate question&quot;, 42);
</code></pre>
</div></details>
<h2><a class="header" href="#stdout-and-stderr" id="stdout-and-stderr">stdout and stderr</a></h2>
<p>By default, DQCsim will capture the stdout and stderr streams of the plugin
processes it launches. Each received line will simply be turned into a log
message. This is particularly useful for logging problems related to
connecting to DQCsim.</p>
<h1><a class="header" href="#simulations" id="simulations">Simulations</a></h1>
<p>The easiest way to start a simulation is to use the
<a href="c-api/../cli/index.html">command line interface</a>. However, it is also possible to
launch simulations programmatically through DQCsim's host interface. Besides
letting you start simulations without needing to fork a new process, this
interface also allows you to interact with the frontend through a message
queue, send <code>ArbCmd</code>s to any plugin, and capture log messages.</p>
<h2><a class="header" href="#contents-7" id="contents-7">Contents</a></h2>
<ul>
<li><a href="c-api/pcfg.apigen.html">Configuring plugins</a></li>
<li><a href="c-api/tcfg.apigen.html">Running local plugins</a></li>
<li><a href="c-api/scfg.apigen.html">Configuring a simulation</a></li>
<li><a href="c-api/sim-run.apigen.html">Running a simulation</a></li>
</ul>
<h1><a class="header" href="#configuring-plugins" id="configuring-plugins">Configuring plugins</a></h1>
<p>Before we can build a simulation, we need to configure the individual plugins
that make up the simulation. This is usually done using a plugin process
configuration (<code>pcfg</code>).</p>
<h2><a class="header" href="#constructing-a-plugin-process-configuration" id="constructing-a-plugin-process-configuration">Constructing a plugin process configuration</a></h2>
<p>There are two ways to construct the configuration. <code>dqcs_pcfg_new()</code> is the
easy one: it will look for the plugin executable in the same way that the
command-line interface does it. It works using a single string, which can be:</p>
<ul>
<li>a valid path to the plugin executable;</li>
<li>the basename of the plugin executable with implicit <code>dqcsfe</code>/<code>dqcsop</code>/<code>dqcsbe</code>
prefix, searched for in A) the current working directory, B) the directory
that the binary for the current process resides in, and C) the system
<code>$PATH</code> (in that order);</li>
<li>a valid path to a script file with a file extension. In this case, the above
rule is run for a plugin named by the file extension of the script file. For
instance, if <code>test.py</code> is specified for a frontend plugin, DQCsim will look
for an executable named <code>dqcsfepy</code>. The script filename is passed to the
plugin through the first command-line argument, moving the simulator
endpoint string to the second slot.</li>
</ul>
<p>Alternatively, you can bypass this algorithm by specifying the full path to the
plugin and (optionally) the script file directly using <code>dqcs_pcfg_new_raw()</code>.</p>
<details><summary><font color="green"><tt>dqcs_pcfg_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new plugin process configuration object using sugared syntax.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_pcfg_new(
    dqcs_plugin_type_t typ,
    const char *name,
    const char *spec
)
</code></pre>
<p><code>typ</code> specifies the type of plugin. <code>name</code> specifies the name used to refer
to the plugin later, which much be unique within a simulation; if it is
empty or <code>NULL</code>, auto-naming will be performed: &quot;front&quot; for the frontend,
&quot;oper&lt;i&gt;&quot; for the operators (indices starting at 1 from frontend to
backend), and &quot;back&quot; for the backend. <code>spec</code> specifies which plugin to use,
using the same syntax that the <code>dqcsim</code> command line interface uses.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_new_raw()</tt></font><div style="margin-left: 16px">
<p>Creates a new plugin process configuration object using raw paths.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_pcfg_new_raw(
    dqcs_plugin_type_t typ,
    const char *name,
    const char *executable,
    const char *script
)
</code></pre>
<p>This works the same as <code>dqcs_pcfg_new()</code>, but instead of the sugared,
command-line style specification you have to specify the path to the plugin
executable and (if applicable) the script it must execute directly. This is
useful when you have a specific executable in mind and you don't want the
somewhat heuristic desugaring algorithm from doing something unexpected.</p>
<p>Pass <code>NULL</code> or an empty string to <code>script</code> to specify a native plugin
executable that does not take a script argument.</p>
</div></details>
<p>After construction, the plugin type, name, executable path, and optional script
path become immutable. However, their values can be queried using the following
functions.</p>
<details><summary><font color="green"><tt>dqcs_pcfg_type()</tt></font><div style="margin-left: 16px">
<p>Returns the type of the given plugin process configuration.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_plugin_type_t dqcs_pcfg_type(dqcs_handle_t pcfg)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_name()</tt></font><div style="margin-left: 16px">
<p>Returns the configured name for the given plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_pcfg_name(dqcs_handle_t pcfg)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
name. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_executable()</tt></font><div style="margin-left: 16px">
<p>Returns the configured executable path for the given plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_pcfg_executable(dqcs_handle_t pcfg)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
executable path. Free it with <code>free()</code> when you're done with it to avoid
memory leaks.</strong> On failure (i.e., the handle is invalid) this returns
<code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_script()</tt></font><div style="margin-left: 16px">
<p>Returns the configured script path for the given plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_pcfg_script(dqcs_handle_t pcfg)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
script path. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>. An
empty string will be returned if no script is configured to distinguish it
from failure.</p>
</div></details>
<h2><a class="header" href="#functional-configuration" id="functional-configuration">Functional configuration</a></h2>
<p>A plugin's behavior can be augmented using a list of <code>ArbCmd</code>s passed to its
initialization callback and through environment variables. These can be set
using the following functions.</p>
<details><summary><font color="green"><tt>dqcs_pcfg_init_cmd()</tt></font><div style="margin-left: 16px">
<p>Appends an <code>ArbCmd</code> to the list of initialization commands of a plugin
process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_init_cmd(
    dqcs_handle_t pcfg,
    dqcs_handle_t cmd
)
</code></pre>
<p>The <code>ArbCmd</code> handle is consumed by this function, and is thus invalidated,
if and only if it is successful.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_env_set()</tt></font><div style="margin-left: 16px">
<p>Overrides an environment variable for the plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_env_set(
    dqcs_handle_t pcfg,
    const char *key,
    const char *value
)
</code></pre>
<p>The environment variable <code>key</code> is set to <code>value</code> regardless of whether it
exists in the parent environment variable scope.</p>
<p>If value is <code>NULL</code>, the environment variable <code>key</code> is unset instead.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_env_unset()</tt></font><div style="margin-left: 16px">
<p>Removes/unsets an environment variable for the plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_env_unset(
    dqcs_handle_t pcfg,
    const char *key
)
</code></pre>
<p>The environment variable <code>key</code> is unset regardless of whether it exists in
the parent environment variable scope.</p>
</div></details>
<p>It's also possible to assign a different working directory to a plugin process
using the following functions.</p>
<details><summary><font color="green"><tt>dqcs_pcfg_work_set()</tt></font><div style="margin-left: 16px">
<p>Overrides the working directory for the plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_work_set(
    dqcs_handle_t pcfg,
    const char *work
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_work_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured working directory for the given plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_pcfg_work_get(dqcs_handle_t pcfg)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
working directory. Free it with <code>free()</code> when you're done with it to avoid
memory leaks.</strong> On failure (i.e., the handle is invalid) this returns
<code>NULL</code>.</p>
</div></details>
<p>These configuration parameters are recorded in reproduction files, since they
may modify the behavior of the plugin.</p>
<h2><a class="header" href="#logging-configuration" id="logging-configuration">Logging configuration</a></h2>
<p>DQCsim allows log message filtering to be performed independently for each
plugin. The following functions can be used to configure this per-plugin
filter. The verbosity defaults to trace to pass all messages through; the
messages will also be filtered by DQCsim itself.</p>
<details><summary><font color="green"><tt>dqcs_pcfg_verbosity_set()</tt></font><div style="margin-left: 16px">
<p>Configures the logging verbosity for the given plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_verbosity_set(
    dqcs_handle_t pcfg,
    dqcs_loglevel_t level
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_verbosity_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured verbosity for the given plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_loglevel_t dqcs_pcfg_verbosity_get(dqcs_handle_t pcfg)
</code></pre>
</div></details>
<p>You can also let DQCsim pipe only the messages of a specific plugin to a file.
This behavior can be configured using <code>dqcs_pcfg_tee()</code>.</p>
<details><summary><font color="green"><tt>dqcs_pcfg_tee()</tt></font><div style="margin-left: 16px">
<p>Configures a plugin process to also output its log messages to a file.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_tee(
    dqcs_handle_t pcfg,
    dqcs_loglevel_t verbosity,
    const char *filename
)
</code></pre>
<p><code>verbosity</code> configures the verbosity level for the file only.</p>
</div></details>
<p>Finally, DQCsim will by default capture the stdout and stderr streams of the
plugin process and convert each received line into a log message. The following
functions can be used to configure the loglevels used for these messages, to
disable capturing, or to void the streams altogether.</p>
<details><summary><font color="green"><tt>dqcs_pcfg_stdout_mode_set()</tt></font><div style="margin-left: 16px">
<p>Configures the capture mode for the stdout stream of the specified plugin
process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_stdout_mode_set(
    dqcs_handle_t pcfg,
    dqcs_loglevel_t level
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_stdout_mode_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured stdout capture mode for the specified plugin
process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_loglevel_t dqcs_pcfg_stdout_mode_get(dqcs_handle_t pcfg)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_stderr_mode_set()</tt></font><div style="margin-left: 16px">
<p>Configures the capture mode for the stderr stream of the specified plugin
process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_stderr_mode_set(
    dqcs_handle_t pcfg,
    dqcs_loglevel_t level
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_stderr_mode_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured stderr capture mode for the specified plugin
process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_loglevel_t dqcs_pcfg_stderr_mode_get(dqcs_handle_t pcfg)
</code></pre>
</div></details>
<h2><a class="header" href="#timeouts" id="timeouts">Timeouts</a></h2>
<p>DQCsim uses a timeout mechanism when spawning a plugin and shutting it down to
detect deadlocks due to misconfiguration. This timeout defaults to 5 seconds.
If your plugin needs more time to start up or shut down gracefully for some
reason, you can modify the timeouts using the following functions.</p>
<details><summary><font color="green"><tt>dqcs_pcfg_accept_timeout_set()</tt></font><div style="margin-left: 16px">
<p>Configures the timeout for the plugin process to connect to DQCsim.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_accept_timeout_set(
    dqcs_handle_t pcfg,
    double timeout
)
</code></pre>
<p>The default is 5 seconds, so you should normally be able to leave this
alone.</p>
<p>The time unit is seconds. Use IEEE positive infinity to specify an infinite
timeout.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_accept_timeout_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured timeout for the plugin process to connect to DQCsim.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">double dqcs_pcfg_accept_timeout_get(dqcs_handle_t pcfg)
</code></pre>
<p>The time unit is in seconds. Returns positive inifinity for an infinite
timeout. Returns -1 when the function fails.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_shutdown_timeout_set()</tt></font><div style="margin-left: 16px">
<p>Configures the timeout for the plugin process to shut down gracefully.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_shutdown_timeout_set(
    dqcs_handle_t pcfg,
    double timeout
)
</code></pre>
<p>The default is 5 seconds, so you should normally be able to leave this
alone.</p>
<p>The time unit is seconds. Use IEEE positive infinity to specify an infinite
timeout.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_shutdown_timeout_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured timeout for the plugin process to shut down
gracefully.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">double dqcs_pcfg_shutdown_timeout_get(dqcs_handle_t pcfg)
</code></pre>
<p>The time unit is in seconds. Returns positive inifinity for an infinite
timeout. Returns -1 when the function fails.</p>
</div></details>
<h1><a class="header" href="#running-local-plugins" id="running-local-plugins">Running local plugins</a></h1>
<p>Besides letting DQCsim spawn plugin processes for you, you can also let DQCsim
run a plugin within a thread, or assume full control over spawning the process
or thread. To do this, you need to use a plugin <em>thread</em> configuration object
(<code>tcfg</code>) instead of a plugin <em>process</em> configuration.</p>
<h2><a class="header" href="#running-a-plugin-within-a-thread" id="running-a-plugin-within-a-thread">Running a plugin within a thread</a></h2>
<p>This method is similar to spawning a plugin in a process. However, because
there's no process boundary, the plugin is defined within the host process, and
can access memory of the host process. This can be useful particularly when you
want to make a self-contained simulation, or want to insert a simple operator
plugin somewhere in the pipeline that you don't want to make a separate
executable for. The configuration object for this scenario is constructed using
the following function.</p>
<details><summary><font color="green"><tt>dqcs_tcfg_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new plugin thread configuration object from a plugin definition.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_tcfg_new(
    dqcs_handle_t pdef,
    const char *name
)
</code></pre>
<p>The plugin definition handle is consumed by this function.</p>
</div></details>
<h2><a class="header" href="#assuming-full-control-over-plugin-spawning" id="assuming-full-control-over-plugin-spawning">Assuming full control over plugin spawning</a></h2>
<p>This method gives you full control over spawning a plugin process or thread.
This is useful for instance if you want to encapsulate the plugin process in a
tool like <code>gdb</code> or <code>valgrind</code>. The configuration object for this method is
constructed using the following function.</p>
<details><summary><font color="green"><tt>dqcs_tcfg_new_raw()</tt></font><div style="margin-left: 16px">
<p>Creates a new plugin thread configuration object from a callback.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_tcfg_new_raw(
    dqcs_plugin_type_t plugin_type,
    const char *name,
    void (*callback)(
        void *user_data,
        const char *simulator
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>The callback is called by DQCsim from a dedicated thread when DQCsim wants
to start the plugin. The callback must then in some way spawn a plugin
process that connects to the provided simulator string. The callback should
return only when the process terminates.</p>
</div></details>
<h2><a class="header" href="#querying-plugin-thread-configuration-objects" id="querying-plugin-thread-configuration-objects">Querying plugin thread configuration objects</a></h2>
<p>Similar to plugin process configuration objects, the name and type of the
plugin are immutable after construction, but can be queried.</p>
<details><summary><font color="green"><tt>dqcs_tcfg_type()</tt></font><div style="margin-left: 16px">
<p>Returns the type of the given plugin thread configuration.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_plugin_type_t dqcs_tcfg_type(dqcs_handle_t tcfg)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_tcfg_name()</tt></font><div style="margin-left: 16px">
<p>Returns the configured name for the given plugin thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_tcfg_name(dqcs_handle_t tcfg)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
name. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<h2><a class="header" href="#functional-configuration-1" id="functional-configuration-1">Functional configuration</a></h2>
<p>Like plugin process configuration objects, it's possible to send <code>ArbCmd</code>s to
the plugin's initialization callback. However, environment variables and the
working directory of the plugin cannot be set, since they're tied to the host
process.</p>
<details><summary><font color="green"><tt>dqcs_tcfg_init_cmd()</tt></font><div style="margin-left: 16px">
<p>Appends an <code>ArbCmd</code> to the list of initialization commands of a plugin
thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_tcfg_init_cmd(
    dqcs_handle_t tcfg,
    dqcs_handle_t cmd
)
</code></pre>
<p>The <code>ArbCmd</code> handle is consumed by this function, and is thus invalidated,
if and only if it is successful.</p>
</div></details>
<h2><a class="header" href="#logging-configuration-1" id="logging-configuration-1">Logging configuration</a></h2>
<p>The logging behavior for a plugin thread can be configured with the following
functions, just like plugin processes. However, file descriptors are shared
between threads, so the plugin thread does not have a separate stdout/stderr
stream that can be captured.</p>
<details><summary><font color="green"><tt>dqcs_tcfg_verbosity_set()</tt></font><div style="margin-left: 16px">
<p>Configures the logging verbosity for the given plugin thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_tcfg_verbosity_set(
    dqcs_handle_t tcfg,
    dqcs_loglevel_t level
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_tcfg_verbosity_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured verbosity for the given plugin thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_loglevel_t dqcs_tcfg_verbosity_get(dqcs_handle_t tcfg)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_tcfg_tee()</tt></font><div style="margin-left: 16px">
<p>Configures a plugin thread to also output its log messages to a file.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_tcfg_tee(
    dqcs_handle_t tcfg,
    dqcs_loglevel_t verbosity,
    const char *filename
)
</code></pre>
<p><code>verbosity</code> configures the verbosity level for the file only.</p>
</div></details>
<h1><a class="header" href="#configuring-a-simulation" id="configuring-a-simulation">Configuring a simulation</a></h1>
<p>Once you've constructed the plugin configuration objects for your simulation,
you can start putting them together in a simulation configuration object
(<code>scfg</code>).</p>
<h2><a class="header" href="#constructing-a-simulation-configuration" id="constructing-a-simulation-configuration">Constructing a simulation configuration</a></h2>
<p>A basic simulation with a frontend and a backend can be constructed as follows.</p>
<pre><code class="language-C">dqcs_handle_t frontend_pcfg = ...;
dqcs_handle_t backend_pcfg = ...;
dqcs_handle_t scfg = dqcs_scfg_new();
dqcs_scfg_push_plugin(scfg, frontend_pcfg);
dqcs_scfg_push_plugin(scfg, backend_pcfg);
</code></pre>
<p>The order in which you push plugins doesn't matter, except for operators, which
must be pushed in downstream order.</p>
<details><summary><font color="green"><tt>dqcs_scfg_new()</tt></font><div style="margin-left: 16px">
<p>Constructs an empty simulation configuration.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_scfg_new(void)
</code></pre>
<p>Before the configuration can be used, at least a frontend and a backend
plugin configuration must be pushed into it. This can be done with
<code>dqcs_scfg_push_plugin()</code>. Failing to do this will result in an error when
you try to start the simulation.</p>
<p>The default settings correspond to the defaults of the <code>dqcsim</code> command
line interface. Refer to its help for more information.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_push_plugin()</tt></font><div style="margin-left: 16px">
<p>Appends a plugin to a simulation configuration.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_push_plugin(
    dqcs_handle_t scfg,
    dqcs_handle_t xcfg
)
</code></pre>
<p>Both plugin process and plugin thread configuration objects may be used.
The handle is consumed by this function, and is thus invalidated, if and
only if it is successful.</p>
<p>Frontend and backend plugins will automatically be inserted at the front
and back of the pipeline when the simulation is created. Operators are
inserted in front to back order. This function does not provide safeguards
against multiple frontends/backends; such errors will only be reported when
the simulation is started.</p>
<p>Note that it is not possible to observe or mutate a plugin configuration
once it has been added to a simulator configuration handle. If you want to
do this for some reason, you should maintain your own data structures, and
only build the DQCsim structures from them when you're done.</p>
</div></details>
<h2><a class="header" href="#random-seed-1" id="random-seed-1">Random seed</a></h2>
<p>The random seed can be set and queried using the functions below. The default
seed is generated using a hash of the most accurate system timestamp available.</p>
<details><summary><font color="green"><tt>dqcs_scfg_seed_set()</tt></font><div style="margin-left: 16px">
<p>Configures the random seed that the simulation should use.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_seed_set(
    dqcs_handle_t scfg,
    uint64_t seed
)
</code></pre>
<p>Note that the seed is randomized by default.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_seed_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured random seed.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">uint64_t dqcs_scfg_seed_get(dqcs_handle_t scfg)
</code></pre>
<p>This function will return 0 when it fails, but this can unfortunately not
be reliably distinguished from a seed that was set to 0.</p>
</div></details>
<h2><a class="header" href="#reproduction" id="reproduction">Reproduction</a></h2>
<p>DQCsim can output a reproduction file for the simulation when the simulation is
complete. The recording logic for this system is on by default, since it is
recommended to always output such a file. After all, you never know when
something unexpected that you might want to reproduce might happen!</p>
<p>By default, the generated reproduction file will specify the plugin executable
and script paths as they were generated or specified. However, depending on how
you intend to reproduce the simulation later, you may want purely relative or
purely absolute paths instead. This can be configured using the following
functions.</p>
<details><summary><font color="green"><tt>dqcs_scfg_repro_path_style_set()</tt></font><div style="margin-left: 16px">
<p>Sets the path style used when writing reproduction files.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_repro_path_style_set(
    dqcs_handle_t scfg,
    dqcs_path_style_t path_style
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_repro_path_style_get()</tt></font><div style="margin-left: 16px">
<p>Returns the path style used when writing reproduction files.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_path_style_t dqcs_scfg_repro_path_style_get(dqcs_handle_t scfg)
</code></pre>
</div></details>
<p>It is also possible to disable the reproduction system. The only benefit this
has is to supress the warning message that's generated when a simulation cannot
be reproduced, which is the case when plugin threads are used.</p>
<details><summary><font color="green"><tt>dqcs_scfg_repro_disable()</tt></font><div style="margin-left: 16px">
<p>Disables the reproduction logging system.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_repro_disable(dqcs_handle_t scfg)
</code></pre>
<p>Calling this will disable the warnings printed when a simulation that
cannot be reproduced is constructed.</p>
</div></details>
<h2><a class="header" href="#logging-configuration-2" id="logging-configuration-2">Logging configuration</a></h2>
<p>DQCsim has two main log message verbosity filters. The first is configured
using <code>dqcs_scfg_dqcsim_verbosity_*()</code>. It controls the filtering of messages
generated by the simulation management code, as opposed to the messages
received from the various plugins. Like the plugin-specific filters, this
defaults to passing all messages through.</p>
<details><summary><font color="green"><tt>dqcs_scfg_dqcsim_verbosity_set()</tt></font><div style="margin-left: 16px">
<p>Configures the logging verbosity for DQCsim's own messages.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_dqcsim_verbosity_set(
    dqcs_handle_t scfg,
    dqcs_loglevel_t level
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_dqcsim_verbosity_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured verbosity for DQCsim's own messages.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_loglevel_t dqcs_scfg_dqcsim_verbosity_get(dqcs_handle_t scfg)
</code></pre>
</div></details>
<p>The second filter controls the minimum verbosity that a message must have for
it to be written to stderr. This filter defaults to info.</p>
<details><summary><font color="green"><tt>dqcs_scfg_stderr_verbosity_set()</tt></font><div style="margin-left: 16px">
<p>Configures the stderr sink verbosity for a simulation.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_stderr_verbosity_set(
    dqcs_handle_t scfg,
    dqcs_loglevel_t level
)
</code></pre>
<p>That is, the minimum loglevel that a messages needs to have for it to be
printed to stderr.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_stderr_verbosity_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured stderr sink verbosity for a simulation.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_loglevel_t dqcs_scfg_stderr_verbosity_get(dqcs_handle_t scfg)
</code></pre>
<p>That is, the minimum loglevel that a messages needs to have for it to be
printed to stderr.</p>
</div></details>
<p>It's also possible to have DQCsim pipe all the log messages it receives to a
file, optionally with its own verbosity filter. This is configured using
<code>dqcs_scfg_tee()</code>.</p>
<details><summary><font color="green"><tt>dqcs_scfg_tee()</tt></font><div style="margin-left: 16px">
<p>Configures DQCsim to also output its log messages to a file.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_tee(
    dqcs_handle_t scfg,
    dqcs_loglevel_t verbosity,
    const char *filename
)
</code></pre>
<p><code>verbosity</code> configures the verbosity level for the file only.</p>
</div></details>
<p>Finally, you can have DQCsim call a callback function whenever it receives a
log message. This can be used to tie DQCsim's logging system into whatever
different logging system that the host process uses.</p>
<details><summary><font color="green"><tt>dqcs_scfg_log_callback()</tt></font><div style="margin-left: 16px">
<p>Configures DQCsim to also output its log messages to callback function.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_log_callback(
    dqcs_handle_t scfg,
    dqcs_loglevel_t verbosity,
    void (*callback)(
        void *user_data,
        const char *message,
        const char *logger,
        dqcs_loglevel_t level,
        const char *module,
        const char *file,
        uint32_t line,
        uint64_t time_s,
        uint32_t time_ns,
        uint32_t pid,
        uint64_t tid
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p><code>verbosity</code> specifies the minimum importance of a message required for the
callback to be called.</p>
<p><code>callback</code> is the callback function to install. It is always called with
the <code>user_data</code> pointer to make calling stuff like class member functions
or closures possible. The <code>user_free</code> function, if non-null, will be called
when the callback is uninstalled in any way. If <code>callback</code> is null, any
current callback is uninstalled instead. For consistency, if <code>user_free</code> is
non-null while <code>callback</code> is null, <code>user_free</code> is called immediately, under
the assumption that the caller has allocated resources unbeknownst that the
callback it's trying to install is null.</p>
<p><strong>NOTE: both <code>callback</code> and <code>user_free</code> may be called from a thread spawned
by the simulator. Calling any API calls from the callback is therefore
undefined behavior!</strong></p>
<p>The callback takes the following arguments:</p>
<ul>
<li><code>void*</code>: user defined data.</li>
<li><code>const char*</code>: log message string, excluding metadata.</li>
<li><code>const char*</code>: name assigned to the logger that was used to produce the
message (= &quot;dqcsim&quot; or a plugin name).</li>
<li><code>dqcs_loglevel_t</code>: the verbosity level that the message was logged with.</li>
<li><code>const char*</code>: string representing the source of the log message, or
<code>NULL</code> when no source is known.</li>
<li><code>const char*</code>: string containing the filename of the source that
generated the message, or <code>NULL</code> when no source is known.</li>
<li><code>uint32_t</code>: line number within the aforementioned file, or 0 if not
known.</li>
<li><code>uint64_t</code>: Time in seconds since the Unix epoch.</li>
<li><code>uint32_t</code>: Additional time in nanoseconds since the aforementioned.</li>
<li><code>uint32_t</code>: PID of the generating process.</li>
<li><code>uint64_t</code>: TID of the generating thread.</li>
</ul>
<p>If an internal log record is particularly malformed and cannot be coerced
into the above (nul bytes in the strings, invalid timestamp, whatever) the
message is silently ignored.</p>
<p>The primary use of this callback is to pipe DQCsim's messages to an
external logging framework. When you do this, you probably also want to
call <code>dqcs_scfg_stderr_verbosity_set(handle, DQCS_LOG_OFF)</code> to prevent
DQCsim from writing the messages to stderr itself.</p>
</div></details>
<h1><a class="header" href="#running-a-simulation" id="running-a-simulation">Running a simulation</a></h1>
<p>When you've finished building a simulation configuration object, you can turn
it into a real simulation as described in this section.</p>
<h2><a class="header" href="#constructing-a-simulation" id="constructing-a-simulation">Constructing a simulation</a></h2>
<p>To run the simulation, all you have to do is pass the simulation configuration
object to <code>dqcs_sim_new()</code>. This function will return when all the plugins have
finished initializing as configured in the configuration object, and return a
handle to the simulation.</p>
<details><summary><font color="green"><tt>dqcs_sim_new()</tt></font><div style="margin-left: 16px">
<p>Constructs a DQCsim simulation.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_sim_new(dqcs_handle_t scfg)
</code></pre>
<p>The provided handle is consumed if it is a simulation configuration,
regardless of whether simulation construction succeeds.</p>
</div></details>
<p>Note that it is currently not possible to have more than one simulation handle
within a single thread at the same time. This has to do with DQCsim's log
system, which uses thread-local storage to determine where log messages should
go. If you want to run multiple simulations in parallel, you'll have to run
them from different threads.</p>
<h2><a class="header" href="#interacting-with-a-simulation" id="interacting-with-a-simulation">Interacting with a simulation</a></h2>
<p>After constructing the simulation, you have to explicitly tell the frontend
plugin to start executing a quantum algorithm. This is done using
<code>dqcs_sim_start()</code>. This function is asynchronous: the simulation request is
only sent to the frontend when a blocking function is called. To get the
result/return value of a previously started quantum algorithm, you can use
<code>dqcs_sim_stop()</code>. In fact, you <em>have</em> to do this for every call to
<code>dqcs_sim_start()</code>, and you can't have more than one quantum algorithm running
at a time within the context of a single simulation.</p>
<details><summary><font color="green"><tt>dqcs_sim_start()</tt></font><div style="margin-left: 16px">
<p>Starts a program on the simulated accelerator.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_sim_start(
    dqcs_handle_t sim,
    dqcs_handle_t data
)
</code></pre>
<p>This is an asynchronous call: nothing happens until <code>yield()</code>,
<code>recv()</code>, or <code>wait()</code> is called.</p>
<p>The <code>ArbData</code> handle is optional; if 0 is passed, an empty data object is
used. If a handle is passed, it is consumed if and only if the API call
succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_wait()</tt></font><div style="margin-left: 16px">
<p>Waits for the simulated accelerator to finish its current program.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_sim_wait(dqcs_handle_t sim)
</code></pre>
<p>When this succeeds, the return value of the accelerator's <code>run()</code>
function is returned in the form of a new handle. When it fails, 0 is
returned.</p>
<p>Deadlocks are detected and prevented by returning an error.</p>
</div></details>
<p>While a quantum algorithm is running, you can interact with it using <code>ArbData</code>
message queues. You can send and receive data to and from these queues using
the following functions. The send function is asynchronous, while the receive
function will block if no messages are available.</p>
<details><summary><font color="green"><tt>dqcs_sim_send()</tt></font><div style="margin-left: 16px">
<p>Sends a message to the simulated accelerator.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_sim_send(
    dqcs_handle_t sim,
    dqcs_handle_t data
)
</code></pre>
<p>This is an asynchronous call: nothing happens until <code>yield()</code>,
<code>recv()</code>, or <code>wait()</code> is called.</p>
<p>The <code>ArbData</code> handle is optional; if 0 is passed, an empty data object is
used. If a handle is passed, it is consumed if and only if the API call
succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_recv()</tt></font><div style="margin-left: 16px">
<p>Waits for the simulated accelerator to send a message to us.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_sim_recv(dqcs_handle_t sim)
</code></pre>
<p>When this succeeds, the received data is returned in the form of a new
handle. When it fails, 0 is returned.</p>
<p>Deadlocks are detected and prevented by returning an error.</p>
</div></details>
<p>At any time, you can force DQCsim to pass control to the frontend plugin using
the following function. This is primarily useful for debugging, when you for
instance want to see the results of a single sent message in the log message
stream without calling a blocking function that actually does something.</p>
<details><summary><font color="green"><tt>dqcs_sim_yield()</tt></font><div style="margin-left: 16px">
<p>Yields to the simulator.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_sim_yield(dqcs_handle_t sim)
</code></pre>
<p>The simulation runs until it blocks again. This is useful if you want an
immediate response to an otherwise asynchronous call through the logging
system or some communication channel outside of DQCsim's control.</p>
<p>This function silently returns immediately if no asynchronous data was
pending or if the simulator is waiting for something that has not been
sent yet.</p>
</div></details>
<p>You can also send <code>ArbCmd</code>s to plugins at any time. This corresponds to calling
the <code>host_arb</code> callback within a plugin. This is always synchronous; any
requests queued through <code>dqcs_sim_start()</code> and <code>dqcs_sim_send()</code> are processed
before the <code>ArbCmd</code>, and the function waits for the <code>ArbCmd</code> to finish
executing in order for it to return its result.</p>
<details><summary><font color="green"><tt>dqcs_sim_arb()</tt></font><div style="margin-left: 16px">
<p>Sends an <code>ArbCmd</code> message to one of the plugins, referenced by name.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_sim_arb(
    dqcs_handle_t sim,
    const char *name,
    dqcs_handle_t cmd
)
</code></pre>
<p><code>ArbCmd</code>s are executed immediately after yielding to the simulator, so
all pending asynchronous calls are flushed and executed <em>before</em> the
<code>ArbCmd</code>.</p>
<p>When this succeeds, the received data is returned in the form of a new
handle. When it fails, 0 is returned.</p>
<p>The <code>ArbCmd</code> handle is consumed if and only if the API call succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_arb_idx()</tt></font><div style="margin-left: 16px">
<p>Sends an <code>ArbCmd</code> message to one of the plugins, referenced by index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_sim_arb_idx(
    dqcs_handle_t sim,
    ssize_t index,
    dqcs_handle_t cmd
)
</code></pre>
<p>The frontend always has index 0. 1 through N are used for the operators
in front to back order (where N is the number of operators). The
backend is at index N+1.</p>
<p>Python-style negative indices are supported. That is, -1 can be used to
refer to the backend, -2 to the last operator, and so on.</p>
<p><code>ArbCmd</code>s are executed immediately after yielding to the simulator, so
all pending asynchronous calls are flushed and executed <em>before</em> the
<code>ArbCmd</code>.</p>
<p>When this succeeds, the received data is returned in the form of a new
handle. When it fails, 0 is returned.</p>
<p>The <code>ArbCmd</code> handle is consumed if and only if the API call succeeds.</p>
</div></details>
<h2><a class="header" href="#querying-plugin-information" id="querying-plugin-information">Querying plugin information</a></h2>
<p>You can query the metadata associated with the plugins that make up a
simulation using the following functions.</p>
<details><summary><font color="green"><tt>dqcs_sim_get_name()</tt></font><div style="margin-left: 16px">
<p>Queries the implementation name of a plugin, referenced by instance
name.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_sim_get_name(
    dqcs_handle_t sim,
    const char *name
)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
name. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_get_name_idx()</tt></font><div style="margin-left: 16px">
<p>Queries the implementation name of a plugin, referenced by index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_sim_get_name_idx(
    dqcs_handle_t sim,
    ssize_t index
)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
name. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_get_author()</tt></font><div style="margin-left: 16px">
<p>Queries the author of a plugin, referenced by instance name.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_sim_get_author(
    dqcs_handle_t sim,
    const char *name
)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
author. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_get_author_idx()</tt></font><div style="margin-left: 16px">
<p>Queries the author of a plugin, referenced by index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_sim_get_author_idx(
    dqcs_handle_t sim,
    ssize_t index
)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
author. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_get_version()</tt></font><div style="margin-left: 16px">
<p>Queries the version of a plugin, referenced by instance name.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_sim_get_version(
    dqcs_handle_t sim,
    const char *name
)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
version. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_get_version_idx()</tt></font><div style="margin-left: 16px">
<p>Queries the version of a plugin, referenced by index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_sim_get_version_idx(
    dqcs_handle_t sim,
    ssize_t index
)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
version. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<h2><a class="header" href="#shutting-a-simulation-down" id="shutting-a-simulation-down">Shutting a simulation down</a></h2>
<p>When you're done with a simulation, you can just use <code>dqcs_handle_delete()</code> to
shut it down. Before doing that, though, it is strongly recommended to output a
reproduction file. This file lets you reproduce the simulation exactly without
needing the host executable (or needing it to be deterministic) with just
DQCsim's command-line interface. You never know when you might need this for
debugging!</p>
<details><summary><font color="green"><tt>dqcs_sim_write_reproduction_file()</tt></font><div style="margin-left: 16px">
<p>Writes a reproduction file for the simulation so far.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_sim_write_reproduction_file(
    dqcs_handle_t sim,
    const char *filename
)
</code></pre>
</div></details>
<h1><a class="header" href="#reference-1" id="reference-1">Reference</a></h1>
<p>This chapter simply lists all API functions and types ordered by name.</p>
<details><summary><font color="green"><tt>dqcs_arb_assign()</tt></font><div style="margin-left: 16px">
<p>Copies the data from one object to another.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_assign(
    dqcs_handle_t dest,
    dqcs_handle_t src
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_cbor_get()</tt></font><div style="margin-left: 16px">
<p>Returns the JSON/CBOR object of an <code>ArbData</code> object in the form of a CBOR
object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_arb_cbor_get(
    dqcs_handle_t arb,
    void *obj,
    size_t obj_size
)
</code></pre>
<p>If the actual size of the object differs from the specified object size,
this function will copy the minimum of the actual and specified sizes
number of bytes, and return what the actual size was.</p>
<p>If the specified object size is zero, <code>obj</code> is allowed to be <code>NULL</code>. You
can use this to query the size before allocating an object.</p>
<p>This function returns -1 on failure.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_cbor_set()</tt></font><div style="margin-left: 16px">
<p>Sets the JSON/CBOR object of an <code>ArbData</code> object by means of a CBOR object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_cbor_set(
    dqcs_handle_t arb,
    const void *obj,
    size_t obj_size
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_clear()</tt></font><div style="margin-left: 16px">
<p>Clears the unstructured argument list.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_clear(dqcs_handle_t arb)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_get_raw()</tt></font><div style="margin-left: 16px">
<p>Returns the unstructured string argument at the specified index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_arb_get_raw(
    dqcs_handle_t arb,
    ssize_t index,
    void *obj,
    size_t obj_size
)
</code></pre>
<p>If the actual size of the object differs from the specified object size,
this function will copy the minimum of the actual and specified sizes
number of bytes, and return what the actual size was.</p>
<p>If the specified object size is zero, <code>obj</code> is allowed to be <code>NULL</code>. You
can use this to determine the size of the argument prior to actually
reading it, so you can allocate the right buffer size first.</p>
<p>This function returns -1 on failure.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_get_size()</tt></font><div style="margin-left: 16px">
<p>Returns the size in bytes of the unstructured string argument at the
specified index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_arb_get_size(
    dqcs_handle_t arb,
    ssize_t index
)
</code></pre>
<p>Returns -1 when the function fails.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_get_str()</tt></font><div style="margin-left: 16px">
<p>Returns the unstructured string argument at the specified index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_arb_get_str(
    dqcs_handle_t arb,
    ssize_t index
)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_insert_raw()</tt></font><div style="margin-left: 16px">
<p>Inserts an unstructured raw argument into the list at the specified
index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_insert_raw(
    dqcs_handle_t arb,
    ssize_t index,
    const void *obj,
    size_t obj_size
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_insert_str()</tt></font><div style="margin-left: 16px">
<p>Inserts an unstructured string argument into the list at the specified
index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_insert_str(
    dqcs_handle_t arb,
    ssize_t index,
    const char *s
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_json_get()</tt></font><div style="margin-left: 16px">
<p>Returns the JSON/CBOR object of an <code>ArbData</code> object in the form of a JSON
string.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_arb_json_get(dqcs_handle_t arb)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_json_set()</tt></font><div style="margin-left: 16px">
<p>Sets the JSON/CBOR object of an <code>ArbData</code> object by means of a JSON string.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_json_set(
    dqcs_handle_t arb,
    const char *json
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_len()</tt></font><div style="margin-left: 16px">
<p>Returns the number of unstructured arguments, or -1 to indicate failure.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_arb_len(dqcs_handle_t arb)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new <code>ArbData</code> object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_arb_new(void)
</code></pre>
<p>Returns the handle of the newly created <code>ArbData</code>. The <code>ArbData</code> is
initialized with JSON object <code>{}</code> and an empty binary argument list.</p>
<p><code>ArbData</code> objects support the <code>handle</code> and <code>arb</code> APIs.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_pop()</tt></font><div style="margin-left: 16px">
<p>Pops an unstructured argument from the back of the list without returning
it.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_pop(dqcs_handle_t arb)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_pop_raw()</tt></font><div style="margin-left: 16px">
<p>Pops an unstructured raw argument from the back of the list.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_arb_pop_raw(
    dqcs_handle_t arb,
    void *obj,
    size_t obj_size
)
</code></pre>
<p>If the actual size of the object differs from the specified object size,
this function will copy the minimum of the actual and specified sizes
number of bytes, and return what the actual size was.</p>
<p>If the specified object size is zero, <code>obj</code> is allowed to be <code>NULL</code>. You
can use this if you don't need the contents of the argument and just want
to delete it.</p>
<p>Since this function removes the returned element, data will be lost if the
specified size is smaller than the actual size. To avoid this, first use
<code>dqcs_arb_get_size(handle, -1)</code> to query the size.</p>
<p>This function returns -1 on failure. If this is due to a <code>NULL</code> buffer
being passed, the data that was popped is lost.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_pop_str()</tt></font><div style="margin-left: 16px">
<p>Pops an unstructured string argument from the back of the list.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_arb_pop_str(dqcs_handle_t arb)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>. If the failure is due to the
conversion from binary object to C string (i.e., embedded nulls), the
data is still popped and is thus lost.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_push_raw()</tt></font><div style="margin-left: 16px">
<p>Pushes an unstructured raw argument to the back of the list.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_push_raw(
    dqcs_handle_t arb,
    const void *obj,
    size_t obj_size
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_push_str()</tt></font><div style="margin-left: 16px">
<p>Pushes an unstructured string argument to the back of the list.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_push_str(
    dqcs_handle_t arb,
    const char *s
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_remove()</tt></font><div style="margin-left: 16px">
<p>Removes the specified unstructured string argument from the list.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_remove(
    dqcs_handle_t arb,
    ssize_t index
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_set_raw()</tt></font><div style="margin-left: 16px">
<p>Replaces the unstructured argument at the specified index with the
specified raw object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_set_raw(
    dqcs_handle_t arb,
    ssize_t index,
    const void *obj,
    size_t obj_size
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_set_str()</tt></font><div style="margin-left: 16px">
<p>Replaces the unstructured argument at the specified index with the
specified string.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_set_str(
    dqcs_handle_t arb,
    ssize_t index,
    const char *s
)
</code></pre>
</div></details>
<details><summary><font color="purple"><tt>dqcs_bool_return_t</tt></font><div style="margin-left: 16px">
<p>Return type for functions that normally return a boolean but can also fail.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_bool_return_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_BOOL_FAILURE = -1</tt></font></summary><div style="margin-left: 16px">
The function has failed. More information may be obtained through
`dqcsim_explain()`.
</div></details>
<details><summary><font color="blue"><tt>DQCS_FALSE = 0</tt></font></summary><div style="margin-left: 16px">
The function did what it was supposed to and returned false.
</div></details>
<details><summary><font color="blue"><tt>DQCS_TRUE = 1</tt></font></summary><div style="margin-left: 16px">
The function did what it was supposed to and returned true.
</div></details>
</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_cmd_iface_cmp()</tt></font><div style="margin-left: 16px">
<p>Compares the interface ID of an <code>ArbCmd</code> with the given string.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_cmd_iface_cmp(
    dqcs_handle_t cmd,
    const char *iface
)
</code></pre>
<p>Returns -1 for failure, 0 for no match, or 1 for a match.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_cmd_iface_get()</tt></font><div style="margin-left: 16px">
<p>Returns the interface ID of an <code>ArbCmd</code>.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_cmd_iface_get(dqcs_handle_t cmd)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_cmd_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new <code>ArbCmd</code> object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_cmd_new(
    const char *iface,
    const char *oper
)
</code></pre>
<p>Returns the handle of the newly created <code>ArbCmd</code>. The <code>ArbCmd</code> is
initialized with the given interface and operation IDs, JSON object <code>{}</code>,
and an empty binary argument list. Upon failure, returns 0.</p>
<p><code>ArbCmd</code> objects support the <code>handle</code>, <code>arb</code>, and <code>cmd</code> interfaces.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_cmd_oper_cmp()</tt></font><div style="margin-left: 16px">
<p>Compares the operation ID of an <code>ArbCmd</code> with the given string.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_cmd_oper_cmp(
    dqcs_handle_t cmd,
    const char *oper
)
</code></pre>
<p>Returns -1 for failure, 0 for no match, or 1 for a match.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_cmd_oper_get()</tt></font><div style="margin-left: 16px">
<p>Returns the operation ID of an <code>ArbCmd</code>.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_cmd_oper_get(dqcs_handle_t cmd)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_cq_len()</tt></font><div style="margin-left: 16px">
<p>Returns the number of <code>ArbCmd</code> objects in the given <code>ArbCmd</code> queue.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_cq_len(dqcs_handle_t cq)
</code></pre>
<p>This function returns -1 to indicate failure.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_cq_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new <code>ArbCmd</code> queue object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_cq_new(void)
</code></pre>
<p>Returns the handle of the newly created <code>ArbCmd</code> queue. The queue is
initially empty. Queues implement a &quot;first-in, first-out&quot; model.</p>
<p><code>ArbCmd</code> queue objects support the <code>handle</code>, <code>arb</code>, <code>cmd</code>, and <code>cq</code> APIs.</p>
<p>The <code>arb</code> and <code>cmd</code> APIs refer to the <code>ArbCmd</code> at the front of the queue.
Use <code>dqcs_cq_next()</code> to remove the front entry, allowing access to the next
command.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_cq_next()</tt></font><div style="margin-left: 16px">
<p>Advances an <code>ArbCmd</code> queue to the next command.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_cq_next(dqcs_handle_t cq)
</code></pre>
<p>Use the <code>dqcs_arb_*</code> and <code>dqcs_cmd_*</code> interfaces to read out the command
before calling this function.</p>
<p>To iterate over a queue in C, use the following snippit:</p>
<pre><code class="language-C">for (; dqcs_cq_len(queue) &gt; 0; dqcs_cq_next(queue)) {
    dqcs_cmd_...(queue, ...)
    dqcs_arb_...(queue, ...)
}
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_cq_push()</tt></font><div style="margin-left: 16px">
<p>Pushes an <code>ArbCmd</code> object into the given <code>ArbCmd</code> queue.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_cq_push(
    dqcs_handle_t cq,
    dqcs_handle_t cmd
)
</code></pre>
<p>This function returns -1 to indicate failure. The <code>ArbCmd</code> object specified
by <code>cmd</code> is moved into the queue. That is, the handle is consumed if and
only if the function succeeds.</p>
</div></details>
<details><summary><font color="purple"><tt>dqcs_cycle_t</tt></font><div style="margin-left: 16px">
<p>Type for a simulation cycle timestamp.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef long long dqcs_cycle_t;
</code></pre>
<p>Timestamps count upward from zero. The type is signed to allow usage of -1
for errors, and to allow numerical differences to be represented.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_error_get()</tt></font><div style="margin-left: 16px">
<p>Returns a pointer to the latest error message.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">const char *dqcs_error_get(void)
</code></pre>
<p>Call this to get extra information when another function returns a failure
code. The returned pointer is temporary and therefore should <strong>NOT</strong> be
<code>free()</code>d. It will become invalid when a new error occurs.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_error_set()</tt></font><div style="margin-left: 16px">
<p>Sets the latest error message string.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">void dqcs_error_set(const char *msg)
</code></pre>
<p>This must be called by callback functions when an error occurs within the
callback, otherwise the upstream result for <code>dqcs_error_get()</code> will be
undefined.</p>
<p>If <code>msg</code> is set to <code>NULL</code>, the error string is cleared instead.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_controls()</tt></font><div style="margin-left: 16px">
<p>Returns a handle to a new qubit reference set containing the qubits
that control this gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_controls(dqcs_handle_t gate)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_has_controls()</tt></font><div style="margin-left: 16px">
<p>Returns whether the specified gate has control qubits.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_gate_has_controls(dqcs_handle_t gate)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_has_matrix()</tt></font><div style="margin-left: 16px">
<p>Returns whether a unitary matrix is associated with this gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_gate_has_matrix(dqcs_handle_t gate)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_has_measures()</tt></font><div style="margin-left: 16px">
<p>Returns whether the specified gate measures any qubits.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_gate_has_measures(dqcs_handle_t gate)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_has_targets()</tt></font><div style="margin-left: 16px">
<p>Returns whether the specified gate has target qubits.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_gate_has_targets(dqcs_handle_t gate)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_is_custom()</tt></font><div style="margin-left: 16px">
<p>Returns whether the specified gate is a custom gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_gate_is_custom(dqcs_handle_t gate)
</code></pre>
<p>If this returns true, the type of gate is to be determined by matching its
name against a set of known gate types. If this returns false, the gate is
expected to be executed as follows, in this order:</p>
<ul>
<li>if there are target qubits, extend the supplied unitary matrix to
include the control qubits (if any), then apply it to the control +
target qubits;</li>
<li>measure each measured qubit (if any) in the Z basis.</li>
</ul>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_matrix()</tt></font><div style="margin-left: 16px">
<p>Returns a copy of the unitary matrix associated with this gate, if one
exists.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">double *dqcs_gate_matrix(dqcs_handle_t gate)
</code></pre>
<p>If this function succeeds, the matrix is returned in row-major form, using
pairs of doubles for the real vs. imaginary component of each entry. The
size will be <code>4**len(targets)</code> complex numbers = <code>2*4**len(targets)</code>
doubles = <code>16*4**len(targets)</code> bytes.</p>
<p>On success, this <strong>returns a newly allocated array containing the matrix.
Free it with <code>free()</code> when you're done with it to avoid memory leaks.</strong> On
failure, or if no matrix is associated with this gate, this returns <code>NULL</code>.
Use <code>dqcs_gate_has_matrix()</code> to disambiguate.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_matrix_len()</tt></font><div style="margin-left: 16px">
<p>Returns the size of the gate matrix associated with this gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_gate_matrix_len(dqcs_handle_t gate)
</code></pre>
<p>The size is returned in the form of the number of complex entries. That is,
the number of doubles is two times the return value, and the size in bytes
is 8 times the return value. 0 is returned when there is no matrix. -1 is
used to report errors.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_measures()</tt></font><div style="margin-left: 16px">
<p>Returns a handle to a new qubit reference set containing the qubits
measured by this gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_measures(dqcs_handle_t gate)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_name()</tt></font><div style="margin-left: 16px">
<p>Returns the name of a custom gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_gate_name(dqcs_handle_t gate)
</code></pre>
<p>This function fails if the gate is not a custom gate. Query
<code>dqcs_gate_is_custom()</code> to disambiguate between a non-custom gate and a
different error.</p>
<p>On success, this <strong>returns a newly allocated string containing the gate
name. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_new_custom()</tt></font><div style="margin-left: 16px">
<p>Constructs a new custom gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_new_custom(
    const char *name,
    dqcs_handle_t targets,
    dqcs_handle_t controls,
    dqcs_handle_t measures,
    const double *matrix,
    size_t matrix_len
)
</code></pre>
<p>The functionality of custom gates is not specified by DQCsim. Instead, this
is left up to the plugins. Of course, for this to work, plugins that are
connected to each other must agree on the format used.</p>
<p><code>name</code> specifies the name of the gate. The name is used to indicate which
custom operation is to be applied.</p>
<p><code>targets</code> optionally specifies the set of target qubits. You may pass 0 or
an empty qubit set if you don't need target qubits.</p>
<p><code>controls</code> optionally specifies the set of control qubits. You may pass 0
or an empty qubit set if you don't need control qubits.</p>
<p><code>measures</code> optionally specifies the set of measured qubits. You may pass 0
or an empty qubit set if no qubits are measured. Note that the upstream
plugin expects exactly one measurement result for each qubit specified in
this set; anything else results in a warning and the measurement result
being set to undefined.</p>
<p><code>matrix</code> can point to an appropriately sized array of doubles, or be <code>NULL</code>
if no matrix is required. If a matrix is specified, at least one target
qubit is required, and the matrix must be appropriately sized for the
number of target qubits. The matrix is specified in row-major form, using
pairs of doubles for the real vs. imaginary component of each entry. The
size must thus be <code>4**len(targets)</code> complex numbers = <code>2*4**len(targets)</code>
doubles = <code>16*4**len(targets)</code> bytes. <code>matrix_len</code> must be set to the
number of complex numbers.</p>
<p>In addition to the above data, gate objects implement the <code>arb</code> interface
to allow user-specified classical information to be attached.</p>
<p>This function returns the handle to the gate, or 0 to indicate failure.
The specified qubit sets are consumed/deleted by this function if and only
if it succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_new_measurement()</tt></font><div style="margin-left: 16px">
<p>Constructs a new measurement gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_new_measurement(dqcs_handle_t measures)
</code></pre>
<p><code>measures</code> must be a handle to a qubit set. The qubits in this set are
measured in the Z-basis. To measure in other bases, first apply the
respective rotation, or use a custom gate.</p>
<p>This function returns the handle to the gate, or 0 to indicate failure.
The <code>measures</code> qubit set is consumed/deleted by this function if and only
if it succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_new_unitary()</tt></font><div style="margin-left: 16px">
<p>Constructs a new unitary gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_new_unitary(
    dqcs_handle_t targets,
    dqcs_handle_t controls,
    const double *matrix,
    size_t matrix_len
)
</code></pre>
<p><code>targets</code> must be a handle to a non-empty qubit set. The qubits in this set
correspond with the supplied unitary matrix.</p>
<p><code>controls</code> optionally specifies a set of control qubits. You may pass 0 or
an empty qubit set if you don't need control qubits.</p>
<p><code>matrix</code> must point to an appropriately sized array of doubles,
representing the unitary matrix to be applied to the qubits in the
<code>targets</code> set. The matrix is specified in row-major form, using pairs of
doubles for the real vs. imaginary component of each entry. The size must
thus be <code>4**len(targets)</code> complex numbers = <code>2*4**len(targets)</code> doubles =
<code>16*4**len(targets)</code> bytes. <code>matrix_len</code> must be set to the number of
complex numbers.</p>
<p>The supplied matrix is only applied to the target qubits if all the control
qubits are or will be determined to be set. For instance, to encode a
CCNOT/Toffoli gate, you can specify one target qubits, two control qubits,
and [0, 1; 1, 0] (X) for the matrix. This is equivalent to extending the
matrix to the full Toffoli matrix and specifying all three qubits in the
targets set, or the midway solution using a CNOT matrix, but these
solutions may be less efficient depending on whether the simulator can
optimize its calculations for controlled gates.</p>
<p>Simulators are not required to apply the (hidden) global phase component of
the gate matrix in the same way it is specified; that is, if the simulator
can optimize its calculations by altering the global phase it is allowed
to.</p>
<p>If is up to the user to ensure that the specified matrix is unitary. This
is NOT checked by DQCsim. The simulator backend may or may not check this.</p>
<p>This function returns the handle to the gate, or 0 to indicate failure.
The <code>targets</code> qubit set and (if specified) the <code>controls</code> qubit set are
consumed/deleted by this function if and only if it succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_targets()</tt></font><div style="margin-left: 16px">
<p>Returns a handle to a new qubit reference set containing the qubits
targetted by this gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_targets(dqcs_handle_t gate)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_handle_delete()</tt></font><div style="margin-left: 16px">
<p>Destroys the object associated with a handle.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_handle_delete(dqcs_handle_t handle)
</code></pre>
<p>Returns 0 when successful, -1 otherwise.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_handle_delete_all()</tt></font><div style="margin-left: 16px">
<p>Deletes all handles for the current thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_handle_delete_all(void)
</code></pre>
<p>This can be used to clean stuff up at the end of <code>main()</code> or before an
<code>abort()</code> of some kind. If you don't clean up properly, you might get
undefined behavior or errors when DQCsim tries to do it for you.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_handle_dump()</tt></font><div style="margin-left: 16px">
<p>Returns a debug dump of the object associated with the given handle.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_handle_dump(dqcs_handle_t handle)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
description. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_handle_leak_check()</tt></font><div style="margin-left: 16px">
<p>Succeeds only if there are no live handles in the current thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_handle_leak_check(void)
</code></pre>
<p>This is intended for testing and for finding handle leaks. The error
message returned when handles remain contains dumps of the first 10
remaining handles.</p>
</div></details>
<details><summary><font color="purple"><tt>dqcs_handle_t</tt></font><div style="margin-left: 16px">
<p>Type for a handle.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef unsigned long long dqcs_handle_t;
</code></pre>
<p>Handles are like pointers into DQCsim's internal structures: all API calls
use these to refer to objects. Besides the object, they contain type
information. This type can be retrieved using <code>dqcs_handle_type()</code>.</p>
<p>Handles are always positive integers, counting upwards from 1 upon
allocation, and they are not reused even after being deleted. Thus, every
subsequent object allocation returns a handle one greater than the
previous. Note however that DQCsim may allocate objects as well without
the user specifically requesting this, so external code should generally
<em>not</em> rely on this behavior unless otherwise noted. The value zero is
reserved for invalid references or error propagation.</p>
<p>Note that the scope for handles is thread-local. That is, data referenced
by a handle cannot be shared or moved between threads.</p>
<p>The value zero is reserved for invalid references or error propagation.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_handle_type()</tt></font><div style="margin-left: 16px">
<p>Returns the type of object associated with the given handle.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_type_t dqcs_handle_type(dqcs_handle_t handle)
</code></pre>
</div></details>
<details><summary><font color="purple"><tt>dqcs_handle_type_t</tt></font><div style="margin-left: 16px">
<p>Enumeration of types that can be associated with a handle.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_handle_type_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_HTYPE_INVALID = 0</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle is invalid.
<p>This indicates one of the following:</p>
<ul>
<li>The handle value is invalid (zero or negative).</li>
<li>The handle has not been used yet.</li>
<li>The object associated with the handle was deleted.</li>
</ul>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_ARB_DATA = 100</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to an `ArbData` object.
<p>This means that the handle supports the <code>handle</code> and <code>arb</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_ARB_CMD = 101</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to an `ArbCmd` object.
<p>This means that the handle supports the <code>handle</code>, <code>arb</code>, and <code>cmd</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_ARB_CMD_QUEUE = 102</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a queue of `ArbCmd` object.
<p>This means that the handle supports the <code>handle</code>, <code>arb</code>, <code>cmd</code>, and
<code>cq</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_QUBIT_SET = 103</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a set of qubit references.
<p>This means that the handle supports the <code>handle</code> and <code>qbset</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_GATE = 104</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a quantum gate description.
<p>This means that the handle supports the <code>handle</code>, <code>gate</code>, and <code>arb</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_MEAS = 105</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a qubit measurement result.
<p>This means that the handle supports the <code>handle</code>, <code>meas</code>, and <code>arb</code>
interfaces. It can also be used in place of a qubit measurement result
set by functions that consume the object.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_MEAS_SET = 106</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a set of qubit measurement
results.
<p>This means that the handle supports the <code>handle</code> and <code>mset</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_FRONT_PROCESS_CONFIG = 200</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a frontend plugin process
configuration object.
<p>This means that the handle supports the <code>handle</code>, <code>pcfg</code>, and <code>xcfg</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_OPER_PROCESS_CONFIG = 201</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to an operator plugin process
configuration object.
<p>This means that the handle supports the <code>handle</code>, <code>pcfg</code>, and <code>xcfg</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_BACK_PROCESS_CONFIG = 203</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a backend plugin process
configuration object.
<p>This means that the handle supports the <code>handle</code>, <code>pcfg</code>, and <code>xcfg</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_FRONT_THREAD_CONFIG = 204</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a frontend plugin thread
configuration object.
<p>This means that the handle supports the <code>handle</code>, <code>tcfg</code>, and <code>xcfg</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_OPER_THREAD_CONFIG = 205</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to an operator plugin thread
configuration object.
<p>This means that the handle supports the <code>handle</code>, <code>tcfg</code>, and <code>xcfg</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_BACK_THREAD_CONFIG = 206</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a backend plugin thread
configuration object.
<p>This means that the handle supports the <code>handle</code>, <code>tcfg</code>, and <code>xcfg</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_SIM_CONFIG = 207</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a simulator configuration
object.
<p>This means that the handle supports the <code>handle</code> and <code>scfg</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_SIM = 208</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a simulator instance.
<p>This means that the handle supports the <code>handle</code> and <code>sim</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_FRONT_DEF = 300</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a frontend plugin
definition object.
<p>This means that the handle supports the <code>handle</code> and <code>pdef</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_OPER_DEF = 301</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to an operator plugin
definition object.
<p>This means that the handle supports the <code>handle</code> and <code>pdef</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_BACK_DEF = 302</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a backend plugin
definition object.
<p>This means that the handle supports the <code>handle</code> and <code>pdef</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_PLUGIN_JOIN = 303</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a plugin thread join handle.
<p>This means that the handle supports the <code>handle</code> and <code>pjoin</code>
interfaces.</p>
</div></details>
</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_debug()</tt></font><div style="margin-left: 16px">
<p>Convenience macro for calling <code>dqcs_log_format()</code> with debug loglevel and
automatically determined function name, filename, and line number.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">#define dqcs_log_debug(fmt, ...)          \
  dqcs_log_format(                        \
    DQCS_LOGLEVEL_PREFIX DQCS_LOG_DEBUG,  \
    DQCS_LANGUAGE,                        \
    __FILE__,                             \
    __LINE__,                             \
    fmt,                                  \
    ##__VA_ARGS__                         \
  )
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_error()</tt></font><div style="margin-left: 16px">
<p>Convenience macro for calling <code>dqcs_log_format()</code> with error loglevel and
automatically determined function name, filename, and line number.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">#define dqcs_log_error(fmt, ...)          \
  dqcs_log_format(                        \
    DQCS_LOGLEVEL_PREFIX DQCS_LOG_ERROR,  \
    DQCS_LANGUAGE,                        \
    __FILE__,                             \
    __LINE__,                             \
    fmt,                                  \
    ##__VA_ARGS__                         \
  )
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_fatal()</tt></font><div style="margin-left: 16px">
<p>Convenience macro for calling <code>dqcs_log_format()</code> with fatal loglevel and
automatically determined function name, filename, and line number.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">#define dqcs_log_fatal(fmt, ...)          \
  dqcs_log_format(                        \
    DQCS_LOGLEVEL_PREFIX DQCS_LOG_FATAL,  \
    DQCS_LANGUAGE,                        \
    __FILE__,                             \
    __LINE__,                             \
    fmt,                                  \
    ##__VA_ARGS__                         \
  )
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_format()</tt></font><div style="margin-left: 16px">
<p>Sends a log message using the current logger using printf-like formatting.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">void dqcs_log_format(
    dqcs_loglevel_t level,
    const char *module,
    const char *file,
    uint32_t line,
    const char *fmt,
    ...
)
</code></pre>
<p>This function is identical to <code>dqcs_log_raw()</code>, except instead of a single
string it takes a printf-like format string and varargs to compose the
message.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_info()</tt></font><div style="margin-left: 16px">
<p>Convenience macro for calling <code>dqcs_log_format()</code> with info loglevel and
automatically determined function name, filename, and line number.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">#define dqcs_log_info(fmt, ...)           \
  dqcs_log_format(                        \
    DQCS_LOGLEVEL_PREFIX DQCS_LOG_INFO,   \
    DQCS_LANGUAGE,                        \
    __FILE__,                             \
    __LINE__,                             \
    fmt,                                  \
    ##__VA_ARGS__                         \
  )
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_note()</tt></font><div style="margin-left: 16px">
<p>Convenience macro for calling <code>dqcs_log_format()</code> with note loglevel and
automatically determined function name, filename, and line number.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">#define dqcs_log_note(fmt, ...)           \
  dqcs_log_format(                        \
    DQCS_LOGLEVEL_PREFIX DQCS_LOG_NOTE,   \
    DQCS_LANGUAGE,                        \
    __FILE__,                             \
    __LINE__,                             \
    fmt,                                  \
    ##__VA_ARGS__                         \
  )
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_raw()</tt></font><div style="margin-left: 16px">
<p>Primitive API for sending a log message using the current logger.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_log_raw(
    dqcs_loglevel_t level,
    const char *module,
    const char *file,
    uint32_t line_nr,
    const char *message
)
</code></pre>
<p>Returns <code>DQCS_SUCCESS</code> if logging was successful, or <code>DQCS_FAILURE</code> if no
logger is available in the current thread or one of the arguments could not
be converted. Loggers are available in the simulation host thread and in
threads running plugins.</p>
<h2><a class="header" href="#formatting-and-fallback-to-stderr-1" id="formatting-and-fallback-to-stderr-1">Formatting and fallback to stderr</a></h2>
<p>As an alternative to this function, you can also use <code>dqcs_log_format()</code>.
This function differs from <code>dqcs_log_raw()</code> in two ways:</p>
<ul>
<li>Instead of the <code>message</code> string, a printf-style format string and
associated varargs are passed to construct the message.</li>
<li>When logging fails, this function falls back to writing to <code>stderr</code>
instead of returning the errors.</li>
</ul>
<h2><a class="header" href="#macros-1" id="macros-1">Macros</a></h2>
<p>From C and C++, these functions are normally not called directly. Instead,
the following macros are used:</p>
<pre><code class="language-C">dqcs_log_trace(&quot;trace message!&quot;);
dqcs_log_debug(&quot;debug message!&quot;);
dqcs_log_info(&quot;info message!&quot;);
dqcs_log_note(&quot;notice!&quot;);
dqcs_log_warn(&quot;warning!&quot;);
dqcs_log_error(&quot;error!&quot;);
dqcs_log_fatal(&quot;fatal error!&quot;);
</code></pre>
<p>These macros automatically set <code>file</code> to the C source filename and <code>line</code>
to the line number. <code>module</code> is hardcoded to &quot;C&quot; or &quot;CPP&quot; depending on
source file language. They use <code>dqcs_log_format()</code>, so they also support
printf-style formatting. For instance:</p>
<pre><code class="language-C">dqcs_note(&quot;answer to %s: %d&quot;, &quot;ultimate question&quot;, 42);
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_trace()</tt></font><div style="margin-left: 16px">
<p>Convenience macro for calling <code>dqcs_log_format()</code> with trace loglevel and
automatically determined function name, filename, and line number.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">#define dqcs_log_trace(fmt, ...)          \
  dqcs_log_format(                        \
    DQCS_LOGLEVEL_PREFIX DQCS_LOG_TRACE,  \
    DQCS_LANGUAGE,                        \
    __FILE__,                             \
    __LINE__,                             \
    fmt,                                  \
    ##__VA_ARGS__                         \
  )
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_warn()</tt></font><div style="margin-left: 16px">
<p>Convenience macro for calling <code>dqcs_log_format()</code> with warn loglevel and
automatically determined function name, filename, and line number.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">#define dqcs_log_warn(fmt, ...)           \
  dqcs_log_format(                        \
    DQCS_LOGLEVEL_PREFIX DQCS_LOG_WARN,   \
    DQCS_LANGUAGE,                        \
    __FILE__,                             \
    __LINE__,                             \
    fmt,                                  \
    ##__VA_ARGS__                         \
  )
</code></pre>
</div></details>
<details><summary><font color="purple"><tt>dqcs_loglevel_t</tt></font><div style="margin-left: 16px">
<p>Enumeration of loglevels and logging modes.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_loglevel_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_LOG_INVALID = -1</tt></font></summary><div style="margin-left: 16px">
Invalid loglevel. Used to indicate failure of an API that returns a
loglevel.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_OFF = 0</tt></font></summary><div style="margin-left: 16px">
Turns logging off.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_FATAL = 1</tt></font></summary><div style="margin-left: 16px">
This loglevel is to be used for reporting a fatal error, resulting from
the owner of the logger getting into an illegal state from which it
cannot recover. Such problems are also reported to the API caller via
Result::Err if applicable.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_ERROR = 2</tt></font></summary><div style="margin-left: 16px">
This loglevel is to be used for reporting or propagating a non-fatal
error caused by the API caller doing something wrong. Such problems are
also reported to the API caller via Result::Err if applicable.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_WARN = 3</tt></font></summary><div style="margin-left: 16px">
This loglevel is to be used for reporting that a called API/function is
telling us we did something wrong (that we weren't expecting), but we
can recover. For instance, for a failed connection attempt to something
that really should not be failing, we can still retry (and eventually
report critical or error if a retry counter overflows). Since we're
still trying to rectify things at this point, such problems are NOT
reported to the API/function caller via Result::Err.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_NOTE = 4</tt></font></summary><div style="margin-left: 16px">
This loglevel is to be used for reporting information specifically
requested by the user/API caller, such as the result of an API function
requested through the command line, or an explicitly captured
stdout/stderr stream.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_INFO = 5</tt></font></summary><div style="margin-left: 16px">
This loglevel is to be used for reporting information NOT specifically
requested by the user/API caller, such as a plugin starting up or
shutting down.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_DEBUG = 6</tt></font></summary><div style="margin-left: 16px">
This loglevel is to be used for reporting debugging information useful
for debugging the user of the API provided by the logged instance.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_TRACE = 7</tt></font></summary><div style="margin-left: 16px">
This loglevel is to be used for reporting debugging information useful
for debugging the internals of the logged instance. Such messages would
normally only be generated by debug builds, to prevent them from
impacting performance under normal circumstances.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_PASS = 8</tt></font></summary><div style="margin-left: 16px">
This is intended to be used when configuring the stdout/stderr capture
mode for a plugin process. Selecting it will prevent the stream from
being captured; it will just be the same stream as DQCsim's own
stdout/stderr. When used as the loglevel for a message, the message
itself is sent to stderr instead of passing into DQCsim's log system.
Using this for loglevel filters leads to undefined behavior.
</div></details>
</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_meas_new()</tt></font><div style="margin-left: 16px">
<p>Constructs a new measurement object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_meas_new(
    dqcs_qubit_t qubit,
    dqcs_measurement_t value
)
</code></pre>
<p><code>qubit</code> must be set to the qubit that was measured, <code>value</code> must be set to
its value. The return value is the handle to the measurement object, or 0
if something went wrong.</p>
<p>Note that measurement objects implement the <code>arb</code> interface, so additional
data can be attached to the object.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_meas_qubit_get()</tt></font><div style="margin-left: 16px">
<p>Returns the qubit reference associated with a measurement object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_qubit_t dqcs_meas_qubit_get(dqcs_handle_t meas)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_meas_qubit_set()</tt></font><div style="margin-left: 16px">
<p>Sets the qubit reference associated with a measurement object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_meas_qubit_set(
    dqcs_handle_t meas,
    dqcs_qubit_t qubit
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_meas_value_get()</tt></font><div style="margin-left: 16px">
<p>Returns the measurement value associated with a measurement object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_measurement_t dqcs_meas_value_get(dqcs_handle_t meas)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_meas_value_set()</tt></font><div style="margin-left: 16px">
<p>Sets the measurement value associated with a measurement object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_meas_value_set(
    dqcs_handle_t meas,
    dqcs_measurement_t value
)
</code></pre>
</div></details>
<details><summary><font color="purple"><tt>dqcs_measurement_t</tt></font><div style="margin-left: 16px">
<p>Qubit measurement value.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_measurement_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_MEAS_INVALID = -1</tt></font></summary><div style="margin-left: 16px">
Error value used to indicate that something went wrong.
</div></details>
<details><summary><font color="blue"><tt>DQCS_MEAS_ZERO = 0</tt></font></summary><div style="margin-left: 16px">
Indicates that the qubit was measured to be zero.
</div></details>
<details><summary><font color="blue"><tt>DQCS_MEAS_ONE = 1</tt></font></summary><div style="margin-left: 16px">
Indicates that the qubit was measured to be one.
</div></details>
<details><summary><font color="blue"><tt>DQCS_MEAS_UNDEFINED = 2</tt></font></summary><div style="margin-left: 16px">
Indicates that the measurement value is unknown for whatever reason.
</div></details>
</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_mset_contains()</tt></font><div style="margin-left: 16px">
<p>Returns whether the given qubit measurement set contains data for the given
qubit.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_mset_contains(
    dqcs_handle_t mset,
    dqcs_qubit_t qubit
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_mset_get()</tt></font><div style="margin-left: 16px">
<p>Returns a copy of the measurement result for the given qubit from a
measurement result set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_mset_get(
    dqcs_handle_t mset,
    dqcs_qubit_t qubit
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_mset_len()</tt></font><div style="margin-left: 16px">
<p>Returns the number of qubits measurements in the given measurement set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_mset_len(dqcs_handle_t mset)
</code></pre>
<p>This function returns -1 to indicate failure.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_mset_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new set of qubit measurement results.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_mset_new(void)
</code></pre>
<p>Returns the handle of the newly created set. The set is initially empty.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_mset_remove()</tt></font><div style="margin-left: 16px">
<p>Removes the measurement result for the given qubit from a measurement
result set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_mset_remove(
    dqcs_handle_t mset,
    dqcs_qubit_t qubit
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_mset_set()</tt></font><div style="margin-left: 16px">
<p>Adds a measurement result to a measurement result set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_mset_set(
    dqcs_handle_t mset,
    dqcs_handle_t meas
)
</code></pre>
<p>If there was already a measurement for the specified qubit, the previous
measurement result is overwritten. The measurement result object is deleted
if and only if the function succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_mset_take()</tt></font><div style="margin-left: 16px">
<p>Returns the measurement result for the given qubit from a measurement
result set and removes it from the set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_mset_take(
    dqcs_handle_t mset,
    dqcs_qubit_t qubit
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_mset_take_any()</tt></font><div style="margin-left: 16px">
<p>Returns the measurement result for any of the qubits contained in a
measurement result set and removes it from the set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_mset_take_any(dqcs_handle_t mset)
</code></pre>
<p>This is useful for iteration.</p>
</div></details>
<details><summary><font color="purple"><tt>dqcs_path_style_t</tt></font><div style="margin-left: 16px">
<p>Reproduction file path style.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_path_style_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_PATH_STYLE_INVALID = -1</tt></font></summary><div style="margin-left: 16px">
Error value used to indicate that something went wrong.
</div></details>
<details><summary><font color="blue"><tt>DQCS_PATH_STYLE_KEEP = 0</tt></font></summary><div style="margin-left: 16px">
Specifies that paths should be saved the same way they were specified
on the command line.
</div></details>
<details><summary><font color="blue"><tt>DQCS_PATH_STYLE_RELATIVE = 1</tt></font></summary><div style="margin-left: 16px">
Specifies that all paths should be saved relative to DQCsim's working
directory.
</div></details>
<details><summary><font color="blue"><tt>DQCS_PATH_STYLE_ABSOLUTE = 2</tt></font></summary><div style="margin-left: 16px">
Specifies that all paths should be saved canonically, i.e. relative to
the root directory.
</div></details>
</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_accept_timeout_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured timeout for the plugin process to connect to DQCsim.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">double dqcs_pcfg_accept_timeout_get(dqcs_handle_t pcfg)
</code></pre>
<p>The time unit is in seconds. Returns positive inifinity for an infinite
timeout. Returns -1 when the function fails.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_accept_timeout_set()</tt></font><div style="margin-left: 16px">
<p>Configures the timeout for the plugin process to connect to DQCsim.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_accept_timeout_set(
    dqcs_handle_t pcfg,
    double timeout
)
</code></pre>
<p>The default is 5 seconds, so you should normally be able to leave this
alone.</p>
<p>The time unit is seconds. Use IEEE positive infinity to specify an infinite
timeout.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_env_set()</tt></font><div style="margin-left: 16px">
<p>Overrides an environment variable for the plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_env_set(
    dqcs_handle_t pcfg,
    const char *key,
    const char *value
)
</code></pre>
<p>The environment variable <code>key</code> is set to <code>value</code> regardless of whether it
exists in the parent environment variable scope.</p>
<p>If value is <code>NULL</code>, the environment variable <code>key</code> is unset instead.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_env_unset()</tt></font><div style="margin-left: 16px">
<p>Removes/unsets an environment variable for the plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_env_unset(
    dqcs_handle_t pcfg,
    const char *key
)
</code></pre>
<p>The environment variable <code>key</code> is unset regardless of whether it exists in
the parent environment variable scope.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_executable()</tt></font><div style="margin-left: 16px">
<p>Returns the configured executable path for the given plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_pcfg_executable(dqcs_handle_t pcfg)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
executable path. Free it with <code>free()</code> when you're done with it to avoid
memory leaks.</strong> On failure (i.e., the handle is invalid) this returns
<code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_init_cmd()</tt></font><div style="margin-left: 16px">
<p>Appends an <code>ArbCmd</code> to the list of initialization commands of a plugin
process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_init_cmd(
    dqcs_handle_t pcfg,
    dqcs_handle_t cmd
)
</code></pre>
<p>The <code>ArbCmd</code> handle is consumed by this function, and is thus invalidated,
if and only if it is successful.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_name()</tt></font><div style="margin-left: 16px">
<p>Returns the configured name for the given plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_pcfg_name(dqcs_handle_t pcfg)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
name. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new plugin process configuration object using sugared syntax.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_pcfg_new(
    dqcs_plugin_type_t typ,
    const char *name,
    const char *spec
)
</code></pre>
<p><code>typ</code> specifies the type of plugin. <code>name</code> specifies the name used to refer
to the plugin later, which much be unique within a simulation; if it is
empty or <code>NULL</code>, auto-naming will be performed: &quot;front&quot; for the frontend,
&quot;oper&lt;i&gt;&quot; for the operators (indices starting at 1 from frontend to
backend), and &quot;back&quot; for the backend. <code>spec</code> specifies which plugin to use,
using the same syntax that the <code>dqcsim</code> command line interface uses.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_new_raw()</tt></font><div style="margin-left: 16px">
<p>Creates a new plugin process configuration object using raw paths.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_pcfg_new_raw(
    dqcs_plugin_type_t typ,
    const char *name,
    const char *executable,
    const char *script
)
</code></pre>
<p>This works the same as <code>dqcs_pcfg_new()</code>, but instead of the sugared,
command-line style specification you have to specify the path to the plugin
executable and (if applicable) the script it must execute directly. This is
useful when you have a specific executable in mind and you don't want the
somewhat heuristic desugaring algorithm from doing something unexpected.</p>
<p>Pass <code>NULL</code> or an empty string to <code>script</code> to specify a native plugin
executable that does not take a script argument.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_script()</tt></font><div style="margin-left: 16px">
<p>Returns the configured script path for the given plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_pcfg_script(dqcs_handle_t pcfg)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
script path. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>. An
empty string will be returned if no script is configured to distinguish it
from failure.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_shutdown_timeout_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured timeout for the plugin process to shut down
gracefully.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">double dqcs_pcfg_shutdown_timeout_get(dqcs_handle_t pcfg)
</code></pre>
<p>The time unit is in seconds. Returns positive inifinity for an infinite
timeout. Returns -1 when the function fails.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_shutdown_timeout_set()</tt></font><div style="margin-left: 16px">
<p>Configures the timeout for the plugin process to shut down gracefully.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_shutdown_timeout_set(
    dqcs_handle_t pcfg,
    double timeout
)
</code></pre>
<p>The default is 5 seconds, so you should normally be able to leave this
alone.</p>
<p>The time unit is seconds. Use IEEE positive infinity to specify an infinite
timeout.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_stderr_mode_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured stderr capture mode for the specified plugin
process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_loglevel_t dqcs_pcfg_stderr_mode_get(dqcs_handle_t pcfg)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_stderr_mode_set()</tt></font><div style="margin-left: 16px">
<p>Configures the capture mode for the stderr stream of the specified plugin
process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_stderr_mode_set(
    dqcs_handle_t pcfg,
    dqcs_loglevel_t level
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_stdout_mode_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured stdout capture mode for the specified plugin
process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_loglevel_t dqcs_pcfg_stdout_mode_get(dqcs_handle_t pcfg)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_stdout_mode_set()</tt></font><div style="margin-left: 16px">
<p>Configures the capture mode for the stdout stream of the specified plugin
process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_stdout_mode_set(
    dqcs_handle_t pcfg,
    dqcs_loglevel_t level
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_tee()</tt></font><div style="margin-left: 16px">
<p>Configures a plugin process to also output its log messages to a file.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_tee(
    dqcs_handle_t pcfg,
    dqcs_loglevel_t verbosity,
    const char *filename
)
</code></pre>
<p><code>verbosity</code> configures the verbosity level for the file only.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_type()</tt></font><div style="margin-left: 16px">
<p>Returns the type of the given plugin process configuration.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_plugin_type_t dqcs_pcfg_type(dqcs_handle_t pcfg)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_verbosity_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured verbosity for the given plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_loglevel_t dqcs_pcfg_verbosity_get(dqcs_handle_t pcfg)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_verbosity_set()</tt></font><div style="margin-left: 16px">
<p>Configures the logging verbosity for the given plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_verbosity_set(
    dqcs_handle_t pcfg,
    dqcs_loglevel_t level
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_work_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured working directory for the given plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_pcfg_work_get(dqcs_handle_t pcfg)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
working directory. Free it with <code>free()</code> when you're done with it to avoid
memory leaks.</strong> On failure (i.e., the handle is invalid) this returns
<code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_work_set()</tt></font><div style="margin-left: 16px">
<p>Overrides the working directory for the plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_work_set(
    dqcs_handle_t pcfg,
    const char *work
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_author()</tt></font><div style="margin-left: 16px">
<p>Returns the plugin author for the given plugin definition object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_pdef_author(dqcs_handle_t pdef)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_name()</tt></font><div style="margin-left: 16px">
<p>Returns the plugin name for the given plugin definition object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_pdef_name(dqcs_handle_t pdef)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new <code>PluginDefinition</code> object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_pdef_new(
    dqcs_plugin_type_t typ,
    const char *name,
    const char *author,
    const char *version
)
</code></pre>
<p>Plugin definitions contain the callback functions/closures that define the
functionality of a plugin. They also contain some metadata to identify the
implementation, in the form of a name, author, and version string, that
must be specified when the definition is constructed. The callback
functions/closures are initialized to sane defaults for the requested
plugin type, but obviously one or more of these should be overridden to
make the plugin do something.</p>
<p>Once a definition object has been built, it can be used to spawn a plugin
thread or run a plugin in the main thread, given a DQCsim server URL for it
to connect to.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_advance_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the callback for advancing time for operators and backends.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_advance_cb(
    dqcs_handle_t pdef,
    dqcs_return_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_cycle_t cycles
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>The default behavior for operators is to pass through to
<code>dqcs_plugin_advance()</code>. The default for backends is no-op. This
callback is never called for frontend plugins.</p>
<p>Besides the common arguments, the callback receives an unsigned integer
specifying the number of cycles to advance by.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning <code>DQCS_FAILURE</code>. Otherwise, it should
return <code>DQCS_SUCCESS</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_allocate_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the qubit allocation callback for operators and backends.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_allocate_cb(
    dqcs_handle_t pdef,
    dqcs_return_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t qubits,
        dqcs_handle_t alloc_cmds
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>The default for operators is to pass through to
<code>dqcs_plugin_allocate()</code>. The default for backends is no-op. This
callback is never called for frontend plugins.</p>
<p>Besides the common arguments, the callback receives a handle to a qubit
set containing the references that are to be used for the
to-be-allocated qubits and an <code>ArbCmd</code> queue containing user-defined
commands to optionally augment the behavior of the qubits. These are
borrowed handles; the caller will delete them.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning <code>DQCS_FAILURE</code>. Otherwise, it should
return <code>DQCS_SUCCESS</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_drop_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the user logic drop/cleanup callback.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_drop_cb(
    dqcs_handle_t pdef,
    dqcs_return_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>This is called when a plugin is gracefully terminated. It is not
recommended to execute any downstream instructions at this time, but it
is supported in case this is really necessary.</p>
<p>The default behavior is no-op.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning <code>DQCS_FAILURE</code>. Otherwise, it should
return <code>DQCS_SUCCESS</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_free_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the qubit deallocation callback for operators and backends.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_free_cb(
    dqcs_handle_t pdef,
    dqcs_return_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t qubits
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>The default for operators is to pass through to <code>dqcs_plugin_free()</code>.
The default for backends is no-op. This callback is never called for
frontend plugins.</p>
<p>Besides the common arguments, the callback receives a handle to a qubit
set containing the qubits that are to be freed. This is a borrowed
handle; the caller will delete it.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning <code>DQCS_FAILURE</code>. Otherwise, it should
return <code>DQCS_SUCCESS</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_gate_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the gate execution callback for operators and backends.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_gate_cb(
    dqcs_handle_t pdef,
    dqcs_handle_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t gate
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>Besides the common arguments, the callback receives a handle to the
to-be-executed gate. This is a borrowed handle; the caller will delete
it.</p>
<p>The callback must return one of the following things:</p>
<ul>
<li>a valid handle to a measurement set, created using
<code>dqcs_mset_new()</code> (this object is automatically deleted after the
callback returns);</li>
<li>a valid handle to a single qubit measurement, created using
<code>dqcs_meas_new()</code> (this object is automatically deleted after the
callback returns);</li>
<li>the handle to the supplied gate, a shortcut for not returning any
measurements (this is less clear than returning an empty measurement
set, but slightly faster); or</li>
<li>0 to report an error, after calling the error string using
<code>dqcs_set_error()</code>.</li>
</ul>
<p>Backend plugins must return a measurement result set containing exactly
those qubits specified in the measurement set. For operators, however,
the story is more complicated. Let's say we want to make a silly
operator that inverts all measurements. The trivial way to do
this would be to forward the gate, query all the measurement results
using <code>dqcs_plugin_get_measurement()</code>, invert them, stick them in a
measurement result set, and return that result set. However, this
approach is not very efficient, because <code>dqcs_plugin_get_measurement()</code>
has to wait for all downstream plugins to finish executing the gate,
forcing the OS to switch threads, etc. Instead, operators are allowed
to return only a subset (or none) of the measured qubits, as long as
they return the measurements as they arrive through the
<code>modify_measurement()</code> callback.</p>
<p>The default implementation for this callback for operators is to pass
the gate through to the downstream plugin and return an empty set of
measurements. Combined with the default implementation of
<code>modify_measurement()</code>, this behavior is sane. Backends must override
this callback; the default is to return a not-implemented error.</p>
<p>Note that for our silly example operator, the default behavior for this
function is sufficient; you'd only have to override
<code>modify_measurement()</code> to, well, modify the measurements.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_host_arb_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the callback function function for handling an arb from the host.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_host_arb_cb(
    dqcs_handle_t pdef,
    dqcs_handle_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t cmd
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>The default behavior for this is no-op.</p>
<p>Besides the common arguments, the callback receives a handle to the
<code>ArbCmd</code> object representing the request. It must return a valid
<code>ArbData</code> handle containing the response. Both objects are deleted
automatically after invocation.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning 0. Otherwise, it should return a valid
<code>ArbData</code> handle.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_initialize_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the user logic initialization callback.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_initialize_cb(
    dqcs_handle_t pdef,
    dqcs_return_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t init_cmds
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>This is always called before any of the other callbacks are run. The
downstream plugin has already been initialized at this stage, so it is
legal to send it commands.</p>
<p>The default behavior is no-op.</p>
<p>Besides the common arguments, the callback receives a handle to an
<code>ArbCmd</code> queue (<code>dqcs_cq_*</code>, <code>dqcs_cmd_*</code>, and <code>dqcs_arb_*</code> interfaces)
containing user-defined initialization commands. This is a borrowed
handle; the caller will delete it.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning <code>DQCS_FAILURE</code>. Otherwise, it should
return <code>DQCS_SUCCESS</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_modify_measurement_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the measurement modification callback for operators.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_modify_measurement_cb(
    dqcs_handle_t pdef,
    dqcs_handle_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t meas
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>This callback is called for every measurement result received from the
downstream plugin, and returns the measurements that should be reported
to the upstream plugin. Note that the results from our plugin's
<code>dqcs_plugin_get_measurement()</code> and friends are consistent with the
results received from downstream; they are not affected by this
function.</p>
<p>The callback takes a handle to a single qubit measurement object as an
argument, and must return one of the following things:</p>
<ul>
<li>a valid handle to a measurement set, created using
<code>dqcs_mset_new()</code> (this object is automatically deleted after the
callback returns);</li>
<li>a valid handle to a single qubit measurement object, which may or
may not be the supplied one (this object is automatically deleted
after the callback returns); or</li>
<li>0 to report an error, after calling the error string using
<code>dqcs_set_error()</code>.</li>
</ul>
<p>This callback is somewhat special in that it is not allowed to call
any plugin command other than logging and the pseudorandom number
generator functions. This is because this function is called
asynchronously with respect to the downstream functions, making the
timing of these calls non-deterministic based on operating system
scheduling.</p>
<p>Note that while this function is called for only a single measurement
at a time, it is allowed to produce a vector of measurements. This
allows you to cancel propagation of the measurement by returning an
empty vector, to just modify the measurement data itself, or to
generate additional measurements from a single measurement. However,
if you need to modify the qubit references for operators that remap
qubits, take care to only send measurement data upstream when these
were explicitly requested through the associated upstream gate
function's <code>measured</code> list.</p>
<p>The default behavior for this callback is to return the measurement
without modification.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_run_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the run callback for frontends.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_run_cb(
    dqcs_handle_t pdef,
    dqcs_handle_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t args
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>This is called in response to a <code>start()</code> host API call. The return
value is returned through the <code>wait()</code> host API call.</p>
<p>The default behavior is to fail with a &quot;not implemented&quot; error;
frontends backends should always override this. This callback is never
called for operator or backend plugins.</p>
<p>Besides the common arguments, the callback receives a handle to an
<code>ArbData</code> object containing the data that the host passed to <code>start()</code>.
This is a borrowed handle; the caller will delete it.</p>
<p>When the run callback is successful, it should return a valid <code>ArbData</code>
handle. This can be the same as the argument, but it can also be a new
object. This <code>ArbData</code> is returned to the host through <code>wait()</code>. This
<code>ArbData</code> object is deleted after the callback completes.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning 0. Otherwise, it should return a
valid <code>ArbData</code> handle.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_upstream_arb_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the callback function for handling an arb from upstream for
operators and backends.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_upstream_arb_cb(
    dqcs_handle_t pdef,
    dqcs_handle_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t cmd
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>The default behavior for operators is to pass through to
<code>dqcs_plugin_arb()</code>; operators that do not support the requested
interface should always do this. The default for backends is no-op.
This callback is never called for frontend plugins.</p>
<p>Besides the common arguments, the callback receives a handle to the
<code>ArbCmd</code> object representing the request. It must return a valid
<code>ArbData</code> handle containing the response. Both objects are deleted
automatically after invocation.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning 0. Otherwise, it should return a valid
<code>ArbData</code> handle.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_type()</tt></font><div style="margin-left: 16px">
<p>Returns the plugin type for the given plugin definition object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_plugin_type_t dqcs_pdef_type(dqcs_handle_t pdef)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_version()</tt></font><div style="margin-left: 16px">
<p>Returns the plugin version for the given plugin definition object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_pdef_version(dqcs_handle_t pdef)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_advance()</tt></font><div style="margin-left: 16px">
<p>Tells the downstream plugin to run for the specified number of cycles.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_cycle_t dqcs_plugin_advance(
    dqcs_plugin_state_t plugin,
    dqcs_cycle_t cycles
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p>The return value is the new cycle counter. This function uses -1 to signal
an error.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_allocate()</tt></font><div style="margin-left: 16px">
<p>Allocate the given number of downstream qubits.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_plugin_allocate(
    dqcs_plugin_state_t plugin,
    uintptr_t num_qubits,
    dqcs_handle_t cq
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p><code>num_qubits</code> specifies the number of qubits that are to be allocated.</p>
<p><code>commands</code> must be 0 or a valid handle to an <code>ArbCmd</code> queue, containing a
list of commands that may be used to modify the behavior of the qubit
register; 0 is equivalent to zero commands. The queue is consumed by this
function, i.e. the handle becomes invalid, if and only if it succeeds.</p>
<p>If the function is successful, a new handle to the set of qubit references
representing the newly allocated register is returned. When the function
fails, 0 is returned.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_arb()</tt></font><div style="margin-left: 16px">
<p>Sends an arbitrary command downstream.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_plugin_arb(
    dqcs_plugin_state_t plugin,
    dqcs_handle_t cmd
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p>This function returns a new handle to an <code>ArbData</code> object representing the
return value of the <code>ArbCmd</code> when successful. Otherwise, it returns 0.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_free()</tt></font><div style="margin-left: 16px">
<p>Free the given downstream qubits.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_plugin_free(
    dqcs_plugin_state_t plugin,
    dqcs_handle_t qbset
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p><code>qubits</code> must be a valid set of qubit references. The set is consumed by
this function, i.e. the handle becomes invalid, if and only if it succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_gate()</tt></font><div style="margin-left: 16px">
<p>Tells the downstream plugin to execute a gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_plugin_gate(
    dqcs_plugin_state_t plugin,
    dqcs_handle_t gate
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p><code>gate</code> must be a valid gate object. The object is consumed by this
function, i.e. the handle becomes invalid, if and only if it succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_get_cycle()</tt></font><div style="margin-left: 16px">
<p>Returns the current value of the downstream cycle counter.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_cycle_t dqcs_plugin_get_cycle(dqcs_plugin_state_t plugin)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p>This function uses -1 to signal an error.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_get_cycles_between_measures()</tt></font><div style="margin-left: 16px">
<p>Returns the number of downstream cycles between the last two measurements
of the given downstream qubit.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_cycle_t dqcs_plugin_get_cycles_between_measures(
    dqcs_plugin_state_t plugin,
    dqcs_qubit_t qubit
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p>This function uses -1 to signal an error.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_get_cycles_since_measure()</tt></font><div style="margin-left: 16px">
<p>Returns the number of downstream cycles since the latest measurement of the
given downstream qubit.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_cycle_t dqcs_plugin_get_cycles_since_measure(
    dqcs_plugin_state_t plugin,
    dqcs_qubit_t qubit
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p>This function uses -1 to signal an error.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_get_measurement()</tt></font><div style="margin-left: 16px">
<p>Returns the latest measurement of the given downstream qubit.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_plugin_get_measurement(
    dqcs_plugin_state_t plugin,
    dqcs_qubit_t qubit
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p>If the function succeeds, it returns a new handle to a qubit measurement
result object. Otherwise it returns 0.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_random_f64()</tt></font><div style="margin-left: 16px">
<p>Generates a random floating point number using the simulator random seed.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">double dqcs_plugin_random_f64(dqcs_plugin_state_t plugin)
</code></pre>
<p>The generated numbers are uniformly distributed in the range <code>[0,1&gt;</code>.</p>
<p>This function only fails if the <code>plugin</code> handle is invalid, in which case
it returns 0. Of course, 0 is also a valid (if rare) random return value.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_random_u64()</tt></font><div style="margin-left: 16px">
<p>Generates a random unsigned 64-bit number using the simulator random seed.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_plugin_random_u64(dqcs_plugin_state_t plugin)
</code></pre>
<p>This function only fails if the <code>plugin</code> handle is invalid, in which case
it returns 0. Of course, 0 is also a valid (if rare) random return value.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_recv()</tt></font><div style="margin-left: 16px">
<p>Waits for a message from the host.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_plugin_recv(dqcs_plugin_state_t plugin)
</code></pre>
<p>It is only legal to call this function from within the <code>run()</code> callback.
Any other source will result in an error.</p>
<p>When successful, this function returns a new handle to the received
<code>ArbData</code> object. 0 is used to indicate that an error occurred.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_run()</tt></font><div style="margin-left: 16px">
<p>Executes a plugin in the current thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_plugin_run(
    dqcs_handle_t pdef,
    const char *simulator
)
</code></pre>
<p><code>pdef</code> must be an appropriately populated plugin definition object.
Its callback functions will be called from the current thread, from within
the context of this function.</p>
<p><code>simulator</code> must be set to the address of our endpoint of the simulator
that's using the plugin; DQCsim normally passes this as the first command
line argument of the plugin process.</p>
<p>If the plugin starts, the <code>pdef</code> handle is consumed by this function,
regardless of whether the plugin eventually closes normally. The handle is
only left alive if <code>pdef</code> is not a plugin definition object.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_send()</tt></font><div style="margin-left: 16px">
<p>Sends a message to the host.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_plugin_send(
    dqcs_plugin_state_t plugin,
    dqcs_handle_t arb
)
</code></pre>
<p>It is only legal to call this function from within the <code>run()</code> callback.
Any other source will result in an error.</p>
<p>The <code>cmd</code> handle is consumed by this function if and only if it succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_start()</tt></font><div style="margin-left: 16px">
<p>Executes a plugin in a worker thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_plugin_start(
    dqcs_handle_t pdef,
    const char *simulator
)
</code></pre>
<p>This function behaves the same as dqcs_plugin_log(), but is asynchronous;
it always returns immediately. Of course, this means that the callbacks in
<code>pdef</code> will be called from a different thread.</p>
<p>To wait for the thread to finish executing, call <code>dqcs_plugin_wait()</code> on
the returned join handle. Alternatively you can delete the join handle
object, which will detach the thread.</p>
<p>Note that <code>dqcs_log_*()</code> will only be available in the thread that the
plugin actually runs in.</p>
<p>This function returns 0 to indicate failure to start the plugin. Otherwise,
the join handle is returned.</p>
</div></details>
<details><summary><font color="purple"><tt>dqcs_plugin_state_t</tt></font><div style="margin-left: 16px">
<p>Type for a plugin state.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef void *dqcs_plugin_state_t;
</code></pre>
<p>This is an opaque type that is passed along to plugin implementation
callback functions, which those callbacks can then use to interact with the
plugin instance. User code shall not create or modify values of this type,
and shall only use the values when calling <code>dqcs_plugin_*</code> functions.</p>
</div></details>
<details><summary><font color="purple"><tt>dqcs_plugin_type_t</tt></font><div style="margin-left: 16px">
<p>Enumeration of the three types of plugins.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_plugin_type_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_PTYPE_INVALID = -1</tt></font></summary><div style="margin-left: 16px">
Invalid plugin type. Used to indicate failure of an API that returns
a plugin type.
</div></details>
<details><summary><font color="blue"><tt>DQCS_PTYPE_FRONT = 0</tt></font></summary><div style="margin-left: 16px">
Frontend plugin.
</div></details>
<details><summary><font color="blue"><tt>DQCS_PTYPE_OPER = 1</tt></font></summary><div style="margin-left: 16px">
Operator plugin.
</div></details>
<details><summary><font color="blue"><tt>DQCS_PTYPE_BACK = 2</tt></font></summary><div style="margin-left: 16px">
Backend plugin.
</div></details>
</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_wait()</tt></font><div style="margin-left: 16px">
<p>Waits for a plugin worker thread to finish executing.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_plugin_wait(dqcs_handle_t pjoin)
</code></pre>
<p>Unless the join handle is invalid, this function returns success/failure
based on the result of the plugin execution. If the plugin thread is
joined, the join handle is deleted.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_qbset_contains()</tt></font><div style="margin-left: 16px">
<p>Returns whether the given qubit set contains the given qubit.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_qbset_contains(
    dqcs_handle_t qbset,
    dqcs_qubit_t qubit
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_qbset_copy()</tt></font><div style="margin-left: 16px">
<p>Returns a copy of the given qubit set, intended for non-destructive
iteration.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_qbset_copy(dqcs_handle_t qbset)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_qbset_len()</tt></font><div style="margin-left: 16px">
<p>Returns the number of qubits in the given set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_qbset_len(dqcs_handle_t qbset)
</code></pre>
<p>This function returns -1 to indicate failure.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_qbset_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new set of qubit references.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_qbset_new(void)
</code></pre>
<p>Returns the handle of the newly created set. The set is initially empty.
Qubit sets are ordered, meaning that the order in which qubits are popped
from the set equals the order in which they were pushed. To iterate over a
set, simply make a copy and drain the copy using pop.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_qbset_pop()</tt></font><div style="margin-left: 16px">
<p>Pops a qubit reference off of a qubit reference set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_qubit_t dqcs_qbset_pop(dqcs_handle_t qbset)
</code></pre>
<p>Qubits are popped in the same order in which they were pushed. That is,
they are FIFO-ordered.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_qbset_push()</tt></font><div style="margin-left: 16px">
<p>Pushes a qubit reference into a qubit reference set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_qbset_push(
    dqcs_handle_t qbset,
    dqcs_qubit_t qubit
)
</code></pre>
<p>This function will fail if the specified qubit was already part of the set.</p>
</div></details>
<details><summary><font color="purple"><tt>dqcs_qubit_t</tt></font><div style="margin-left: 16px">
<p>Type for a qubit reference.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef unsigned long long dqcs_qubit_t;
</code></pre>
<p>Qubit references are exchanged between the frontend, operator, and backend
plugins to indicate which qubits a gate operates on. Note that this makes
them fundamentally different from handles, which are thread-local.</p>
<p>Qubit references are always positive integers, counting upwards from 1 upon
allocation, and they are not reused even after the qubit is deallocated.
Thus, every subsequent allocation returns a qubit reference one greater
than the previous. This is guaranteed behavior that external code can rely
upon. The value zero is reserved for invalid references or error
propagation.</p>
</div></details>
<details><summary><font color="purple"><tt>dqcs_return_t</tt></font><div style="margin-left: 16px">
<p>Default return type for functions that don't need to return anything.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_return_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_FAILURE = -1</tt></font></summary><div style="margin-left: 16px">
The function has failed. More information may be obtained through
`dqcsim_explain()`.
</div></details>
<details><summary><font color="blue"><tt>DQCS_SUCCESS = 0</tt></font></summary><div style="margin-left: 16px">
The function did what it was supposed to.
</div></details>
</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_dqcsim_verbosity_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured verbosity for DQCsim's own messages.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_loglevel_t dqcs_scfg_dqcsim_verbosity_get(dqcs_handle_t scfg)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_dqcsim_verbosity_set()</tt></font><div style="margin-left: 16px">
<p>Configures the logging verbosity for DQCsim's own messages.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_dqcsim_verbosity_set(
    dqcs_handle_t scfg,
    dqcs_loglevel_t level
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_log_callback()</tt></font><div style="margin-left: 16px">
<p>Configures DQCsim to also output its log messages to callback function.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_log_callback(
    dqcs_handle_t scfg,
    dqcs_loglevel_t verbosity,
    void (*callback)(
        void *user_data,
        const char *message,
        const char *logger,
        dqcs_loglevel_t level,
        const char *module,
        const char *file,
        uint32_t line,
        uint64_t time_s,
        uint32_t time_ns,
        uint32_t pid,
        uint64_t tid
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p><code>verbosity</code> specifies the minimum importance of a message required for the
callback to be called.</p>
<p><code>callback</code> is the callback function to install. It is always called with
the <code>user_data</code> pointer to make calling stuff like class member functions
or closures possible. The <code>user_free</code> function, if non-null, will be called
when the callback is uninstalled in any way. If <code>callback</code> is null, any
current callback is uninstalled instead. For consistency, if <code>user_free</code> is
non-null while <code>callback</code> is null, <code>user_free</code> is called immediately, under
the assumption that the caller has allocated resources unbeknownst that the
callback it's trying to install is null.</p>
<p><strong>NOTE: both <code>callback</code> and <code>user_free</code> may be called from a thread spawned
by the simulator. Calling any API calls from the callback is therefore
undefined behavior!</strong></p>
<p>The callback takes the following arguments:</p>
<ul>
<li><code>void*</code>: user defined data.</li>
<li><code>const char*</code>: log message string, excluding metadata.</li>
<li><code>const char*</code>: name assigned to the logger that was used to produce the
message (= &quot;dqcsim&quot; or a plugin name).</li>
<li><code>dqcs_loglevel_t</code>: the verbosity level that the message was logged with.</li>
<li><code>const char*</code>: string representing the source of the log message, or
<code>NULL</code> when no source is known.</li>
<li><code>const char*</code>: string containing the filename of the source that
generated the message, or <code>NULL</code> when no source is known.</li>
<li><code>uint32_t</code>: line number within the aforementioned file, or 0 if not
known.</li>
<li><code>uint64_t</code>: Time in seconds since the Unix epoch.</li>
<li><code>uint32_t</code>: Additional time in nanoseconds since the aforementioned.</li>
<li><code>uint32_t</code>: PID of the generating process.</li>
<li><code>uint64_t</code>: TID of the generating thread.</li>
</ul>
<p>If an internal log record is particularly malformed and cannot be coerced
into the above (nul bytes in the strings, invalid timestamp, whatever) the
message is silently ignored.</p>
<p>The primary use of this callback is to pipe DQCsim's messages to an
external logging framework. When you do this, you probably also want to
call <code>dqcs_scfg_stderr_verbosity_set(handle, DQCS_LOG_OFF)</code> to prevent
DQCsim from writing the messages to stderr itself.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_new()</tt></font><div style="margin-left: 16px">
<p>Constructs an empty simulation configuration.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_scfg_new(void)
</code></pre>
<p>Before the configuration can be used, at least a frontend and a backend
plugin configuration must be pushed into it. This can be done with
<code>dqcs_scfg_push_plugin()</code>. Failing to do this will result in an error when
you try to start the simulation.</p>
<p>The default settings correspond to the defaults of the <code>dqcsim</code> command
line interface. Refer to its help for more information.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_push_plugin()</tt></font><div style="margin-left: 16px">
<p>Appends a plugin to a simulation configuration.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_push_plugin(
    dqcs_handle_t scfg,
    dqcs_handle_t xcfg
)
</code></pre>
<p>Both plugin process and plugin thread configuration objects may be used.
The handle is consumed by this function, and is thus invalidated, if and
only if it is successful.</p>
<p>Frontend and backend plugins will automatically be inserted at the front
and back of the pipeline when the simulation is created. Operators are
inserted in front to back order. This function does not provide safeguards
against multiple frontends/backends; such errors will only be reported when
the simulation is started.</p>
<p>Note that it is not possible to observe or mutate a plugin configuration
once it has been added to a simulator configuration handle. If you want to
do this for some reason, you should maintain your own data structures, and
only build the DQCsim structures from them when you're done.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_repro_disable()</tt></font><div style="margin-left: 16px">
<p>Disables the reproduction logging system.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_repro_disable(dqcs_handle_t scfg)
</code></pre>
<p>Calling this will disable the warnings printed when a simulation that
cannot be reproduced is constructed.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_repro_path_style_get()</tt></font><div style="margin-left: 16px">
<p>Returns the path style used when writing reproduction files.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_path_style_t dqcs_scfg_repro_path_style_get(dqcs_handle_t scfg)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_repro_path_style_set()</tt></font><div style="margin-left: 16px">
<p>Sets the path style used when writing reproduction files.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_repro_path_style_set(
    dqcs_handle_t scfg,
    dqcs_path_style_t path_style
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_seed_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured random seed.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">uint64_t dqcs_scfg_seed_get(dqcs_handle_t scfg)
</code></pre>
<p>This function will return 0 when it fails, but this can unfortunately not
be reliably distinguished from a seed that was set to 0.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_seed_set()</tt></font><div style="margin-left: 16px">
<p>Configures the random seed that the simulation should use.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_seed_set(
    dqcs_handle_t scfg,
    uint64_t seed
)
</code></pre>
<p>Note that the seed is randomized by default.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_stderr_verbosity_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured stderr sink verbosity for a simulation.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_loglevel_t dqcs_scfg_stderr_verbosity_get(dqcs_handle_t scfg)
</code></pre>
<p>That is, the minimum loglevel that a messages needs to have for it to be
printed to stderr.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_stderr_verbosity_set()</tt></font><div style="margin-left: 16px">
<p>Configures the stderr sink verbosity for a simulation.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_stderr_verbosity_set(
    dqcs_handle_t scfg,
    dqcs_loglevel_t level
)
</code></pre>
<p>That is, the minimum loglevel that a messages needs to have for it to be
printed to stderr.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_tee()</tt></font><div style="margin-left: 16px">
<p>Configures DQCsim to also output its log messages to a file.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_tee(
    dqcs_handle_t scfg,
    dqcs_loglevel_t verbosity,
    const char *filename
)
</code></pre>
<p><code>verbosity</code> configures the verbosity level for the file only.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_arb()</tt></font><div style="margin-left: 16px">
<p>Sends an <code>ArbCmd</code> message to one of the plugins, referenced by name.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_sim_arb(
    dqcs_handle_t sim,
    const char *name,
    dqcs_handle_t cmd
)
</code></pre>
<p><code>ArbCmd</code>s are executed immediately after yielding to the simulator, so
all pending asynchronous calls are flushed and executed <em>before</em> the
<code>ArbCmd</code>.</p>
<p>When this succeeds, the received data is returned in the form of a new
handle. When it fails, 0 is returned.</p>
<p>The <code>ArbCmd</code> handle is consumed if and only if the API call succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_arb_idx()</tt></font><div style="margin-left: 16px">
<p>Sends an <code>ArbCmd</code> message to one of the plugins, referenced by index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_sim_arb_idx(
    dqcs_handle_t sim,
    ssize_t index,
    dqcs_handle_t cmd
)
</code></pre>
<p>The frontend always has index 0. 1 through N are used for the operators
in front to back order (where N is the number of operators). The
backend is at index N+1.</p>
<p>Python-style negative indices are supported. That is, -1 can be used to
refer to the backend, -2 to the last operator, and so on.</p>
<p><code>ArbCmd</code>s are executed immediately after yielding to the simulator, so
all pending asynchronous calls are flushed and executed <em>before</em> the
<code>ArbCmd</code>.</p>
<p>When this succeeds, the received data is returned in the form of a new
handle. When it fails, 0 is returned.</p>
<p>The <code>ArbCmd</code> handle is consumed if and only if the API call succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_get_author()</tt></font><div style="margin-left: 16px">
<p>Queries the author of a plugin, referenced by instance name.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_sim_get_author(
    dqcs_handle_t sim,
    const char *name
)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
author. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_get_author_idx()</tt></font><div style="margin-left: 16px">
<p>Queries the author of a plugin, referenced by index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_sim_get_author_idx(
    dqcs_handle_t sim,
    ssize_t index
)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
author. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_get_name()</tt></font><div style="margin-left: 16px">
<p>Queries the implementation name of a plugin, referenced by instance
name.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_sim_get_name(
    dqcs_handle_t sim,
    const char *name
)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
name. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_get_name_idx()</tt></font><div style="margin-left: 16px">
<p>Queries the implementation name of a plugin, referenced by index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_sim_get_name_idx(
    dqcs_handle_t sim,
    ssize_t index
)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
name. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_get_version()</tt></font><div style="margin-left: 16px">
<p>Queries the version of a plugin, referenced by instance name.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_sim_get_version(
    dqcs_handle_t sim,
    const char *name
)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
version. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_get_version_idx()</tt></font><div style="margin-left: 16px">
<p>Queries the version of a plugin, referenced by index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_sim_get_version_idx(
    dqcs_handle_t sim,
    ssize_t index
)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
version. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_new()</tt></font><div style="margin-left: 16px">
<p>Constructs a DQCsim simulation.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_sim_new(dqcs_handle_t scfg)
</code></pre>
<p>The provided handle is consumed if it is a simulation configuration,
regardless of whether simulation construction succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_recv()</tt></font><div style="margin-left: 16px">
<p>Waits for the simulated accelerator to send a message to us.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_sim_recv(dqcs_handle_t sim)
</code></pre>
<p>When this succeeds, the received data is returned in the form of a new
handle. When it fails, 0 is returned.</p>
<p>Deadlocks are detected and prevented by returning an error.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_send()</tt></font><div style="margin-left: 16px">
<p>Sends a message to the simulated accelerator.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_sim_send(
    dqcs_handle_t sim,
    dqcs_handle_t data
)
</code></pre>
<p>This is an asynchronous call: nothing happens until <code>yield()</code>,
<code>recv()</code>, or <code>wait()</code> is called.</p>
<p>The <code>ArbData</code> handle is optional; if 0 is passed, an empty data object is
used. If a handle is passed, it is consumed if and only if the API call
succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_start()</tt></font><div style="margin-left: 16px">
<p>Starts a program on the simulated accelerator.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_sim_start(
    dqcs_handle_t sim,
    dqcs_handle_t data
)
</code></pre>
<p>This is an asynchronous call: nothing happens until <code>yield()</code>,
<code>recv()</code>, or <code>wait()</code> is called.</p>
<p>The <code>ArbData</code> handle is optional; if 0 is passed, an empty data object is
used. If a handle is passed, it is consumed if and only if the API call
succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_wait()</tt></font><div style="margin-left: 16px">
<p>Waits for the simulated accelerator to finish its current program.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_sim_wait(dqcs_handle_t sim)
</code></pre>
<p>When this succeeds, the return value of the accelerator's <code>run()</code>
function is returned in the form of a new handle. When it fails, 0 is
returned.</p>
<p>Deadlocks are detected and prevented by returning an error.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_write_reproduction_file()</tt></font><div style="margin-left: 16px">
<p>Writes a reproduction file for the simulation so far.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_sim_write_reproduction_file(
    dqcs_handle_t sim,
    const char *filename
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_yield()</tt></font><div style="margin-left: 16px">
<p>Yields to the simulator.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_sim_yield(dqcs_handle_t sim)
</code></pre>
<p>The simulation runs until it blocks again. This is useful if you want an
immediate response to an otherwise asynchronous call through the logging
system or some communication channel outside of DQCsim's control.</p>
<p>This function silently returns immediately if no asynchronous data was
pending or if the simulator is waiting for something that has not been
sent yet.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_tcfg_init_cmd()</tt></font><div style="margin-left: 16px">
<p>Appends an <code>ArbCmd</code> to the list of initialization commands of a plugin
thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_tcfg_init_cmd(
    dqcs_handle_t tcfg,
    dqcs_handle_t cmd
)
</code></pre>
<p>The <code>ArbCmd</code> handle is consumed by this function, and is thus invalidated,
if and only if it is successful.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_tcfg_name()</tt></font><div style="margin-left: 16px">
<p>Returns the configured name for the given plugin thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_tcfg_name(dqcs_handle_t tcfg)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
name. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_tcfg_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new plugin thread configuration object from a plugin definition.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_tcfg_new(
    dqcs_handle_t pdef,
    const char *name
)
</code></pre>
<p>The plugin definition handle is consumed by this function.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_tcfg_new_raw()</tt></font><div style="margin-left: 16px">
<p>Creates a new plugin thread configuration object from a callback.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_tcfg_new_raw(
    dqcs_plugin_type_t plugin_type,
    const char *name,
    void (*callback)(
        void *user_data,
        const char *simulator
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>The callback is called by DQCsim from a dedicated thread when DQCsim wants
to start the plugin. The callback must then in some way spawn a plugin
process that connects to the provided simulator string. The callback should
return only when the process terminates.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_tcfg_tee()</tt></font><div style="margin-left: 16px">
<p>Configures a plugin thread to also output its log messages to a file.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_tcfg_tee(
    dqcs_handle_t tcfg,
    dqcs_loglevel_t verbosity,
    const char *filename
)
</code></pre>
<p><code>verbosity</code> configures the verbosity level for the file only.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_tcfg_type()</tt></font><div style="margin-left: 16px">
<p>Returns the type of the given plugin thread configuration.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_plugin_type_t dqcs_tcfg_type(dqcs_handle_t tcfg)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_tcfg_verbosity_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured verbosity for the given plugin thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_loglevel_t dqcs_tcfg_verbosity_get(dqcs_handle_t tcfg)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_tcfg_verbosity_set()</tt></font><div style="margin-left: 16px">
<p>Configures the logging verbosity for the given plugin thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_tcfg_verbosity_set(
    dqcs_handle_t tcfg,
    dqcs_loglevel_t level
)
</code></pre>
</div></details>
<h1><a class="header" href="#rust-api" id="rust-api">Rust API</a></h1>
<p>Of course, you can also develop plugins in Rust, since that's DQCsim's native
programming language. Simply add the <code>dqcsim</code> crate to your Cargo dependencies,
and use DQCsim's internal structures. You can find the crate documentation
<a href="rust-api/../rust_/dqcsim/index.html">here</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
