<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Reference - DQCsim</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction to DQCsim</a></li><li><ol class="section"><li class="expanded "><a href="../intro/components.html"><strong aria-hidden="true">1.1.</strong> The components of a simulation</a></li><li><ol class="section"><li class="expanded "><a href="../intro/frontend.html"><strong aria-hidden="true">1.1.1.</strong> Frontend use cases</a></li><li class="expanded "><a href="../intro/backend.html"><strong aria-hidden="true">1.1.2.</strong> Backend use cases</a></li><li class="expanded "><a href="../intro/operator.html"><strong aria-hidden="true">1.1.3.</strong> Operator use cases</a></li><li class="expanded "><a href="../intro/host.html"><strong aria-hidden="true">1.1.4.</strong> Host use cases</a></li></ol></li><li class="expanded "><a href="../intro/puzzle.html"><strong aria-hidden="true">1.2.</strong> Jigsaw puzzle analogy</a></li><li class="expanded "><a href="../intro/interfaces.html"><strong aria-hidden="true">1.3.</strong> DQCsim's interfaces</a></li><li><ol class="section"><li class="expanded "><a href="../intro/arbs.html"><strong aria-hidden="true">1.3.1.</strong> ArbData and ArbCmds</a></li><li class="expanded "><a href="../intro/gatestream.html"><strong aria-hidden="true">1.3.2.</strong> Gate- and measurement streams</a></li><li class="expanded "><a href="../intro/host-iface.html"><strong aria-hidden="true">1.3.3.</strong> The host interface</a></li><li class="expanded "><a href="../intro/misc-iface.html"><strong aria-hidden="true">1.3.4.</strong> Miscellaneous interfaces</a></li></ol></li><li class="expanded "><a href="../intro/reproducibility.html"><strong aria-hidden="true">1.4.</strong> Reproducibility</a></li></ol></li><li class="expanded "><a href="../install/index.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li><ol class="section"><li class="expanded "><a href="../install/plugins.html"><strong aria-hidden="true">2.1.</strong> Plugin distribution</a></li></ol></li><li class="expanded "><a href="../cli/index.html"><strong aria-hidden="true">3.</strong> The command-line interface</a></li><li class="expanded "><a href="../python-api/index.html"><strong aria-hidden="true">4.</strong> Python API</a></li><li><ol class="section"><li class="expanded "><a href="../python-api/hello-world.html"><strong aria-hidden="true">4.1.</strong> Hello, world!</a></li><li class="expanded "><a href="../python-api/debugging.html"><strong aria-hidden="true">4.2.</strong> Debugging</a></li><li class="expanded "><a href="../python-api/sending-gates.html"><strong aria-hidden="true">4.3.</strong> Sending some gates</a></li><li class="expanded "><a href="../python-api/simulations.html"><strong aria-hidden="true">4.4.</strong> Controlling simulations</a></li><li class="expanded "><a href="../python-api/operator.html"><strong aria-hidden="true">4.5.</strong> Inserting an operator</a></li><li class="expanded "><a href="../python-api/reference.html"><strong aria-hidden="true">4.6.</strong> Reference</a></li></ol></li><li class="expanded "><a href="../c-api/index.html"><strong aria-hidden="true">5.</strong> C API</a></li><li><ol class="section"><li class="expanded "><a href="../c-api/usage.html"><strong aria-hidden="true">5.1.</strong> Usage</a></li><li class="expanded "><a href="../c-api/concepts.apigen.html"><strong aria-hidden="true">5.2.</strong> Concepts</a></li><li><ol class="section"><li class="expanded "><a href="../c-api/handle.apigen.html"><strong aria-hidden="true">5.2.1.</strong> Handles: dqcs_handle_*</a></li><li class="expanded "><a href="../c-api/memory-management.apigen.html"><strong aria-hidden="true">5.2.2.</strong> Memory management</a></li><li class="expanded "><a href="../c-api/error.apigen.html"><strong aria-hidden="true">5.2.3.</strong> Error handling: dqcs_error_*</a></li><li class="expanded "><a href="../c-api/callbacks.apigen.html"><strong aria-hidden="true">5.2.4.</strong> Callbacks</a></li></ol></li><li class="expanded "><a href="../c-api/type-definitions.apigen.html"><strong aria-hidden="true">5.3.</strong> Type definitions: dqcs_*_t</a></li><li class="expanded "><a href="../c-api/arb-cmd-cq.apigen.html"><strong aria-hidden="true">5.4.</strong> ArbData and ArbCmd objects</a></li><li><ol class="section"><li class="expanded "><a href="../c-api/arb.apigen.html"><strong aria-hidden="true">5.4.1.</strong> ArbData objects: dqcs_arb_*</a></li><li class="expanded "><a href="../c-api/cmd.apigen.html"><strong aria-hidden="true">5.4.2.</strong> ArbCmd objects: dqcs_cmd_*</a></li><li class="expanded "><a href="../c-api/cq.apigen.html"><strong aria-hidden="true">5.4.3.</strong> ArbCmd queues: dqcs_cq_*</a></li></ol></li><li class="expanded "><a href="../c-api/qbset.apigen.html"><strong aria-hidden="true">5.5.</strong> Qubits: dqcs_qbset_*</a></li><li class="expanded "><a href="../c-api/mat.apigen.html"><strong aria-hidden="true">5.6.</strong> Matrices: dqcs_mat_*</a></li><li class="expanded "><a href="../c-api/gate.apigen.html"><strong aria-hidden="true">5.7.</strong> Gates: dqcs_gate_*</a></li><li class="expanded "><a href="../c-api/gm.apigen.html"><strong aria-hidden="true">5.8.</strong> Gate maps: dqcs_gm_*</a></li><li class="expanded "><a href="../c-api/measurements.apigen.html"><strong aria-hidden="true">5.9.</strong> Measurements</a></li><li><ol class="section"><li class="expanded "><a href="../c-api/meas.apigen.html"><strong aria-hidden="true">5.9.1.</strong> Singular measurements: dqcs_meas_*</a></li><li class="expanded "><a href="../c-api/mset.apigen.html"><strong aria-hidden="true">5.9.2.</strong> Measurement sets: dqcs_mset_*</a></li></ol></li><li class="expanded "><a href="../c-api/plugins.apigen.html"><strong aria-hidden="true">5.10.</strong> Plugins</a></li><li><ol class="section"><li class="expanded "><a href="../c-api/pdef.apigen.html"><strong aria-hidden="true">5.10.1.</strong> Defining a plugin: dqcs_pdef_*</a></li><li class="expanded "><a href="../c-api/plugin-run.apigen.html"><strong aria-hidden="true">5.10.2.</strong> Running a plugin: dqcs_plugin_*</a></li><li class="expanded "><a href="../c-api/plugin-interact.apigen.html"><strong aria-hidden="true">5.10.3.</strong> Interacting with DQCsim: dqcs_plugin_*</a></li><li class="expanded "><a href="../c-api/log.apigen.html"><strong aria-hidden="true">5.10.4.</strong> Logging: dqcs_log_*</a></li></ol></li><li class="expanded "><a href="../c-api/simulations.apigen.html"><strong aria-hidden="true">5.11.</strong> Simulations</a></li><li><ol class="section"><li class="expanded "><a href="../c-api/pcfg.apigen.html"><strong aria-hidden="true">5.11.1.</strong> Configuring plugins: dqcs_pcfg_*</a></li><li class="expanded "><a href="../c-api/tcfg.apigen.html"><strong aria-hidden="true">5.11.2.</strong> Running local plugins: dqcs_tcfg_*</a></li><li class="expanded "><a href="../c-api/scfg.apigen.html"><strong aria-hidden="true">5.11.3.</strong> Configuring a simulation: dqcs_scfg_*</a></li><li class="expanded "><a href="../c-api/sim.apigen.html"><strong aria-hidden="true">5.11.4.</strong> Running a simulation: dqcs_sim_*</a></li></ol></li><li class="expanded "><a href="../c-api/reference.apigen.html" class="active"><strong aria-hidden="true">5.12.</strong> Reference</a></li></ol></li><li class="expanded "><a href="../cpp-api/index.html"><strong aria-hidden="true">6.</strong> C++ API</a></li><li><ol class="section"><li class="expanded "><a href="../cpp-api/usage.html"><strong aria-hidden="true">6.1.</strong> Usage</a></li><li class="expanded "><a href="../cpp-api/ccompare.html"><strong aria-hidden="true">6.2.</strong> Comparison to the C API</a></li><li class="expanded "><a href="../cpp-api/plugin.html"><strong aria-hidden="true">6.3.</strong> Plugin anatomy</a></li><li class="expanded "><a href="../cpp-api/sim.html"><strong aria-hidden="true">6.4.</strong> Host/simulation anatomy</a></li><li class="expanded "><a href="../cpp-api/reference.html"><strong aria-hidden="true">6.5.</strong> Reference</a></li></ol></li><li class="expanded "><a href="../rust-api/index.html"><strong aria-hidden="true">7.</strong> Rust API</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">DQCsim</h1>

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#reference" id="reference">Reference</a></h1>
<p>This chapter simply lists all API functions and types ordered by name.</p>
<details><summary><font color="green"><tt>dqcs_arb_assign()</tt></font><div style="margin-left: 16px">
<p>Copies the data from one object to another.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_assign(
    dqcs_handle_t dest,
    dqcs_handle_t src
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_cbor_get()</tt></font><div style="margin-left: 16px">
<p>Returns the JSON/CBOR object of an <code>ArbData</code> object in the form of a CBOR
object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_arb_cbor_get(
    dqcs_handle_t arb,
    void *obj,
    size_t obj_size
)
</code></pre>
<p>If the actual size of the object differs from the specified object size,
this function will copy the minimum of the actual and specified sizes
number of bytes, and return what the actual size was.</p>
<p>If the specified object size is zero, <code>obj</code> is allowed to be <code>NULL</code>. You
can use this to query the size before allocating an object.</p>
<p>This function returns -1 on failure.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_cbor_set()</tt></font><div style="margin-left: 16px">
<p>Sets the JSON/CBOR object of an <code>ArbData</code> object by means of a CBOR object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_cbor_set(
    dqcs_handle_t arb,
    const void *obj,
    size_t obj_size
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_clear()</tt></font><div style="margin-left: 16px">
<p>Clears the unstructured argument list.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_clear(dqcs_handle_t arb)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_get_raw()</tt></font><div style="margin-left: 16px">
<p>Returns the unstructured string argument at the specified index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_arb_get_raw(
    dqcs_handle_t arb,
    ssize_t index,
    void *obj,
    size_t obj_size
)
</code></pre>
<p>If the actual size of the object differs from the specified object size,
this function will copy the minimum of the actual and specified sizes
number of bytes, and return what the actual size was.</p>
<p>If the specified object size is zero, <code>obj</code> is allowed to be <code>NULL</code>. You
can use this to determine the size of the argument prior to actually
reading it, so you can allocate the right buffer size first.</p>
<p>This function returns -1 on failure.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_get_size()</tt></font><div style="margin-left: 16px">
<p>Returns the size in bytes of the unstructured string argument at the
specified index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_arb_get_size(
    dqcs_handle_t arb,
    ssize_t index
)
</code></pre>
<p>Returns -1 when the function fails.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_get_str()</tt></font><div style="margin-left: 16px">
<p>Returns the unstructured string argument at the specified index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_arb_get_str(
    dqcs_handle_t arb,
    ssize_t index
)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_insert_raw()</tt></font><div style="margin-left: 16px">
<p>Inserts an unstructured raw argument into the list at the specified
index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_insert_raw(
    dqcs_handle_t arb,
    ssize_t index,
    const void *obj,
    size_t obj_size
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_insert_str()</tt></font><div style="margin-left: 16px">
<p>Inserts an unstructured string argument into the list at the specified
index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_insert_str(
    dqcs_handle_t arb,
    ssize_t index,
    const char *s
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_json_get()</tt></font><div style="margin-left: 16px">
<p>Returns the JSON/CBOR object of an <code>ArbData</code> object in the form of a JSON
string.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_arb_json_get(dqcs_handle_t arb)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_json_set()</tt></font><div style="margin-left: 16px">
<p>Sets the JSON/CBOR object of an <code>ArbData</code> object by means of a JSON string.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_json_set(
    dqcs_handle_t arb,
    const char *json
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_len()</tt></font><div style="margin-left: 16px">
<p>Returns the number of unstructured arguments, or -1 to indicate failure.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_arb_len(dqcs_handle_t arb)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new <code>ArbData</code> object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_arb_new(void)
</code></pre>
<p>Returns the handle of the newly created <code>ArbData</code>. The <code>ArbData</code> is
initialized with JSON object <code>{}</code> and an empty binary argument list.</p>
<p><code>ArbData</code> objects support the <code>handle</code> and <code>arb</code> APIs.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_pop()</tt></font><div style="margin-left: 16px">
<p>Pops an unstructured argument from the back of the list without returning
it.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_pop(dqcs_handle_t arb)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_pop_raw()</tt></font><div style="margin-left: 16px">
<p>Pops an unstructured raw argument from the back of the list.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_arb_pop_raw(
    dqcs_handle_t arb,
    void *obj,
    size_t obj_size
)
</code></pre>
<p>If the actual size of the object differs from the specified object size,
this function will copy the minimum of the actual and specified sizes
number of bytes, and return what the actual size was.</p>
<p>If the specified object size is zero, <code>obj</code> is allowed to be <code>NULL</code>. You
can use this if you don't need the contents of the argument and just want
to delete it.</p>
<p>Since this function removes the returned element, data will be lost if the
specified size is smaller than the actual size. To avoid this, first use
<code>dqcs_arb_get_size(handle, -1)</code> to query the size.</p>
<p>This function returns -1 on failure. If this is due to a <code>NULL</code> buffer
being passed, the data that was popped is lost.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_pop_str()</tt></font><div style="margin-left: 16px">
<p>Pops an unstructured string argument from the back of the list.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_arb_pop_str(dqcs_handle_t arb)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>. If the failure is due to the
conversion from binary object to C string (i.e., embedded nulls), the
data is still popped and is thus lost.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_push_raw()</tt></font><div style="margin-left: 16px">
<p>Pushes an unstructured raw argument to the back of the list.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_push_raw(
    dqcs_handle_t arb,
    const void *obj,
    size_t obj_size
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_push_str()</tt></font><div style="margin-left: 16px">
<p>Pushes an unstructured string argument to the back of the list.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_push_str(
    dqcs_handle_t arb,
    const char *s
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_remove()</tt></font><div style="margin-left: 16px">
<p>Removes the specified unstructured string argument from the list.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_remove(
    dqcs_handle_t arb,
    ssize_t index
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_set_raw()</tt></font><div style="margin-left: 16px">
<p>Replaces the unstructured argument at the specified index with the
specified raw object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_set_raw(
    dqcs_handle_t arb,
    ssize_t index,
    const void *obj,
    size_t obj_size
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_arb_set_str()</tt></font><div style="margin-left: 16px">
<p>Replaces the unstructured argument at the specified index with the
specified string.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_arb_set_str(
    dqcs_handle_t arb,
    ssize_t index,
    const char *s
)
</code></pre>
</div></details>
<details><summary><font color="purple"><tt>dqcs_bool_return_t</tt></font><div style="margin-left: 16px">
<p>Return type for functions that normally return a boolean but can also fail.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_bool_return_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_BOOL_FAILURE = -1</tt></font></summary><div style="margin-left: 16px">
The function has failed. More information may be obtained through
`dqcsim_explain()`.
</div></details>
<details><summary><font color="blue"><tt>DQCS_FALSE = 0</tt></font></summary><div style="margin-left: 16px">
The function did what it was supposed to and returned false.
</div></details>
<details><summary><font color="blue"><tt>DQCS_TRUE = 1</tt></font></summary><div style="margin-left: 16px">
The function did what it was supposed to and returned true.
</div></details>
</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_cmd_iface_cmp()</tt></font><div style="margin-left: 16px">
<p>Compares the interface ID of an <code>ArbCmd</code> with the given string.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_cmd_iface_cmp(
    dqcs_handle_t cmd,
    const char *iface
)
</code></pre>
<p>Returns -1 for failure, 0 for no match, or 1 for a match.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_cmd_iface_get()</tt></font><div style="margin-left: 16px">
<p>Returns the interface ID of an <code>ArbCmd</code>.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_cmd_iface_get(dqcs_handle_t cmd)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_cmd_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new <code>ArbCmd</code> object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_cmd_new(
    const char *iface,
    const char *oper
)
</code></pre>
<p>Returns the handle of the newly created <code>ArbCmd</code>. The <code>ArbCmd</code> is
initialized with the given interface and operation IDs, JSON object <code>{}</code>,
and an empty binary argument list. Upon failure, returns 0.</p>
<p><code>ArbCmd</code> objects support the <code>handle</code>, <code>arb</code>, and <code>cmd</code> interfaces.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_cmd_oper_cmp()</tt></font><div style="margin-left: 16px">
<p>Compares the operation ID of an <code>ArbCmd</code> with the given string.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_cmd_oper_cmp(
    dqcs_handle_t cmd,
    const char *oper
)
</code></pre>
<p>Returns -1 for failure, 0 for no match, or 1 for a match.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_cmd_oper_get()</tt></font><div style="margin-left: 16px">
<p>Returns the operation ID of an <code>ArbCmd</code>.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_cmd_oper_get(dqcs_handle_t cmd)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_cq_len()</tt></font><div style="margin-left: 16px">
<p>Returns the number of <code>ArbCmd</code> objects in the given <code>ArbCmd</code> queue.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_cq_len(dqcs_handle_t cq)
</code></pre>
<p>This function returns -1 to indicate failure.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_cq_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new <code>ArbCmd</code> queue object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_cq_new(void)
</code></pre>
<p>Returns the handle of the newly created <code>ArbCmd</code> queue. The queue is
initially empty. Queues implement a &quot;first-in, first-out&quot; model.</p>
<p><code>ArbCmd</code> queue objects support the <code>handle</code>, <code>arb</code>, <code>cmd</code>, and <code>cq</code> APIs.</p>
<p>The <code>arb</code> and <code>cmd</code> APIs refer to the <code>ArbCmd</code> at the front of the queue.
Use <code>dqcs_cq_next()</code> to remove the front entry, allowing access to the next
command.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_cq_next()</tt></font><div style="margin-left: 16px">
<p>Advances an <code>ArbCmd</code> queue to the next command.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_cq_next(dqcs_handle_t cq)
</code></pre>
<p>Use the <code>dqcs_arb_*</code> and <code>dqcs_cmd_*</code> interfaces to read out the command
before calling this function.</p>
<p>To iterate over a queue in C, use the following snippit:</p>
<pre><code class="language-C">for (; dqcs_cq_len(queue) &gt; 0; dqcs_cq_next(queue)) {
    dqcs_cmd_...(queue, ...)
    dqcs_arb_...(queue, ...)
}
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_cq_push()</tt></font><div style="margin-left: 16px">
<p>Pushes an <code>ArbCmd</code> object into the given <code>ArbCmd</code> queue.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_cq_push(
    dqcs_handle_t cq,
    dqcs_handle_t cmd
)
</code></pre>
<p>This function returns -1 to indicate failure. The <code>ArbCmd</code> object specified
by <code>cmd</code> is moved into the queue. That is, the handle is consumed if and
only if the function succeeds.</p>
</div></details>
<details><summary><font color="purple"><tt>dqcs_cycle_t</tt></font><div style="margin-left: 16px">
<p>Type for a simulation cycle timestamp.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef long long dqcs_cycle_t;
</code></pre>
<p>Timestamps count upward from zero. The type is signed to allow usage of -1
for errors, and to allow numerical differences to be represented.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_error_get()</tt></font><div style="margin-left: 16px">
<p>Returns a pointer to the latest error message.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">const char *dqcs_error_get(void)
</code></pre>
<p>Call this to get extra information when another function returns a failure
code. The returned pointer is temporary and therefore should <strong>NOT</strong> be
<code>free()</code>d. It will become invalid when a new error occurs.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_error_set()</tt></font><div style="margin-left: 16px">
<p>Sets the latest error message string.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">void dqcs_error_set(const char *msg)
</code></pre>
<p>This must be called by callback functions when an error occurs within the
callback, otherwise the upstream result for <code>dqcs_error_get()</code> will be
undefined.</p>
<p>If <code>msg</code> is set to <code>NULL</code>, the error string is cleared instead.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_controls()</tt></font><div style="margin-left: 16px">
<p>Returns a handle to a new qubit reference set containing the qubits
that control this gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_controls(dqcs_handle_t gate)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_expand_control()</tt></font><div style="margin-left: 16px">
<p>Utility function that expands a gate matrix to account for all control
qubits.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_expand_control(dqcs_handle_t gate)
</code></pre>
<p>This function borrows a handle to any gate with a matrix, and returns an
equivalent copy of said gate with any control qubits in the <code>controls</code> set
moved to the <code>targets</code> set. The associated gate matrix is extended
accordingly. The control qubits are added at the front of the <code>targets</code>
set in the same order they appeared in the <code>controls</code> qubit set.</p>
<p>This function returns a new gate handle with the modified gate, or a copy
of the input gate if the matrix could not be reduced. If the input gate
does not have a matrix (measurement gate, or custom gate without matrix) an
error is returned instead.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_has_controls()</tt></font><div style="margin-left: 16px">
<p>Returns whether the specified gate has control qubits.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_gate_has_controls(dqcs_handle_t gate)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_has_matrix()</tt></font><div style="margin-left: 16px">
<p>Returns whether a unitary matrix is associated with this gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_gate_has_matrix(dqcs_handle_t gate)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_has_measures()</tt></font><div style="margin-left: 16px">
<p>Returns whether the specified gate measures any qubits.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_gate_has_measures(dqcs_handle_t gate)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_has_targets()</tt></font><div style="margin-left: 16px">
<p>Returns whether the specified gate has target qubits.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_gate_has_targets(dqcs_handle_t gate)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_is_custom()</tt></font><div style="margin-left: 16px">
<p>Returns whether the specified gate is a custom gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_gate_is_custom(dqcs_handle_t gate)
</code></pre>
<p>If this returns true, the type of gate is to be determined by matching its
name against a set of known gate types. If this returns false, the gate is
expected to be executed as follows, in this order:</p>
<ul>
<li>if there are target qubits, extend the supplied unitary matrix to
include the control qubits (if any), then apply it to the control +
target qubits;</li>
<li>measure each measured qubit (if any) in the Z basis.</li>
</ul>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_matrix()</tt></font><div style="margin-left: 16px">
<p>Returns a copy of the unitary matrix associated with this gate, if one
exists.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_matrix(dqcs_handle_t gate)
</code></pre>
<p>If this function succeeds, a new matrix handle is returned. If it fails,
0 is returned.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_measures()</tt></font><div style="margin-left: 16px">
<p>Returns a handle to a new qubit reference set containing the qubits
measured by this gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_measures(dqcs_handle_t gate)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_name()</tt></font><div style="margin-left: 16px">
<p>Returns the name of a custom gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_gate_name(dqcs_handle_t gate)
</code></pre>
<p>This function fails if the gate is not a custom gate. Query
<code>dqcs_gate_is_custom()</code> to disambiguate between a non-custom gate and a
different error.</p>
<p>On success, this <strong>returns a newly allocated string containing the gate
name. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_new_custom()</tt></font><div style="margin-left: 16px">
<p>Constructs a new custom gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_new_custom(
    const char *name,
    dqcs_handle_t targets,
    dqcs_handle_t controls,
    dqcs_handle_t measures,
    dqcs_handle_t matrix
)
</code></pre>
<p>The functionality of custom gates is not specified by DQCsim. Instead, this
is left up to the plugins. Of course, for this to work, plugins that are
connected to each other must agree on the format used.</p>
<p><code>name</code> specifies the name of the gate. The name is used to indicate which
custom operation is to be applied.</p>
<p><code>targets</code> optionally specifies the set of target qubits. You may pass 0 or
an empty qubit set if you don't need target qubits.</p>
<p><code>controls</code> optionally specifies the set of control qubits. You may pass 0
or an empty qubit set if you don't need control qubits.</p>
<p><code>measures</code> optionally specifies the set of measured qubits. You may pass 0
or an empty qubit set if no qubits are measured. Note that the upstream
plugin expects exactly one measurement result for each qubit specified in
this set; anything else results in a warning and the measurement result
being set to undefined.</p>
<p><code>matrix</code> optionally specifies a handle to an appropriately sized matrix
for the <code>targets</code> qubit set.</p>
<p>In addition to the above data, gate objects implement the <code>arb</code> interface
to allow user-specified classical information to be attached.</p>
<p>This function returns the handle to the gate, or 0 to indicate failure.
The specified qubit sets are consumed/deleted by this function if and only
if it succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_new_measurement()</tt></font><div style="margin-left: 16px">
<p>Constructs a new measurement gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_new_measurement(dqcs_handle_t measures)
</code></pre>
<p><code>measures</code> must be a handle to a qubit set. The qubits in this set are
measured in the Z-basis. To measure in other bases, first apply the
respective rotation, or use a custom gate.</p>
<p>This function returns the handle to the gate, or 0 to indicate failure.
The <code>measures</code> qubit set is consumed/deleted by this function if and only
if it succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_new_predef()</tt></font><div style="margin-left: 16px">
<p>Constructs a new predefined unitary gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_new_predef(
    dqcs_predefined_gate_t gate_type,
    dqcs_handle_t qubits,
    dqcs_handle_t param_data
)
</code></pre>
<p><code>gate_type</code> specifies which kind of gate should be constructed.</p>
<p><code>targets</code> must be a handle to a non-empty qubit set, containing at least
as many qubits as needed for the specified gate type. If more qubits are
specified, the rightmost qubits become the targets, and the remaining
qubits become control qubits to make a controlled gate.</p>
<p><code>param_data</code> takes an optional <code>ArbData</code> object used to parameterize the
gate if necessary. If not specified, an empty object is used. Some of the
gate types are parameterized, and use values from this <code>ArbData</code> as
defined in the docs for <code>dqcs_predefined_gate_t</code>. Anything remaining in
the <code>ArbData</code> afterwards is placed in the gate object.</p>
<p>This function returns the handle to the gate, or 0 to indicate failure.
The qubit set and parameterization data (if specified) are consumed/deleted
by this function if and only if it succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_new_predef_one()</tt></font><div style="margin-left: 16px">
<p>Constructs a new predefined unitary one-qubit gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_new_predef_one(
    dqcs_predefined_gate_t gate_type,
    dqcs_qubit_t qa,
    dqcs_handle_t param_data
)
</code></pre>
<p>This function is simply a shorthand for <code>dqcs_gate_new_predef()</code> with
one qubit in the <code>qubits</code> set, to make constructing one-qubit gates more
ergonomic. Refer to its documentation for more information.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_new_predef_three()</tt></font><div style="margin-left: 16px">
<p>Constructs a new predefined unitary three-qubit gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_new_predef_three(
    dqcs_predefined_gate_t gate_type,
    dqcs_qubit_t qa,
    dqcs_qubit_t qb,
    dqcs_qubit_t qc,
    dqcs_handle_t param_data
)
</code></pre>
<p>This function is simply a shorthand for <code>dqcs_gate_new_predef()</code> with
three qubit in the <code>qubits</code> set, to make constructing three-qubit gates
more ergonomic. Refer to its documentation for more information.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_new_predef_two()</tt></font><div style="margin-left: 16px">
<p>Constructs a new predefined unitary two-qubit gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_new_predef_two(
    dqcs_predefined_gate_t gate_type,
    dqcs_qubit_t qa,
    dqcs_qubit_t qb,
    dqcs_handle_t param_data
)
</code></pre>
<p>This function is simply a shorthand for <code>dqcs_gate_new_predef()</code> with
two qubit in the <code>qubits</code> set, to make constructing two-qubit gates more
ergonomic. Refer to its documentation for more information.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_new_unitary()</tt></font><div style="margin-left: 16px">
<p>Constructs a new unitary gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_new_unitary(
    dqcs_handle_t targets,
    dqcs_handle_t controls,
    dqcs_handle_t matrix
)
</code></pre>
<p><code>targets</code> must be a handle to a non-empty qubit set. The qubits in this set
correspond with the supplied unitary matrix.</p>
<p><code>controls</code> optionally specifies a set of control qubits. You may pass 0 or
an empty qubit set if you don't need control qubits.</p>
<p><code>matrix</code> must be a handle to an appropriately sized matrix.</p>
<p>The supplied matrix is only applied to the target qubits if all the control
qubits are or will be determined to be set. For instance, to encode a
CCNOT/Toffoli gate, you can specify one target qubits, two control qubits,
and [0, 1; 1, 0] (X) for the matrix. This is equivalent to extending the
matrix to the full Toffoli matrix and specifying all three qubits in the
targets set, or the midway solution using a CNOT matrix, but these
solutions may be less efficient depending on whether the simulator can
optimize its calculations for controlled gates.</p>
<p>Simulators are not required to apply the (hidden) global phase component of
the gate matrix in the same way it is specified; that is, if the simulator
can optimize its calculations by altering the global phase it is allowed
to.</p>
<p>If is up to the user to ensure that the specified matrix is unitary. This
is NOT checked by DQCsim. The simulator backend may or may not check this.</p>
<p>This function returns the handle to the gate, or 0 to indicate failure.
The <code>targets</code> qubit set, (if specified) the <code>controls</code> qubit set, and the
matrix are consumed/deleted by this function if and only if it succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_reduce_control()</tt></font><div style="margin-left: 16px">
<p>Utility function that detects control qubits in the <code>targets</code> list of the
gate by means of the gate matrix, and reduces them into <code>controls</code> qubits.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_reduce_control(
    dqcs_handle_t gate,
    double epsilon,
    bool ignore_gphase
)
</code></pre>
<p>This function borrows a handle to any gate with a matrix, and returns an
equivalent copy of said gate with any control qubits in the <code>targets</code> set
moved to the <code>controls</code> set. The associated gate matrix is accordingly
reduced in size. The control qubits are added at the end of the <code>controls</code>
set in the same order they appeared in the <code>targets</code> qubit set.</p>
<p><code>epsilon</code> specifies the maximum element-wise deviation from the identity
matrix for the relevant array elements for a qubit to be considered a
control qubit. Note that if this is greater than zero, the resulting gate
may not be exactly equivalent. If <code>ignore_gphase</code> is set, any global phase
in the matrix is ignored, but the global phase of the non-control submatrix
is not changed.</p>
<p>This function returns a new gate handle with the modified gate, or a copy
of the input gate if the matrix could not be reduced. If the input gate
does not have a matrix (measurement gate, or custom gate without matrix) an
error is returned instead.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gate_targets()</tt></font><div style="margin-left: 16px">
<p>Returns a handle to a new qubit reference set containing the qubits
targetted by this gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gate_targets(dqcs_handle_t gate)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_gm_add_custom()</tt></font><div style="margin-left: 16px">
<p>Adds a fully customizable gate mapping to the given gate map.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_gm_add_custom(
    dqcs_handle_t gm,
    void (*key_free)(void *key_data),
    void *key_data,
    dqcs_bool_return_t (*detector)(
        const void *user_data,
        dqcs_handle_t gate,
        dqcs_handle_t *qubits,
        dqcs_handle_t *param_data
    ),
    void (*detector_user_free)(void *user_data),
    void *detector_user_data,
    dqcs_handle_t (*constructor)(
        const void *user_data,
        dqcs_handle_t qubits,
        dqcs_handle_t param_data
    ),
    void (*constructor_user_free)(void *user_data),
    void *constructor_user_data
)
</code></pre>
<p>Note that this is the only type of mapping that can handle custom/named
gates.</p>
<p><code>detector</code> is the detector function pointer. It is optional; if null, this
mapping only supports construction.
<code>detector_user_free</code> is an optional callback function used to free
<code>detector_user_data</code> when the gate map is destroyed, when this function
fails, or when <code>detector</code> was null.
<code>detector_user_data</code> is a user-specified value that is passed to the
<code>detector</code> callback function. It is not used by DQCsim.
<code>constructor</code> is the constructor function pointer. It is optional; if
null, this mapping only supports detection.
<code>constructor_user_free</code> is an optional callback function used to free
<code>constructor_user_data</code> when the gate map is destroyed, when this function
fails, or when <code>constructor</code> was null.
<code>constructor_user_data</code> is a user-specified value that is passed to the
<code>constructor</code> callback function. It is not used by DQCsim.</p>
<p>If both <code>constructor</code> and <code>detector</code> are null for some reason, the
function is no-op (besides possibly calling the <code>*_free()</code> callbacks.</p>
<p>The detector callback receives the complete gate passed to the gate map
for it to match as it pleases. If the gate matches, the detector function
must return <code>DQCS_TRUE</code>. It may  assign <code>qubits</code> to a <code>qbset</code> object
representing the qubit arguments (substituted with an empty set if it
doesn't), and may assign <code>param_data</code> to an <code>arb</code> handle with the
parameterization data (if it doesn't, the data from the gate is used; if
this was modified by the callback, the modified data is used). If the gate
doesn't match, it must return <code>DQCS_FALSE</code>. If an error occurs, it must
call <code>dqcs_error_set()</code> with the error message and return
<code>DQCS_BOOL_FAILURE</code>.</p>
<p>The constructor callback performs the reverse operation. It receives an
<code>ArbData</code> handle containing the parameterization data and a qubit set, and
must construct a gate based on this information. If construction succeeds,
the constructor function must return the gate handle. If an error occurs,
it must call <code>dqcs_error_set()</code> with the error message and return 0.</p>
<p>It is up to the user how to do the matching and constructing, but the
converter functions must always return the same value for the same input.
In other words, they must be pure functions. Otherwise, the caching
behavior of the <code>GateMap</code> will make the results inconsistent.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gm_add_custom_unitary()</tt></font><div style="margin-left: 16px">
<p>Adds a custom unitary gate mapping to the given gate map.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_gm_add_custom_unitary(
    dqcs_handle_t gm,
    void (*key_free)(void *key_data),
    void *key_data,
    dqcs_bool_return_t (*detector)(
        const void *user_data,
        dqcs_handle_t matrix,
        size_t num_controls,
        dqcs_handle_t *param_data
    ),
    void (*detector_user_free)(void *user_data),
    void *detector_user_data,
    dqcs_handle_t (*constructor)(
        const void *user_data,
        dqcs_handle_t *param_data,
        intptr_t *num_controls
    ),
    void (*constructor_user_free)(void *user_data),
    void *constructor_user_data
)
</code></pre>
<p><code>gm</code> must be a handle to a gate map object (<code>dqcs_gm_new()</code>).
<code>key_free</code> is an optional callback function used to free <code>key_data</code> when
the gate map is destroyed, or when this function fails.
<code>key_data</code> is the user-specified value used to identify this mapping.
<code>detector</code> is the detector function pointer. It is optional; if null, this
mapping only supports construction.
<code>detector_user_free</code> is an optional callback function used to free
<code>detector_user_data</code> when the gate map is destroyed, when this function
fails, or when <code>detector</code> was null.
<code>detector_user_data</code> is a user-specified value that is passed to the
<code>detector</code> callback function. It is not used by DQCsim.
<code>constructor</code> is the constructor function pointer. It is optional; if
null, this mapping only supports detection.
<code>constructor_user_free</code> is an optional callback function used to free
<code>constructor_user_data</code> when the gate map is destroyed, when this function
fails, or when <code>constructor</code> was null.
<code>constructor_user_data</code> is a user-specified value that is passed to the
<code>constructor</code> callback function. It is not used by DQCsim.</p>
<p>If both <code>constructor</code> and <code>detector</code> are null for some reason, the
function is no-op (besides possibly calling the <code>*_free()</code> callbacks.</p>
<p>The detector callback receives a matrix and control qubit information for
the user to match. The matrix is passed through the <code>matrix</code> handle.
<code>num_controls</code> is passed the number of explicit control qubits that exist
besides the matrix (that is, if nonzero, the matrix is actually only the
non-controlled submatrix of the controlled gate). <code>param_data</code> is given an
<code>ArbData</code> handle initialized with the <code>ArbData</code> attached to the gate. If
the gate matches, the detector function must return <code>DQCS_TRUE</code>. In this
case, it can mutate the <code>param_data</code> to add the detected gate parameters.
If it doesn't match, it must return <code>DQCS_FALSE</code>. If an error occurs, it
must call <code>dqcs_error_set()</code> with the error message and return
<code>DQCS_BOOL_FAILURE</code>.</p>
<p>The constructor callback performs the reverse operation. It receives an
<code>ArbData</code> handle containing the parameterization data, and must construct
the matrix, return the bound on the number of control qubits, and must
return the <code>ArbData</code> associated with the gate by mutating the <code>param_data</code>
handle. <code>num_controls</code> will point to a variable initialized to -1
representing a constraint on the number of control qubits. This works as
follows: if negative, any number of qubits is allowed; if zero or
positive, only that number is allowed. If construction succeeds, the
constructor function must return a handle to the constructed matrix. If
it fails, it must call <code>dqcs_error_set()</code> with an error message and return
0.</p>
<p>It is up to the user how to do the matching and constructing, but the
converter functions must always return the same value for the same input.
In other words, they must be pure functions. Otherwise, the caching
behavior of the <code>GateMap</code> will make the results inconsistent.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gm_add_fixed_unitary()</tt></font><div style="margin-left: 16px">
<p>Adds a unitary gate mapping for the given gate matrix to the given gate
map.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_gm_add_fixed_unitary(
    dqcs_handle_t gm,
    void (*key_free)(void *key_data),
    void *key_data,
    dqcs_handle_t matrix,
    intptr_t num_controls,
    double epsilon,
    bool ignore_gphase
)
</code></pre>
<p><code>gm</code> must be a handle to a gate map object (<code>dqcs_gm_new()</code>).
<code>key_free</code> is an optional callback function used to free <code>key_data</code> when
the gate map is destroyed, or when this function fails.
<code>key_data</code> is the user-specified value used to identify this mapping.
<code>matrix</code> must be passed a handle to the matrix to detect. It is consumed
by this function.
<code>num_controls</code> specifies the number of control qubits associated with this
gate type. If negative, the gate can have any number of control qubits.
If zero or positive, the number of control qubits must be as specified.
<code>epsilon</code> specifies the maximum element-wise root-mean-square error
between the incoming matrix and the to be detected matrix that results in a
positive match.
<code>ignore_phase</code> specifies whether the aforementioned check should ignore
global phase or not when there are no explicit control qubits.</p>
<p>The parameterization <code>ArbData</code> object returned by detection and consumed
by construction is mapped one-to-one to the user data of the gate in the
DQCsim-protocol.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gm_add_measure()</tt></font><div style="margin-left: 16px">
<p>Adds a measurement gate mapping to the given gate map.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_gm_add_measure(
    dqcs_handle_t gm,
    void (*key_free)(void *user_data),
    void *key_data,
    intptr_t num_measures
)
</code></pre>
<p><code>gm</code> must be a handle to a gate map object (<code>dqcs_gm_new()</code>).
<code>key_free</code> is an optional callback function used to free <code>key_data</code> when
the gate map is destroyed, or when this function fails.
<code>key_data</code> is the user-specified value used to identify this mapping.
<code>num_measures</code> specifies the number of measured qubits for this gate type.
If negative, the gate can have any number of measured qubits. If zero or
positive, the number of measured qubits must be as specified.</p>
<p>The parameterization <code>ArbData</code> object returned by detection and consumed
by construction is mapped one-to-one to the user data of the gate in the
DQCsim-protocol.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gm_add_predef_unitary()</tt></font><div style="margin-left: 16px">
<p>Adds a unitary gate mapping for the given DQCsim-defined gate to the
given gate map.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_gm_add_predef_unitary(
    dqcs_handle_t gm,
    void (*key_free)(void *user_data),
    void *key_data,
    dqcs_predefined_gate_t gate,
    intptr_t num_controls,
    double epsilon,
    bool ignore_gphase
)
</code></pre>
<p><code>gm</code> must be a handle to a gate map object (<code>dqcs_gm_new()</code>).
<code>key_free</code> is an optional callback function used to free <code>key_data</code> when
the gate map is destroyed, or when this function fails.
<code>key_data</code> is the user-specified value used to identify this mapping.
<code>gate</code> defines which predefined gate to use. Some of the predefined gates
are parameterized.
<code>num_controls</code> specifies the number of control qubits associated with this
gate type. If negative, the gate can have any number of control qubits.
If zero or positive, the number of control qubits must be as specified.
<code>epsilon</code> specifies the maximum element-wise root-mean-square error
between the incoming matrix and the to be detected matrix that results in a
positive match.
<code>ignore_phase</code> specifies whether the aforementioned check should ignore
global phase or not when there are no explicit control qubits.</p>
<p>For most gate types, the parameterization <code>ArbData</code> object returned by
detection and consumed by construction is mapped one-to-one to the user
data of the gate in the DQCsim-protocol. Some of the detectors however
detect parameterized gate matrices. These detectors prefix a fixed number
of binary string arguments to the <code>ArbData</code> upon detection, and pop these
when constructing. The specs for this can be found in the docs for
<code>dqcs_predefined_gate_t</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gm_construct()</tt></font><div style="margin-left: 16px">
<p>Uses a gate map object to construct a multi-qubit DQCsim gate from the
plugin's representation.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gm_construct(
    dqcs_handle_t gm,
    const void *key_data,
    dqcs_handle_t qubits,
    dqcs_handle_t param_data
)
</code></pre>
<p><code>gm</code> must be a handle to a gate map object (<code>dqcs_mm_new()</code>).
<code>gate</code> must be a handle to a gate. The handle is borrowed; it is not
mutated or deleted.
<code>key_data</code> specifies the gate mapping key for the constructor to use. Note
that the <em>pointer</em> must match exactly to what was specified when the
mapping(s) was/were added.
<code>qubits</code> specifies the qubits arguments for the constructed gate. It is
up to the constructor function to determine how to interpret these. The
parameter is optional; passing 0 is equivalent to passing an empty qubit
set. The handle is deleted if the function succeeds.
<code>param_data</code> specifies the <code>ArbData</code> object used to parameterize the gate.
It is optional; if 0, an empty <code>ArbData</code> is automatically constructed by
DQCsim. The handle is deleted if the function succeeds.</p>
<p>This function returns the handle to the gate, or 0 to indicate failure.
The qubit set and parameterization data (if specified) are consumed/deleted
by this function if and only if it succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gm_construct_one()</tt></font><div style="margin-left: 16px">
<p>Uses a gate map object to construct a one-qubit DQCsim gate from the
plugin's representation.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gm_construct_one(
    dqcs_handle_t gm,
    const void *key_data,
    dqcs_qubit_t qa,
    dqcs_handle_t param_data
)
</code></pre>
<p>This function is simply a shorthand for <code>dqcs_gm_construct()</code> with
one qubit in the <code>qubits</code> set, to make constructing one-qubit gates more
ergonomic. Refer to its documentation for more information.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gm_construct_three()</tt></font><div style="margin-left: 16px">
<p>Uses a gate map object to construct a three-qubit DQCsim gate from the
plugin's representation.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gm_construct_three(
    dqcs_handle_t gm,
    const void *key_data,
    dqcs_qubit_t qa,
    dqcs_qubit_t qb,
    dqcs_qubit_t qc,
    dqcs_handle_t param_data
)
</code></pre>
<p>This function is simply a shorthand for <code>dqcs_gm_construct()</code> with
three qubits in the <code>qubits</code> set, to make constructing three-qubit gates
more ergonomic. Refer to its documentation for more information.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gm_construct_two()</tt></font><div style="margin-left: 16px">
<p>Uses a gate map object to construct a two-qubit DQCsim gate from the
plugin's representation.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gm_construct_two(
    dqcs_handle_t gm,
    const void *key_data,
    dqcs_qubit_t qa,
    dqcs_qubit_t qb,
    dqcs_handle_t param_data
)
</code></pre>
<p>This function is simply a shorthand for <code>dqcs_gm_construct()</code> with
two qubits in the <code>qubits</code> set, to make constructing two-qubit gates more
ergonomic. Refer to its documentation for more information.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gm_detect()</tt></font><div style="margin-left: 16px">
<p>Uses a gate map object to convert an incoming DQCsim gate to the plugin's
representation.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_gm_detect(
    dqcs_handle_t gm,
    dqcs_handle_t gate,
    const void **key_data,
    dqcs_handle_t *qubits,
    dqcs_handle_t *param_data
)
</code></pre>
<p><code>gm</code> must be a handle to a gate map object (<code>dqcs_mm_new()</code>).
<code>gate</code> must be a handle to a gate. The handle is borrowed; it is not
mutated or deleted.
<code>key_data</code> serves as an optional return value; if non-NULL and a match is
found, the <code>key_data</code> specified when the respective detector was added is
returned here as a <code>const void *</code>. If no match is found, <code>*key_data</code> is
not assigned.
<code>qubits</code> serves as an optional return value; if non-NULL and a match
is found, it is set to a handle to a new <code>QubitSet</code> object representing the
gate's qubits. Ownership of this handle is passed to the user, so it
is up to the user to eventually delete it. If no match is found,
<code>*qubits</code> is set to 0.
<code>param_data</code> serves as an optional return value; if non-NULL and a match
is found, it is set to a handle to a new <code>ArbData</code> object representing the
gate's parameters. Ownership of this handle is passed to the user, so it
is up to the user to eventually delete it. If no match is found,
<code>*param_data</code> is set to 0.</p>
<p>This function returns <code>DQCS_TRUE</code> if a match was found, <code>DQCS_FALSE</code> if no
match was found, or <code>DQCS_BOOL_FAILURE</code> if an error occurs.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gm_new()</tt></font><div style="margin-left: 16px">
<p>Constructs a new gate map.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gm_new(
    bool strip_qubit_refs,
    bool strip_data,
    bool (*key_cmp)(
        const void,
        const void
    ),
    uint64_t (*key_hash)(const void)
)
</code></pre>
<p>Returns a handle to a gate map with no mappings attached to it yet. Use
<code>dqcs_gm_add_*()</code> to do that. The mappings are queried in the order in
which they are added, so be sure to add more specific gates first. Once
added, use <code>dqcs_gm_detect()</code> to detect incoming DQCsim gates, and
<code>dqcs_gm_construct*()</code> to (re)construct gates for transmission.</p>
<p>Gate maps objects retain a cache to speed up detection of similar DQCsim
gates: if a gate is received for the second time, the cache will hit,
avoiding recomputation of the detector functions. What constitutes
&quot;similar gates&quot; is defined by the two booleans passed to this function. If
<code>strip_qubit_refs</code> is set, all qubit references associated with the gate
will be invalidated (i.e., set to 0), such that for instance an X gate
applied to qubit 1 will be considered equal to an X gate applied to qubit
2. If <code>strip_data</code> is set, the <code>ArbData</code> associated with the incoming
gate is removed.</p>
<p>Gates are identified through user-defined <code>void*</code> keys. To do the above,
however, DQCsim needs to know the following things:</p>
<ul>
<li>how to delete an owned copy of a key if your semantics are that DQCsim
owns it,</li>
<li>how to compare two keys (equality);</li>
<li>how to hash a key.</li>
</ul>
<p>The deletion function is passed when the key is passed. If the keys are
objects of different classes, this allows different constructors to be
passed here. There can only be a single comparison and hash function for
each gate map, though. They are passed here.</p>
<p><code>key_cmp</code> represents this comparison function. It takes two <code>void*</code> to
keys and must returns whether they are equal or not. If not specified,
the default is to compare the pointers themselves, instead of the values
they refer to. <code>key_cmp</code> must be a pure function, i.e., depend only on its
input values.</p>
<p><code>key_hash</code> represents the hashing function. It takes a <code>void*</code> key and
returns a 64-bit hash representative of the key. <strong>For any pair of keys
for which <code>key_cmp</code> returns true, the hashes must be equal.</strong> The default
behavior depends on whether <code>key_cmp</code> is defined: if it is, all keys will
have the same hash; if it isn't, the pointer is itself hashed. <code>key_hash</code>
must be a pure function, i.e., depend only on its input values.</p>
<p>It is recommended to first preprocess incoming gates with
<code>dqcs_gate_reduce_control()</code>. In this case, controlled unitary gate
matrices will be reduced to their non-controlled submatrix, such that the
unitary gate detectors will operate on said submatrix. The predefined
unitary gate detectors are more-or-less based on this assumption (as there
are no predefined controlled matrices).</p>
<p>Alternatively, you can preprocess with <code>dqcs_gate_expand_control()</code>. In
this case, you can use <code>dqcs_gm_add_fixed_unitary()</code> to detect the full
matrix in all cases, by specifying the CNOT matrix instead of an X matrix
with one control qubit.</p>
<p>If you don't preprocess, the upstream plugin determines the
representation. That is, it may send a CNOT as a two-qubit gate with a
CNOT matrix or as a controlled X gate with a single target and single
control qubit. The gate map will then detect these as two different kinds
of gates.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_handle_delete()</tt></font><div style="margin-left: 16px">
<p>Destroys the object associated with a handle.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_handle_delete(dqcs_handle_t handle)
</code></pre>
<p>Returns 0 when successful, -1 otherwise.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_handle_delete_all()</tt></font><div style="margin-left: 16px">
<p>Deletes all handles for the current thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_handle_delete_all(void)
</code></pre>
<p>This can be used to clean stuff up at the end of <code>main()</code> or before an
<code>abort()</code> of some kind. If you don't clean up properly, you might get
undefined behavior or errors when DQCsim tries to do it for you.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_handle_dump()</tt></font><div style="margin-left: 16px">
<p>Returns a debug dump of the object associated with the given handle.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_handle_dump(dqcs_handle_t handle)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
description. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_handle_leak_check()</tt></font><div style="margin-left: 16px">
<p>Succeeds only if there are no live handles in the current thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_handle_leak_check(void)
</code></pre>
<p>This is intended for testing and for finding handle leaks. The error
message returned when handles remain contains dumps of the first 10
remaining handles.</p>
</div></details>
<details><summary><font color="purple"><tt>dqcs_handle_t</tt></font><div style="margin-left: 16px">
<p>Type for a handle.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef unsigned long long dqcs_handle_t;
</code></pre>
<p>Handles are like pointers into DQCsim's internal structures: all API calls
use these to refer to objects. Besides the object, they contain type
information. This type can be retrieved using <code>dqcs_handle_type()</code>.</p>
<p>Handles are always positive integers, counting upwards from 1 upon
allocation, and they are not reused even after being deleted. Thus, every
subsequent object allocation returns a handle one greater than the
previous. Note however that DQCsim may allocate objects as well without
the user specifically requesting this, so external code should generally
<em>not</em> rely on this behavior unless otherwise noted. The value zero is
reserved for invalid references or error propagation.</p>
<p>Note that the scope for handles is thread-local. That is, data referenced
by a handle cannot be shared or moved between threads.</p>
<p>The value zero is reserved for invalid references or error propagation.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_handle_type()</tt></font><div style="margin-left: 16px">
<p>Returns the type of object associated with the given handle.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_type_t dqcs_handle_type(dqcs_handle_t handle)
</code></pre>
</div></details>
<details><summary><font color="purple"><tt>dqcs_handle_type_t</tt></font><div style="margin-left: 16px">
<p>Enumeration of types that can be associated with a handle.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_handle_type_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_HTYPE_INVALID = 0</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle is invalid.
<p>This indicates one of the following:</p>
<ul>
<li>The handle value is invalid (zero or negative).</li>
<li>The handle has not been used yet.</li>
<li>The object associated with the handle was deleted.</li>
</ul>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_ARB_DATA = 100</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to an `ArbData` object.
<p>This means that the handle supports the <code>handle</code> and <code>arb</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_ARB_CMD = 101</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to an `ArbCmd` object.
<p>This means that the handle supports the <code>handle</code>, <code>arb</code>, and <code>cmd</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_ARB_CMD_QUEUE = 102</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a queue of `ArbCmd` object.
<p>This means that the handle supports the <code>handle</code>, <code>arb</code>, <code>cmd</code>, and
<code>cq</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_QUBIT_SET = 103</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a set of qubit references.
<p>This means that the handle supports the <code>handle</code> and <code>qbset</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_GATE = 104</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a quantum gate description.
<p>This means that the handle supports the <code>handle</code>, <code>gate</code>, and <code>arb</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_MEAS = 105</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a qubit measurement result.
<p>This means that the handle supports the <code>handle</code>, <code>meas</code>, and <code>arb</code>
interfaces. It can also be used in place of a qubit measurement result
set by functions that consume the object.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_MEAS_SET = 106</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a set of qubit measurement
results.
<p>This means that the handle supports the <code>handle</code> and <code>mset</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_MATRIX = 107</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a matrix.
<p>This means that the handle supports the <code>handle</code> and <code>mat</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_GATE_MAP = 108</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a gate map.
<p>This means that the handle supports the <code>handle</code> and <code>gm</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_FRONT_PROCESS_CONFIG = 200</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a frontend plugin process
configuration object.
<p>This means that the handle supports the <code>handle</code>, <code>pcfg</code>, and <code>xcfg</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_OPER_PROCESS_CONFIG = 201</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to an operator plugin process
configuration object.
<p>This means that the handle supports the <code>handle</code>, <code>pcfg</code>, and <code>xcfg</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_BACK_PROCESS_CONFIG = 203</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a backend plugin process
configuration object.
<p>This means that the handle supports the <code>handle</code>, <code>pcfg</code>, and <code>xcfg</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_FRONT_THREAD_CONFIG = 204</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a frontend plugin thread
configuration object.
<p>This means that the handle supports the <code>handle</code>, <code>tcfg</code>, and <code>xcfg</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_OPER_THREAD_CONFIG = 205</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to an operator plugin thread
configuration object.
<p>This means that the handle supports the <code>handle</code>, <code>tcfg</code>, and <code>xcfg</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_BACK_THREAD_CONFIG = 206</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a backend plugin thread
configuration object.
<p>This means that the handle supports the <code>handle</code>, <code>tcfg</code>, and <code>xcfg</code>
interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_SIM_CONFIG = 207</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a simulator configuration
object.
<p>This means that the handle supports the <code>handle</code> and <code>scfg</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_SIM = 208</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a simulator instance.
<p>This means that the handle supports the <code>handle</code> and <code>sim</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_FRONT_DEF = 300</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a frontend plugin
definition object.
<p>This means that the handle supports the <code>handle</code> and <code>pdef</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_OPER_DEF = 301</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to an operator plugin
definition object.
<p>This means that the handle supports the <code>handle</code> and <code>pdef</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_BACK_DEF = 302</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a backend plugin
definition object.
<p>This means that the handle supports the <code>handle</code> and <code>pdef</code> interfaces.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_HTYPE_PLUGIN_JOIN = 303</tt></font></summary><div style="margin-left: 16px">
Indicates that the given handle belongs to a plugin thread join handle.
<p>This means that the handle supports the <code>handle</code> and <code>pjoin</code>
interfaces.</p>
</div></details>
</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_debug()</tt></font><div style="margin-left: 16px">
<p>Convenience macro for calling <code>dqcs_log_format()</code> with debug loglevel and
automatically determined function name, filename, and line number.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">#define dqcs_log_debug(fmt, ...)                \
  dqcs_log_format(                              \
    _DQCSIM_LOGLEVEL_PREFIX_ DQCS_LOG_DEBUG,    \
    _DQCSIM_LANGUAGE_,                          \
    __FILE__,                                   \
    __LINE__,                                   \
    fmt,                                        \
    ##__VA_ARGS__                               \
  )
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_error()</tt></font><div style="margin-left: 16px">
<p>Convenience macro for calling <code>dqcs_log_format()</code> with error loglevel and
automatically determined function name, filename, and line number.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">#define dqcs_log_error(fmt, ...)                \
  dqcs_log_format(                              \
    _DQCSIM_LOGLEVEL_PREFIX_ DQCS_LOG_ERROR,    \
    _DQCSIM_LANGUAGE_,                          \
    __FILE__,                                   \
    __LINE__,                                   \
    fmt,                                        \
    ##__VA_ARGS__                               \
  )
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_fatal()</tt></font><div style="margin-left: 16px">
<p>Convenience macro for calling <code>dqcs_log_format()</code> with fatal loglevel and
automatically determined function name, filename, and line number.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">#define dqcs_log_fatal(fmt, ...)                \
  dqcs_log_format(                              \
    _DQCSIM_LOGLEVEL_PREFIX_ DQCS_LOG_FATAL,    \
    _DQCSIM_LANGUAGE_,                          \
    __FILE__,                                   \
    __LINE__,                                   \
    fmt,                                        \
    ##__VA_ARGS__                               \
  )
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_format()</tt></font><div style="margin-left: 16px">
<p>Sends a log message using the current logger using printf-like formatting.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">static void dqcs_log_format(
    dqcs_loglevel_t level,
    const char *module,
    const char *file,
    uint32_t line,
    const char *fmt,
    ...
)
</code></pre>
<p>This function is identical to <code>dqcs_log_raw()</code>, except instead of a single
string it takes a printf-like format string and varargs to compose the
message.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_info()</tt></font><div style="margin-left: 16px">
<p>Convenience macro for calling <code>dqcs_log_format()</code> with info loglevel and
automatically determined function name, filename, and line number.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">#define dqcs_log_info(fmt, ...)                 \
  dqcs_log_format(                              \
    _DQCSIM_LOGLEVEL_PREFIX_ DQCS_LOG_INFO,     \
    _DQCSIM_LANGUAGE_,                          \
    __FILE__,                                   \
    __LINE__,                                   \
    fmt,                                        \
    ##__VA_ARGS__                               \
  )
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_note()</tt></font><div style="margin-left: 16px">
<p>Convenience macro for calling <code>dqcs_log_format()</code> with note loglevel and
automatically determined function name, filename, and line number.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">#define dqcs_log_note(fmt, ...)                 \
  dqcs_log_format(                              \
    _DQCSIM_LOGLEVEL_PREFIX_ DQCS_LOG_NOTE,     \
    _DQCSIM_LANGUAGE_,                          \
    __FILE__,                                   \
    __LINE__,                                   \
    fmt,                                        \
    ##__VA_ARGS__                               \
  )
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_raw()</tt></font><div style="margin-left: 16px">
<p>Primitive API for sending a log message using the current logger.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_log_raw(
    dqcs_loglevel_t level,
    const char *module,
    const char *file,
    uint32_t line_nr,
    const char *message
)
</code></pre>
<p>Returns <code>DQCS_SUCCESS</code> if logging was successful, or <code>DQCS_FAILURE</code> if no
logger is available in the current thread or one of the arguments could not
be converted. Loggers are available in the simulation host thread and in
threads running plugins.</p>
<h3><a class="header" href="#formatting-and-fallback-to-stderr" id="formatting-and-fallback-to-stderr">Formatting and fallback to stderr</a></h3>
<p>As an alternative to this function, you can also use <code>dqcs_log_format()</code>.
This function differs from <code>dqcs_log_raw()</code> in two ways:</p>
<ul>
<li>Instead of the <code>message</code> string, a printf-style format string and
associated varargs are passed to construct the message.</li>
<li>When logging fails, this function falls back to writing to <code>stderr</code>
instead of returning the errors.</li>
</ul>
<h3><a class="header" href="#macros" id="macros">Macros</a></h3>
<p>From C and C++, these functions are normally not called directly. Instead,
the following macros are used:</p>
<pre><code class="language-C">dqcs_log_trace(&quot;trace message!&quot;);
dqcs_log_debug(&quot;debug message!&quot;);
dqcs_log_info(&quot;info message!&quot;);
dqcs_log_note(&quot;notice!&quot;);
dqcs_log_warn(&quot;warning!&quot;);
dqcs_log_error(&quot;error!&quot;);
dqcs_log_fatal(&quot;fatal error!&quot;);
</code></pre>
<p>These macros automatically set <code>file</code> to the C source filename and <code>line</code>
to the line number. <code>module</code> is hardcoded to &quot;C&quot; or &quot;CPP&quot; depending on
source file language. They use <code>dqcs_log_format()</code>, so they also support
printf-style formatting. For instance:</p>
<pre><code class="language-C">dqcs_note(&quot;answer to %s: %d&quot;, &quot;ultimate question&quot;, 42);
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_trace()</tt></font><div style="margin-left: 16px">
<p>Convenience macro for calling <code>dqcs_log_format()</code> with trace loglevel and
automatically determined function name, filename, and line number.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">#define dqcs_log_trace(fmt, ...)                \
  dqcs_log_format(                              \
    _DQCSIM_LOGLEVEL_PREFIX_ DQCS_LOG_TRACE,    \
    _DQCSIM_LANGUAGE_,                          \
    __FILE__,                                   \
    __LINE__,                                   \
    fmt,                                        \
    ##__VA_ARGS__                               \
  )
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_log_warn()</tt></font><div style="margin-left: 16px">
<p>Convenience macro for calling <code>dqcs_log_format()</code> with warn loglevel and
automatically determined function name, filename, and line number.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">#define dqcs_log_warn(fmt, ...)                 \
  dqcs_log_format(                              \
    _DQCSIM_LOGLEVEL_PREFIX_ DQCS_LOG_WARN,     \
    _DQCSIM_LANGUAGE_,                          \
    __FILE__,                                   \
    __LINE__,                                   \
    fmt,                                        \
    ##__VA_ARGS__                               \
  )
</code></pre>
</div></details>
<details><summary><font color="purple"><tt>dqcs_loglevel_t</tt></font><div style="margin-left: 16px">
<p>Enumeration of loglevels and logging modes.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_loglevel_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_LOG_INVALID = -1</tt></font></summary><div style="margin-left: 16px">
Invalid loglevel. Used to indicate failure of an API that returns a
loglevel.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_OFF = 0</tt></font></summary><div style="margin-left: 16px">
Turns logging off.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_FATAL = 1</tt></font></summary><div style="margin-left: 16px">
This loglevel is to be used for reporting a fatal error, resulting from
the owner of the logger getting into an illegal state from which it
cannot recover. Such problems are also reported to the API caller via
Result::Err if applicable.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_ERROR = 2</tt></font></summary><div style="margin-left: 16px">
This loglevel is to be used for reporting or propagating a non-fatal
error caused by the API caller doing something wrong. Such problems are
also reported to the API caller via Result::Err if applicable.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_WARN = 3</tt></font></summary><div style="margin-left: 16px">
This loglevel is to be used for reporting that a called API/function is
telling us we did something wrong (that we weren't expecting), but we
can recover. For instance, for a failed connection attempt to something
that really should not be failing, we can still retry (and eventually
report critical or error if a retry counter overflows). Since we're
still trying to rectify things at this point, such problems are NOT
reported to the API/function caller via Result::Err.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_NOTE = 4</tt></font></summary><div style="margin-left: 16px">
This loglevel is to be used for reporting information specifically
requested by the user/API caller, such as the result of an API function
requested through the command line, or an explicitly captured
stdout/stderr stream.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_INFO = 5</tt></font></summary><div style="margin-left: 16px">
This loglevel is to be used for reporting information NOT specifically
requested by the user/API caller, such as a plugin starting up or
shutting down.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_DEBUG = 6</tt></font></summary><div style="margin-left: 16px">
This loglevel is to be used for reporting debugging information useful
for debugging the user of the API provided by the logged instance.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_TRACE = 7</tt></font></summary><div style="margin-left: 16px">
This loglevel is to be used for reporting debugging information useful
for debugging the internals of the logged instance. Such messages would
normally only be generated by debug builds, to prevent them from
impacting performance under normal circumstances.
</div></details>
<details><summary><font color="blue"><tt>DQCS_LOG_PASS = 8</tt></font></summary><div style="margin-left: 16px">
This is intended to be used when configuring the stdout/stderr capture
mode for a plugin process. Selecting it will prevent the stream from
being captured; it will just be the same stream as DQCsim's own
stdout/stderr. When used as the loglevel for a message, the message
itself is sent to stderr instead of passing into DQCsim's log system.
Using this for loglevel filters leads to undefined behavior.
</div></details>
</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_mat_add_controls()</tt></font><div style="margin-left: 16px">
<p>Constructs a controlled matrix from the given matrix.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_mat_add_controls(
    dqcs_handle_t mat,
    size_t number_of_controls
)
</code></pre>
<p><code>mat</code> specifies the matrix to use as the non-controlled submatrix. This
is a borrowed handle. <code>number_of_controls</code> specifies the number of control
qubits to add. This function returns a new matrix handle with the
constructed matrix, or 0 if it fails.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_mat_approx_eq()</tt></font><div style="margin-left: 16px">
<p>Approximately compares two matrices.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_mat_approx_eq(
    dqcs_handle_t a,
    dqcs_handle_t b,
    double epsilon,
    bool ignore_gphase
)
</code></pre>
<p><code>a</code> and <code>b</code> are borrowed matrix handles.
<code>epsilon</code> specifies the maximum element-wise root-mean-square error
between the matrices that results in a positive match. <code>ignore_gphase</code>
specifies whether the check should ignore global phase.</p>
<p>This function returns <code>DQCS_TRUE</code> if the matrices match according to the
aforementioned criteria, or <code>DQCS_FALSE</code> if not. <code>DQCS_BOOL_ERROR</code> is used
when either handle is invalid or not a matrix. If the matrices differ in
dimensionality, <code>DQCS_FALSE</code> is used.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_mat_dimension()</tt></font><div style="margin-left: 16px">
<p>Returns the dimension (number of rows == number of columns) of the given
matrix.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_mat_dimension(dqcs_handle_t mat)
</code></pre>
<p>This function returns -1 when an error occurs.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_mat_get()</tt></font><div style="margin-left: 16px">
<p>Returns a copy of the contained matrix as a C array.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">double *dqcs_mat_get(dqcs_handle_t mat)
</code></pre>
<p>If this function succeeds, the matrix is returned in row-major form, using
pairs of doubles for the real vs. imaginary component of each entry. The
size will be <code>4**num_qubits</code> complex numbers = <code>2*4**num_qubits</code> doubles =
<code>16*4**num_qubits</code> bytes. A newly allocated matrix is returned; <strong>free it
with <code>free()</code> when you're done with it to avoid memory leaks.</strong> On failure,
this function returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_mat_is_predef()</tt></font><div style="margin-left: 16px">
<p>Returns whether this matrix is of the given predefined form and, if it is,
any parameters needed to describe it.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_mat_is_predef(
    dqcs_handle_t mat,
    dqcs_predefined_gate_t gate_type,
    dqcs_handle_t *param_data,
    double epsilon,
    bool ignore_gphase
)
</code></pre>
<p><code>mat</code> is a borrowed handle to the matrix to check.
<code>gate_type</code> specifies which kind of gate should be detected.
<code>param_data</code>, if non-null, receives a new <code>ArbData</code> handle with
parameterization data, or an empty <code>ArbData</code> if the gate is not
parameterized; the caller must delete this object when it is done with
it. This function always writes the 0 handle to this return parameter if
it fails. The <code>ArbData</code> representation can be found in the documentation
for <code>dqcs_predefined_gate_t</code>.</p>
<p><code>epsilon</code> specifies the maximum element-wise root-mean-square error
between the matrices that results in a positive match. <code>ignore_gphase</code>
specifies whether the check should ignore global phase.</p>
<p>This function returns <code>DQCS_TRUE</code> if the matrices match according to the
aforementioned criteria, or <code>DQCS_FALSE</code> if not. <code>DQCS_BOOL_ERROR</code> is used
when either handle is invalid or not a matrix. If the matrices differ in
dimensionality, <code>DQCS_FALSE</code> is used.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_mat_len()</tt></font><div style="margin-left: 16px">
<p>Returns the number of complex entries in the given matrix.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_mat_len(dqcs_handle_t mat)
</code></pre>
<p>This function returns -1 when an error occurs.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_mat_new()</tt></font><div style="margin-left: 16px">
<p>Constructs a new gate matrix.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_mat_new(
    size_t num_qubits,
    const double *matrix
)
</code></pre>
<p><code>num_qubits</code> must be set to the number of qubits mutated by this matrix.
It must be greater than or equal to zero.
<code>matrix</code> must point to an appropriately sized array of doubles. The matrix
is specified in row-major form, using pairs of doubles for the real vs.
imaginary component of each entry. The size must be <code>4**num_qubits</code> complex
numbers = <code>2*4**num_qubits</code> doubles = <code>16*4**num_qubits</code> bytes,
representing a <code>2**num_qubits</code> by <code>2**num_qubits</code> matrix.
This function returns the constructed matrix handle, or 0 if an error
occurs.</p>
<p>While not enforced at this level, the matrix is normally unitary, or
approximately so within some floating-point error margin.</p>
<p>This function returns the handle to the matrix, or 0 to indicate failure.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_mat_num_qubits()</tt></font><div style="margin-left: 16px">
<p>Returns the number of qubits targeted by the given matrix.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_mat_num_qubits(dqcs_handle_t mat)
</code></pre>
<p>This function returns -1 when an error occurs.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_mat_predef()</tt></font><div style="margin-left: 16px">
<p>Constructs a new gate matrix for one of DQCsim's predefined gates.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_mat_predef(
    dqcs_predefined_gate_t gate_type,
    dqcs_handle_t param_data
)
</code></pre>
<p><code>gate_type</code> specifies which kind of gate should be constructed.</p>
<p><code>param_data</code> takes an optional <code>ArbData</code> object used to parameterize the
matrix if necessary. If not specified, an empty object is used. The
<code>ArbData</code> representation for each gate can be found in the docs for
<code>dqcs_predefined_gate_t</code>. If nothing is specified, no <code>ArbData</code> is used.</p>
<p>This function returns the handle to the matrix, or 0 to indicate failure.
The parameterization data (if specified) is consumed/deleted by this
function if and only if it succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_mat_strip_control()</tt></font><div style="margin-left: 16px">
<p>Splits a controlled matrix into its non-controlled submatrix and the
indices of the control qubits.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_mat_strip_control(
    dqcs_handle_t mat,
    double epsilon,
    bool ignore_global_phase,
    ssize_t **control_indices
)
</code></pre>
<p><code>mat</code> specifies the matrix to modify. This is a borrowed handle.
<code>epsilon</code> specifies the maximum magitude of the difference between the
column vectors of the input matrix and the identity matrix (after
dephasing if <code>ignore_gphase</code> is set) for the column vector to be
considered to not affect the respective entry in the quantum state
vector. Note that if this is greater than zero, the resulting gate may
not be exactly equivalent. If <code>ignore_global_phase</code> is set, any global
phase in the matrix is ignored, but note that if control qubits are
stripped the &quot;global&quot; phase of the resulting submatrix is always
significant.
<code>control_indices</code> is a return argument through which DQCsim will pass
the indices of the qubits that were removed in the process of constructing
the submatrix. This is represented as an array of indices terminated by
a -1 entry. The returned matrix <strong>must be freed using <code>free()</code> when you
are done with it to avoid memory leaks.</strong> This function returns a new
matrix handle with the submatrix, or 0 if it fails. In this case,
<code>control_indices</code> is not mutated.</p>
<p>This function assumes that the incoming matrix is unitary (within
<code>epsilon</code>) without verifying that this is the case. The results may
thus be invalid if it was not.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_meas_new()</tt></font><div style="margin-left: 16px">
<p>Constructs a new measurement object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_meas_new(
    dqcs_qubit_t qubit,
    dqcs_measurement_t value
)
</code></pre>
<p><code>qubit</code> must be set to the qubit that was measured, <code>value</code> must be set to
its value. The return value is the handle to the measurement object, or 0
if something went wrong.</p>
<p>Note that measurement objects implement the <code>arb</code> interface, so additional
data can be attached to the object.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_meas_qubit_get()</tt></font><div style="margin-left: 16px">
<p>Returns the qubit reference associated with a measurement object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_qubit_t dqcs_meas_qubit_get(dqcs_handle_t meas)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_meas_qubit_set()</tt></font><div style="margin-left: 16px">
<p>Sets the qubit reference associated with a measurement object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_meas_qubit_set(
    dqcs_handle_t meas,
    dqcs_qubit_t qubit
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_meas_value_get()</tt></font><div style="margin-left: 16px">
<p>Returns the measurement value associated with a measurement object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_measurement_t dqcs_meas_value_get(dqcs_handle_t meas)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_meas_value_set()</tt></font><div style="margin-left: 16px">
<p>Sets the measurement value associated with a measurement object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_meas_value_set(
    dqcs_handle_t meas,
    dqcs_measurement_t value
)
</code></pre>
</div></details>
<details><summary><font color="purple"><tt>dqcs_measurement_t</tt></font><div style="margin-left: 16px">
<p>Qubit measurement value.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_measurement_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_MEAS_INVALID = -1</tt></font></summary><div style="margin-left: 16px">
Error value used to indicate that something went wrong.
</div></details>
<details><summary><font color="blue"><tt>DQCS_MEAS_ZERO = 0</tt></font></summary><div style="margin-left: 16px">
Indicates that the qubit was measured to be zero.
</div></details>
<details><summary><font color="blue"><tt>DQCS_MEAS_ONE = 1</tt></font></summary><div style="margin-left: 16px">
Indicates that the qubit was measured to be one.
</div></details>
<details><summary><font color="blue"><tt>DQCS_MEAS_UNDEFINED = 2</tt></font></summary><div style="margin-left: 16px">
Indicates that the measurement value is unknown for whatever reason.
</div></details>
</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_mset_contains()</tt></font><div style="margin-left: 16px">
<p>Returns whether the given qubit measurement set contains data for the given
qubit.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_mset_contains(
    dqcs_handle_t mset,
    dqcs_qubit_t qubit
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_mset_get()</tt></font><div style="margin-left: 16px">
<p>Returns a copy of the measurement result for the given qubit from a
measurement result set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_mset_get(
    dqcs_handle_t mset,
    dqcs_qubit_t qubit
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_mset_len()</tt></font><div style="margin-left: 16px">
<p>Returns the number of qubits measurements in the given measurement set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_mset_len(dqcs_handle_t mset)
</code></pre>
<p>This function returns -1 to indicate failure.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_mset_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new set of qubit measurement results.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_mset_new(void)
</code></pre>
<p>Returns the handle of the newly created set. The set is initially empty.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_mset_remove()</tt></font><div style="margin-left: 16px">
<p>Removes the measurement result for the given qubit from a measurement
result set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_mset_remove(
    dqcs_handle_t mset,
    dqcs_qubit_t qubit
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_mset_set()</tt></font><div style="margin-left: 16px">
<p>Adds a measurement result to a measurement result set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_mset_set(
    dqcs_handle_t mset,
    dqcs_handle_t meas
)
</code></pre>
<p>If there was already a measurement for the specified qubit, the previous
measurement result is overwritten. The measurement result object is deleted
if and only if the function succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_mset_take()</tt></font><div style="margin-left: 16px">
<p>Returns the measurement result for the given qubit from a measurement
result set and removes it from the set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_mset_take(
    dqcs_handle_t mset,
    dqcs_qubit_t qubit
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_mset_take_any()</tt></font><div style="margin-left: 16px">
<p>Returns the measurement result for any of the qubits contained in a
measurement result set and removes it from the set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_mset_take_any(dqcs_handle_t mset)
</code></pre>
<p>This is useful for iteration.</p>
</div></details>
<details><summary><font color="purple"><tt>dqcs_path_style_t</tt></font><div style="margin-left: 16px">
<p>Reproduction file path style.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_path_style_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_PATH_STYLE_INVALID = -1</tt></font></summary><div style="margin-left: 16px">
Error value used to indicate that something went wrong.
</div></details>
<details><summary><font color="blue"><tt>DQCS_PATH_STYLE_KEEP = 0</tt></font></summary><div style="margin-left: 16px">
Specifies that paths should be saved the same way they were specified
on the command line.
</div></details>
<details><summary><font color="blue"><tt>DQCS_PATH_STYLE_RELATIVE = 1</tt></font></summary><div style="margin-left: 16px">
Specifies that all paths should be saved relative to DQCsim's working
directory.
</div></details>
<details><summary><font color="blue"><tt>DQCS_PATH_STYLE_ABSOLUTE = 2</tt></font></summary><div style="margin-left: 16px">
Specifies that all paths should be saved canonically, i.e. relative to
the root directory.
</div></details>
</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_accept_timeout_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured timeout for the plugin process to connect to DQCsim.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">double dqcs_pcfg_accept_timeout_get(dqcs_handle_t pcfg)
</code></pre>
<p>The time unit is in seconds. Returns positive inifinity for an infinite
timeout. Returns -1 when the function fails.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_accept_timeout_set()</tt></font><div style="margin-left: 16px">
<p>Configures the timeout for the plugin process to connect to DQCsim.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_accept_timeout_set(
    dqcs_handle_t pcfg,
    double timeout
)
</code></pre>
<p>The default is 5 seconds, so you should normally be able to leave this
alone.</p>
<p>The time unit is seconds. Use IEEE positive infinity to specify an infinite
timeout.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_env_set()</tt></font><div style="margin-left: 16px">
<p>Overrides an environment variable for the plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_env_set(
    dqcs_handle_t pcfg,
    const char *key,
    const char *value
)
</code></pre>
<p>The environment variable <code>key</code> is set to <code>value</code> regardless of whether it
exists in the parent environment variable scope.</p>
<p>If value is <code>NULL</code>, the environment variable <code>key</code> is unset instead.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_env_unset()</tt></font><div style="margin-left: 16px">
<p>Removes/unsets an environment variable for the plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_env_unset(
    dqcs_handle_t pcfg,
    const char *key
)
</code></pre>
<p>The environment variable <code>key</code> is unset regardless of whether it exists in
the parent environment variable scope.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_executable()</tt></font><div style="margin-left: 16px">
<p>Returns the configured executable path for the given plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_pcfg_executable(dqcs_handle_t pcfg)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
executable path. Free it with <code>free()</code> when you're done with it to avoid
memory leaks.</strong> On failure (i.e., the handle is invalid) this returns
<code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_init_cmd()</tt></font><div style="margin-left: 16px">
<p>Appends an <code>ArbCmd</code> to the list of initialization commands of a plugin
process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_init_cmd(
    dqcs_handle_t pcfg,
    dqcs_handle_t cmd
)
</code></pre>
<p>The <code>ArbCmd</code> handle is consumed by this function, and is thus invalidated,
if and only if it is successful.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_name()</tt></font><div style="margin-left: 16px">
<p>Returns the configured name for the given plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_pcfg_name(dqcs_handle_t pcfg)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
name. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new plugin process configuration object using sugared syntax.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_pcfg_new(
    dqcs_plugin_type_t typ,
    const char *name,
    const char *spec
)
</code></pre>
<p><code>typ</code> specifies the type of plugin. <code>name</code> specifies the name used to refer
to the plugin later, which much be unique within a simulation; if it is
empty or <code>NULL</code>, auto-naming will be performed: &quot;front&quot; for the frontend,
&quot;oper&lt;i&gt;&quot; for the operators (indices starting at 1 from frontend to
backend), and &quot;back&quot; for the backend. <code>spec</code> specifies which plugin to use,
using the same syntax that the <code>dqcsim</code> command line interface uses.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_new_raw()</tt></font><div style="margin-left: 16px">
<p>Creates a new plugin process configuration object using raw paths.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_pcfg_new_raw(
    dqcs_plugin_type_t typ,
    const char *name,
    const char *executable,
    const char *script
)
</code></pre>
<p>This works the same as <code>dqcs_pcfg_new()</code>, but instead of the sugared,
command-line style specification you have to specify the path to the plugin
executable and (if applicable) the script it must execute directly. This is
useful when you have a specific executable in mind and you don't want the
somewhat heuristic desugaring algorithm from doing something unexpected.</p>
<p>Pass <code>NULL</code> or an empty string to <code>script</code> to specify a native plugin
executable that does not take a script argument.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_script()</tt></font><div style="margin-left: 16px">
<p>Returns the configured script path for the given plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_pcfg_script(dqcs_handle_t pcfg)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
script path. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>. An
empty string will be returned if no script is configured to distinguish it
from failure.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_shutdown_timeout_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured timeout for the plugin process to shut down
gracefully.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">double dqcs_pcfg_shutdown_timeout_get(dqcs_handle_t pcfg)
</code></pre>
<p>The time unit is in seconds. Returns positive inifinity for an infinite
timeout. Returns -1 when the function fails.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_shutdown_timeout_set()</tt></font><div style="margin-left: 16px">
<p>Configures the timeout for the plugin process to shut down gracefully.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_shutdown_timeout_set(
    dqcs_handle_t pcfg,
    double timeout
)
</code></pre>
<p>The default is 5 seconds, so you should normally be able to leave this
alone.</p>
<p>The time unit is seconds. Use IEEE positive infinity to specify an infinite
timeout.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_stderr_mode_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured stderr capture mode for the specified plugin
process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_loglevel_t dqcs_pcfg_stderr_mode_get(dqcs_handle_t pcfg)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_stderr_mode_set()</tt></font><div style="margin-left: 16px">
<p>Configures the capture mode for the stderr stream of the specified plugin
process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_stderr_mode_set(
    dqcs_handle_t pcfg,
    dqcs_loglevel_t level
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_stdout_mode_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured stdout capture mode for the specified plugin
process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_loglevel_t dqcs_pcfg_stdout_mode_get(dqcs_handle_t pcfg)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_stdout_mode_set()</tt></font><div style="margin-left: 16px">
<p>Configures the capture mode for the stdout stream of the specified plugin
process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_stdout_mode_set(
    dqcs_handle_t pcfg,
    dqcs_loglevel_t level
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_tee()</tt></font><div style="margin-left: 16px">
<p>Configures a plugin process to also output its log messages to a file.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_tee(
    dqcs_handle_t pcfg,
    dqcs_loglevel_t verbosity,
    const char *filename
)
</code></pre>
<p><code>verbosity</code> configures the verbosity level for the file only.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_type()</tt></font><div style="margin-left: 16px">
<p>Returns the type of the given plugin process configuration.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_plugin_type_t dqcs_pcfg_type(dqcs_handle_t pcfg)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_verbosity_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured verbosity for the given plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_loglevel_t dqcs_pcfg_verbosity_get(dqcs_handle_t pcfg)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_verbosity_set()</tt></font><div style="margin-left: 16px">
<p>Configures the logging verbosity for the given plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_verbosity_set(
    dqcs_handle_t pcfg,
    dqcs_loglevel_t level
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_work_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured working directory for the given plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_pcfg_work_get(dqcs_handle_t pcfg)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
working directory. Free it with <code>free()</code> when you're done with it to avoid
memory leaks.</strong> On failure (i.e., the handle is invalid) this returns
<code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pcfg_work_set()</tt></font><div style="margin-left: 16px">
<p>Overrides the working directory for the plugin process.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pcfg_work_set(
    dqcs_handle_t pcfg,
    const char *work
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_author()</tt></font><div style="margin-left: 16px">
<p>Returns the plugin author for the given plugin definition object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_pdef_author(dqcs_handle_t pdef)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_name()</tt></font><div style="margin-left: 16px">
<p>Returns the plugin name for the given plugin definition object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_pdef_name(dqcs_handle_t pdef)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new <code>PluginDefinition</code> object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_pdef_new(
    dqcs_plugin_type_t typ,
    const char *name,
    const char *author,
    const char *version
)
</code></pre>
<p>Plugin definitions contain the callback functions/closures that define the
functionality of a plugin. They also contain some metadata to identify the
implementation, in the form of a name, author, and version string, that
must be specified when the definition is constructed. The callback
functions/closures are initialized to sane defaults for the requested
plugin type, but obviously one or more of these should be overridden to
make the plugin do something.</p>
<p>Once a definition object has been built, it can be used to spawn a plugin
thread or run a plugin in the main thread, given a DQCsim server URL for it
to connect to.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_advance_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the callback for advancing time for operators and backends.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_advance_cb(
    dqcs_handle_t pdef,
    dqcs_return_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_cycle_t cycles
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>The default behavior for operators is to pass through to
<code>dqcs_plugin_advance()</code>. The default for backends is no-op. This
callback is never called for frontend plugins.</p>
<p>Besides the common arguments, the callback receives an unsigned integer
specifying the number of cycles to advance by.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning <code>DQCS_FAILURE</code>. Otherwise, it should
return <code>DQCS_SUCCESS</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_allocate_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the qubit allocation callback for operators and backends.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_allocate_cb(
    dqcs_handle_t pdef,
    dqcs_return_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t qubits,
        dqcs_handle_t alloc_cmds
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>The default for operators is to pass through to
<code>dqcs_plugin_allocate()</code>. The default for backends is no-op. This
callback is never called for frontend plugins.</p>
<p>Besides the common arguments, the callback receives a handle to a qubit
set containing the references that are to be used for the
to-be-allocated qubits and an <code>ArbCmd</code> queue containing user-defined
commands to optionally augment the behavior of the qubits. These are
borrowed handles; the caller will delete them.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning <code>DQCS_FAILURE</code>. Otherwise, it should
return <code>DQCS_SUCCESS</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_drop_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the user logic drop/cleanup callback.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_drop_cb(
    dqcs_handle_t pdef,
    dqcs_return_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>This is called when a plugin is gracefully terminated. It is not
recommended to execute any downstream instructions at this time, but it
is supported in case this is really necessary.</p>
<p>The default behavior is no-op.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning <code>DQCS_FAILURE</code>. Otherwise, it should
return <code>DQCS_SUCCESS</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_free_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the qubit deallocation callback for operators and backends.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_free_cb(
    dqcs_handle_t pdef,
    dqcs_return_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t qubits
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>The default for operators is to pass through to <code>dqcs_plugin_free()</code>.
The default for backends is no-op. This callback is never called for
frontend plugins.</p>
<p>Besides the common arguments, the callback receives a handle to a qubit
set containing the qubits that are to be freed. This is a borrowed
handle; the caller will delete it.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning <code>DQCS_FAILURE</code>. Otherwise, it should
return <code>DQCS_SUCCESS</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_gate_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the gate execution callback for operators and backends.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_gate_cb(
    dqcs_handle_t pdef,
    dqcs_handle_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t gate
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>Besides the common arguments, the callback receives a handle to the
to-be-executed gate. This is a borrowed handle; the caller will delete
it.</p>
<p>The callback must return one of the following things:</p>
<ul>
<li>a valid handle to a measurement set, created using
<code>dqcs_mset_new()</code> (this object is automatically deleted after the
callback returns);</li>
<li>a valid handle to a single qubit measurement, created using
<code>dqcs_meas_new()</code> (this object is automatically deleted after the
callback returns);</li>
<li>the handle to the supplied gate, a shortcut for not returning any
measurements (this is less clear than returning an empty measurement
set, but slightly faster); or</li>
<li>0 to report an error, after calling the error string using
<code>dqcs_set_error()</code>.</li>
</ul>
<p>Backend plugins must return a measurement result set containing exactly
those qubits specified in the measurement set. For operators, however,
the story is more complicated. Let's say we want to make a silly
operator that inverts all measurements. The trivial way to do
this would be to forward the gate, query all the measurement results
using <code>dqcs_plugin_get_measurement()</code>, invert them, stick them in a
measurement result set, and return that result set. However, this
approach is not very efficient, because <code>dqcs_plugin_get_measurement()</code>
has to wait for all downstream plugins to finish executing the gate,
forcing the OS to switch threads, etc. Instead, operators are allowed
to return only a subset (or none) of the measured qubits, as long as
they return the measurements as they arrive through the
<code>modify_measurement()</code> callback.</p>
<p>The default implementation for this callback for operators is to pass
the gate through to the downstream plugin and return an empty set of
measurements. Combined with the default implementation of
<code>modify_measurement()</code>, this behavior is sane. Backends must override
this callback; the default is to return a not-implemented error.</p>
<p>Note that for our silly example operator, the default behavior for this
function is sufficient; you'd only have to override
<code>modify_measurement()</code> to, well, modify the measurements.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_host_arb_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the callback function function for handling an arb from the host.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_host_arb_cb(
    dqcs_handle_t pdef,
    dqcs_handle_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t cmd
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>The default behavior for this is no-op.</p>
<p>Besides the common arguments, the callback receives a handle to the
<code>ArbCmd</code> object representing the request. It must return a valid
<code>ArbData</code> handle containing the response. Both objects are deleted
automatically after invocation.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning 0. Otherwise, it should return a valid
<code>ArbData</code> handle.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_initialize_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the user logic initialization callback.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_initialize_cb(
    dqcs_handle_t pdef,
    dqcs_return_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t init_cmds
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>This is always called before any of the other callbacks are run. The
downstream plugin has already been initialized at this stage, so it is
legal to send it commands.</p>
<p>The default behavior is no-op.</p>
<p>Besides the common arguments, the callback receives a handle to an
<code>ArbCmd</code> queue (<code>dqcs_cq_*</code>, <code>dqcs_cmd_*</code>, and <code>dqcs_arb_*</code> interfaces)
containing user-defined initialization commands. This is a borrowed
handle; the caller will delete it.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning <code>DQCS_FAILURE</code>. Otherwise, it should
return <code>DQCS_SUCCESS</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_modify_measurement_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the measurement modification callback for operators.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_modify_measurement_cb(
    dqcs_handle_t pdef,
    dqcs_handle_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t meas
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>This callback is called for every measurement result received from the
downstream plugin, and returns the measurements that should be reported
to the upstream plugin. Note that the results from our plugin's
<code>dqcs_plugin_get_measurement()</code> and friends are consistent with the
results received from downstream; they are not affected by this
function.</p>
<p>The callback takes a handle to a single qubit measurement object as an
argument, and must return one of the following things:</p>
<ul>
<li>a valid handle to a measurement set, created using
<code>dqcs_mset_new()</code> (this object is automatically deleted after the
callback returns);</li>
<li>a valid handle to a single qubit measurement object, which may or
may not be the supplied one (this object is automatically deleted
after the callback returns); or</li>
<li>0 to report an error, after calling the error string using
<code>dqcs_set_error()</code>.</li>
</ul>
<p>This callback is somewhat special in that it is not allowed to call
any plugin command other than logging and the pseudorandom number
generator functions. This is because this function is called
asynchronously with respect to the downstream functions, making the
timing of these calls non-deterministic based on operating system
scheduling.</p>
<p>Note that while this function is called for only a single measurement
at a time, it is allowed to produce a vector of measurements. This
allows you to cancel propagation of the measurement by returning an
empty vector, to just modify the measurement data itself, or to
generate additional measurements from a single measurement. However,
if you need to modify the qubit references for operators that remap
qubits, take care to only send measurement data upstream when these
were explicitly requested through the associated upstream gate
function's <code>measured</code> list.</p>
<p>The default behavior for this callback is to return the measurement
without modification.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_run_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the run callback for frontends.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_run_cb(
    dqcs_handle_t pdef,
    dqcs_handle_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t args
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>This is called in response to a <code>start()</code> host API call. The return
value is returned through the <code>wait()</code> host API call.</p>
<p>The default behavior is to fail with a &quot;not implemented&quot; error;
frontends backends should always override this. This callback is never
called for operator or backend plugins.</p>
<p>Besides the common arguments, the callback receives a handle to an
<code>ArbData</code> object containing the data that the host passed to <code>start()</code>.
This is a borrowed handle; the caller will delete it.</p>
<p>When the run callback is successful, it should return a valid <code>ArbData</code>
handle. This can be the same as the argument, but it can also be a new
object. This <code>ArbData</code> is returned to the host through <code>wait()</code>. This
<code>ArbData</code> object is deleted after the callback completes.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning 0. Otherwise, it should return a
valid <code>ArbData</code> handle.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_set_upstream_arb_cb()</tt></font><div style="margin-left: 16px">
<p>Sets the callback function for handling an arb from upstream for
operators and backends.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_pdef_set_upstream_arb_cb(
    dqcs_handle_t pdef,
    dqcs_handle_t (*callback)(
        void *user_data,
        dqcs_plugin_state_t state,
        dqcs_handle_t cmd
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>The default behavior for operators is to pass through to
<code>dqcs_plugin_arb()</code>; operators that do not support the requested
interface should always do this. The default for backends is no-op.
This callback is never called for frontend plugins.</p>
<p>Besides the common arguments, the callback receives a handle to the
<code>ArbCmd</code> object representing the request. It must return a valid
<code>ArbData</code> handle containing the response. Both objects are deleted
automatically after invocation.</p>
<p>The callback can return an error by setting an error message using
<code>dqcs_error_set()</code> and returning 0. Otherwise, it should return a valid
<code>ArbData</code> handle.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_type()</tt></font><div style="margin-left: 16px">
<p>Returns the plugin type for the given plugin definition object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_plugin_type_t dqcs_pdef_type(dqcs_handle_t pdef)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_pdef_version()</tt></font><div style="margin-left: 16px">
<p>Returns the plugin version for the given plugin definition object.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_pdef_version(dqcs_handle_t pdef)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the JSON
string. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure, this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_advance()</tt></font><div style="margin-left: 16px">
<p>Tells the downstream plugin to run for the specified number of cycles.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_cycle_t dqcs_plugin_advance(
    dqcs_plugin_state_t plugin,
    dqcs_cycle_t cycles
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p>The return value is the new cycle counter. This function uses -1 to signal
an error.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_allocate()</tt></font><div style="margin-left: 16px">
<p>Allocate the given number of downstream qubits.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_plugin_allocate(
    dqcs_plugin_state_t plugin,
    uintptr_t num_qubits,
    dqcs_handle_t cq
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p><code>num_qubits</code> specifies the number of qubits that are to be allocated.</p>
<p><code>commands</code> must be 0 or a valid handle to an <code>ArbCmd</code> queue, containing a
list of commands that may be used to modify the behavior of the qubit
register; 0 is equivalent to zero commands. The queue is consumed by this
function, i.e. the handle becomes invalid, if and only if it succeeds.</p>
<p>If the function is successful, a new handle to the set of qubit references
representing the newly allocated register is returned. When the function
fails, 0 is returned.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_arb()</tt></font><div style="margin-left: 16px">
<p>Sends an arbitrary command downstream.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_plugin_arb(
    dqcs_plugin_state_t plugin,
    dqcs_handle_t cmd
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p>This function returns a new handle to an <code>ArbData</code> object representing the
return value of the <code>ArbCmd</code> when successful. Otherwise, it returns 0.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_free()</tt></font><div style="margin-left: 16px">
<p>Free the given downstream qubits.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_plugin_free(
    dqcs_plugin_state_t plugin,
    dqcs_handle_t qbset
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p><code>qubits</code> must be a valid set of qubit references. The set is consumed by
this function, i.e. the handle becomes invalid, if and only if it succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_gate()</tt></font><div style="margin-left: 16px">
<p>Tells the downstream plugin to execute a gate.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_plugin_gate(
    dqcs_plugin_state_t plugin,
    dqcs_handle_t gate
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p><code>gate</code> must be a valid gate object. The object is consumed by this
function, i.e. the handle becomes invalid, if and only if it succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_get_cycle()</tt></font><div style="margin-left: 16px">
<p>Returns the current value of the downstream cycle counter.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_cycle_t dqcs_plugin_get_cycle(dqcs_plugin_state_t plugin)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p>This function uses -1 to signal an error.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_get_cycles_between_measures()</tt></font><div style="margin-left: 16px">
<p>Returns the number of downstream cycles between the last two measurements
of the given downstream qubit.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_cycle_t dqcs_plugin_get_cycles_between_measures(
    dqcs_plugin_state_t plugin,
    dqcs_qubit_t qubit
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p>This function uses -1 to signal an error.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_get_cycles_since_measure()</tt></font><div style="margin-left: 16px">
<p>Returns the number of downstream cycles since the latest measurement of the
given downstream qubit.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_cycle_t dqcs_plugin_get_cycles_since_measure(
    dqcs_plugin_state_t plugin,
    dqcs_qubit_t qubit
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p>This function uses -1 to signal an error.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_get_measurement()</tt></font><div style="margin-left: 16px">
<p>Returns the latest measurement of the given downstream qubit.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_plugin_get_measurement(
    dqcs_plugin_state_t plugin,
    dqcs_qubit_t qubit
)
</code></pre>
<p>Backend plugins are not allowed to call this. Doing so will result in an
error.</p>
<p>If the function succeeds, it returns a new handle to a qubit measurement
result object. Otherwise it returns 0.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_random_f64()</tt></font><div style="margin-left: 16px">
<p>Generates a random floating point number using the simulator random seed.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">double dqcs_plugin_random_f64(dqcs_plugin_state_t plugin)
</code></pre>
<p>The generated numbers are uniformly distributed in the range <code>[0,1&gt;</code>.</p>
<p>This function only fails if the <code>plugin</code> handle is invalid, in which case
it returns 0. Of course, 0 is also a valid (if rare) random return value.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_random_u64()</tt></font><div style="margin-left: 16px">
<p>Generates a random unsigned 64-bit number using the simulator random seed.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_plugin_random_u64(dqcs_plugin_state_t plugin)
</code></pre>
<p>This function only fails if the <code>plugin</code> handle is invalid, in which case
it returns 0. Of course, 0 is also a valid (if rare) random return value.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_recv()</tt></font><div style="margin-left: 16px">
<p>Waits for a message from the host.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_plugin_recv(dqcs_plugin_state_t plugin)
</code></pre>
<p>It is only legal to call this function from within the <code>run()</code> callback.
Any other source will result in an error.</p>
<p>When successful, this function returns a new handle to the received
<code>ArbData</code> object. 0 is used to indicate that an error occurred.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_run()</tt></font><div style="margin-left: 16px">
<p>Executes a plugin in the current thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_plugin_run(
    dqcs_handle_t pdef,
    const char *simulator
)
</code></pre>
<p><code>pdef</code> must be an appropriately populated plugin definition object.
Its callback functions will be called from the current thread, from within
the context of this function.</p>
<p><code>simulator</code> must be set to the address of our endpoint of the simulator
that's using the plugin; DQCsim normally passes this as the first command
line argument of the plugin process.</p>
<p>If the plugin starts, the <code>pdef</code> handle is consumed by this function,
regardless of whether the plugin eventually closes normally. The handle is
only left alive if <code>pdef</code> is not a plugin definition object.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_send()</tt></font><div style="margin-left: 16px">
<p>Sends a message to the host.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_plugin_send(
    dqcs_plugin_state_t plugin,
    dqcs_handle_t arb
)
</code></pre>
<p>It is only legal to call this function from within the <code>run()</code> callback.
Any other source will result in an error.</p>
<p>The <code>cmd</code> handle is consumed by this function if and only if it succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_start()</tt></font><div style="margin-left: 16px">
<p>Executes a plugin in a worker thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_plugin_start(
    dqcs_handle_t pdef,
    const char *simulator
)
</code></pre>
<p>This function behaves the same as dqcs_plugin_log(), but is asynchronous;
it always returns immediately. Of course, this means that the callbacks in
<code>pdef</code> will be called from a different thread.</p>
<p>To wait for the thread to finish executing, call <code>dqcs_plugin_wait()</code> on
the returned join handle. Alternatively you can delete the join handle
object, which will detach the thread.</p>
<p>Note that <code>dqcs_log_*()</code> will only be available in the thread that the
plugin actually runs in.</p>
<p>This function returns 0 to indicate failure to start the plugin. Otherwise,
the join handle is returned.</p>
</div></details>
<details><summary><font color="purple"><tt>dqcs_plugin_state_t</tt></font><div style="margin-left: 16px">
<p>Type for a plugin state.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef void *dqcs_plugin_state_t;
</code></pre>
<p>This is an opaque type that is passed along to plugin implementation
callback functions, which those callbacks can then use to interact with the
plugin instance. User code shall not create or modify values of this type,
and shall only use the values when calling <code>dqcs_plugin_*</code> functions.</p>
</div></details>
<details><summary><font color="purple"><tt>dqcs_plugin_type_t</tt></font><div style="margin-left: 16px">
<p>Enumeration of the three types of plugins.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_plugin_type_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_PTYPE_INVALID = -1</tt></font></summary><div style="margin-left: 16px">
Invalid plugin type. Used to indicate failure of an API that returns
a plugin type.
</div></details>
<details><summary><font color="blue"><tt>DQCS_PTYPE_FRONT = 0</tt></font></summary><div style="margin-left: 16px">
Frontend plugin.
</div></details>
<details><summary><font color="blue"><tt>DQCS_PTYPE_OPER = 1</tt></font></summary><div style="margin-left: 16px">
Operator plugin.
</div></details>
<details><summary><font color="blue"><tt>DQCS_PTYPE_BACK = 2</tt></font></summary><div style="margin-left: 16px">
Backend plugin.
</div></details>
</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_plugin_wait()</tt></font><div style="margin-left: 16px">
<p>Waits for a plugin worker thread to finish executing.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_plugin_wait(dqcs_handle_t pjoin)
</code></pre>
<p>Unless the join handle is invalid, this function returns success/failure
based on the result of the plugin execution. If the plugin thread is
joined, the join handle is deleted.</p>
</div></details>
<details><summary><font color="purple"><tt>dqcs_predefined_gate_t</tt></font><div style="margin-left: 16px">
<p>Enumeration of gates defined by DQCsim.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_predefined_gate_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_GATE_INVALID = 0</tt></font></summary><div style="margin-left: 16px">
Invalid gate. Used as an error return value.
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_PAULI_I = 100</tt></font></summary><div style="margin-left: 16px">
The identity gate for a single qubit.
<p>\[
I = \sigma_0 = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; 1
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_PAULI_X = 101</tt></font></summary><div style="margin-left: 16px">
The Pauli X matrix.
<p>\[
X = \sigma_1 = \begin{bmatrix}
0 &amp; 1 \\
1 &amp; 0
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_PAULI_Y = 102</tt></font></summary><div style="margin-left: 16px">
The Pauli Y matrix.
<p>\[
Y = \sigma_2 = \begin{bmatrix}
0 &amp; -i \\
i &amp; 0
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_PAULI_Z = 103</tt></font></summary><div style="margin-left: 16px">
The Pauli Z matrix.
<p>\[
Z = \sigma_3 = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; -1
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_H = 104</tt></font></summary><div style="margin-left: 16px">
The hadamard gate matrix. That is, a 180-degree Y rotation, followed by
a 90-degree X rotation.
<p>\[
H = \frac{1}{\sqrt{2}} \begin{bmatrix}
1 &amp; 1 \\
1 &amp; -1
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_S = 105</tt></font></summary><div style="margin-left: 16px">
The S matrix, also known as a 90 degree Z rotation.
<p>\[
S = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; i
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_S_DAG = 106</tt></font></summary><div style="margin-left: 16px">
The S-dagger matrix, also known as a negative 90 degree Z rotation.
<p>\[
S^\dagger = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; -i
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_T = 107</tt></font></summary><div style="margin-left: 16px">
The T matrix, also known as a 45 degree Z rotation.
<p>\[
T = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; e^{i\frac{\pi}{4}}
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_T_DAG = 108</tt></font></summary><div style="margin-left: 16px">
The T-dagger matrix, also known as a negative 45 degree Z rotation.
<p>\[
T^\dagger = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; e^{-i\frac{\pi}{4}}
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RX_90 = 109</tt></font></summary><div style="margin-left: 16px">
Rx(90) gate.
<p>\[
R_x\left(\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}} \begin{bmatrix}
1 &amp; -i \\
-i &amp; 1
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RX_M90 = 110</tt></font></summary><div style="margin-left: 16px">
Rx(-90) gate.
<p>\[
R_x\left(-\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}} \begin{bmatrix}
1 &amp; i \\
i &amp; 1
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RX_180 = 111</tt></font></summary><div style="margin-left: 16px">
Rx(180) gate.
<p>\[
R_x(\pi) = \begin{bmatrix}
0 &amp; -i \\
-i &amp; 0
\end{bmatrix}
\]</p>
<p>This matrix is equivalent to the Pauli X gate, but differs in global
phase. Note that this difference is significant when it is used as a
submatrix for a controlled gate.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RY_90 = 112</tt></font></summary><div style="margin-left: 16px">
Ry(90) gate.
<p>\[
R_y\left(\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}} \begin{bmatrix}
1 &amp; -1 \\
1 &amp; 1
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RY_M90 = 113</tt></font></summary><div style="margin-left: 16px">
Ry(-90) gate.
<p>\[
R_y\left(\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}} \begin{bmatrix}
1 &amp; 1 \\
-1 &amp; 1
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RY_180 = 114</tt></font></summary><div style="margin-left: 16px">
Ry(180) gate.
<p>\[
R_y(\pi) = \begin{bmatrix}
0 &amp; -1 \\
1 &amp; 0
\end{bmatrix}
\]</p>
<p>This matrix is equivalent to the Pauli Y gate, but differs in global
phase. Note that this difference is significant when it is used as a
submatrix for a controlled gate.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RZ_90 = 115</tt></font></summary><div style="margin-left: 16px">
Rz(90) gate.
<p>\[
R_z\left(\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}} \begin{bmatrix}
1-i &amp; 0 \\
0 &amp; 1+i
\end{bmatrix}
\]</p>
<p>This matrix is equivalent to the S gate, but differs in global phase.
Note that this difference is significant when it is used as a submatrix
for a controlled gate.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RZ_M90 = 116</tt></font></summary><div style="margin-left: 16px">
Rz(-90) gate.
<p>\[
R_z\left(-\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}} \begin{bmatrix}
1+i &amp; 0 \\
0 &amp; 1-i
\end{bmatrix}
\]</p>
<p>This matrix is equivalent to the S-dagger gate, but differs in global
phase. Note that this difference is significant when it is used as a
submatrix for a controlled gate.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RZ_180 = 117</tt></font></summary><div style="margin-left: 16px">
Rz(180) gate.
<p>\[
R_z(\pi) = \begin{bmatrix}
-i &amp; 0 \\
0 &amp; i
\end{bmatrix}
\]</p>
<p>This matrix is equivalent to the Pauli Z gate, but differs in global
phase. Note that this difference is significant when it is used as a
submatrix for a controlled gate.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RX = 150</tt></font></summary><div style="margin-left: 16px">
The matrix for an arbitrary X rotation.
<p>\[
R_x(\theta) = \begin{bmatrix}
\cos{\frac{\theta}{2}} &amp; -i\sin{\frac{\theta}{2}} \\
-i\sin{\frac{\theta}{2}} &amp; \cos{\frac{\theta}{2}}
\end{bmatrix}
\]</p>
<p> is specified or returned through the first binary string argument
of the parameterization ArbData object. It is represented as a
little-endian double floating point value, specified in radians.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RY = 151</tt></font></summary><div style="margin-left: 16px">
The matrix for an arbitrary Y rotation.
<p>\[
R_y(\theta) = \begin{bmatrix}
\cos{\frac{\theta}{2}} &amp; -\sin{\frac{\theta}{2}} \\
\sin{\frac{\theta}{2}} &amp; \cos{\frac{\theta}{2}}
\end{bmatrix}
\]</p>
<p> is specified or returned through the first binary string argument
of the parameterization ArbData object. It is represented as a
little-endian double floating point value, specified in radians.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RZ = 152</tt></font></summary><div style="margin-left: 16px">
The matrix for an arbitrary Z rotation.
<p>\[
R_z(\theta) = \begin{bmatrix}
e^{-i\frac{\theta}{2}} &amp; 0 \\
0 &amp; e^{i\frac{\theta}{2}}
\end{bmatrix}
\]</p>
<p> is specified or returned through the first binary string argument
of the parameterization ArbData object. It is represented as a
little-endian double floating point value, specified in radians.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_PHASE_K = 153</tt></font></summary><div style="margin-left: 16px">
The matrix for a Z rotation with angle /2^k.
<p>\[
\textit{PhaseK}(k) = \textit{Phase}\left(\frac{\pi}{2^k}\right) = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; e^{i\pi / 2^k}
\end{bmatrix}
\]</p>
<p>k is specified or returned through the first binary string argument
of the parameterization ArbData object. It is represented as a
little-endian unsigned 64-bit integer.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_PHASE = 154</tt></font></summary><div style="margin-left: 16px">
The matrix for an arbitrary Z rotation.
<p>\[
\textit{Phase}(\theta) = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; e^{i\theta}
\end{bmatrix}
\]</p>
<p> is specified or returned through the first binary string argument
of the parameterization ArbData object. It is represented as a
little-endian double floating point value, specified in radians.</p>
<p>This matrix is equivalent to the Rz gate, but differs in global phase.
Note that this difference is significant when it is used as a submatrix
for a controlled gate. Specifically, controlled phase gates use the
phase as specified by this gate, whereas Rz follows the usual algebraic
notation.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_U1 = 190</tt></font></summary><div style="margin-left: 16px">
Any single-qubit unitary gate, parameterized as a full unitary matrix.
<p>The full matrix is specified or returned through the first binary string
argument of the parameterization ArbData object. It is represented as an
array of little-endian double floating point values, structured as
real/imag pairs, with the pairs in row-major order.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_R = 191</tt></font></summary><div style="margin-left: 16px">
Arbitrary rotation matrix.
<p>\[
R(\theta, \phi, \lambda) = \begin{bmatrix}
\cos{\frac{\theta}{2}} &amp; -\sin{\frac{\theta}{2}} e^{i\lambda} \\
\sin{\frac{\theta}{2}} e^{i\phi} &amp; \cos{\frac{\theta}{2}} e^{i\phi + i\lambda}
\end{bmatrix}
\]</p>
<p>This is equivalent to the following:</p>
<p>\[
R(\theta, \phi, \lambda) = \textit{Phase}(\phi) \cdot R_y(\theta) \cdot \textit{Phase}(\lambda)
\]</p>
<p>The rotation order and phase is taken from Qiskit's U3 gate. Ignoring
global phase, any unitary single-qubit gate can be represented with this
notation.</p>
<p>, , and  are specified or returned through the first three binary
string arguments of the parameterization ArbData object. They are
represented as little-endian double floating point values, specified in
radians.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_SWAP = 200</tt></font></summary><div style="margin-left: 16px">
The swap gate matrix.
<p>\[
\textit{SWAP} = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_SQRT_SWAP = 201</tt></font></summary><div style="margin-left: 16px">
The square-root of a swap gate matrix.
<p>\[
\sqrt{\textit{SWAP}} = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \frac{i+1}{2} &amp; \frac{i-1}{2} &amp; 0 \\
0 &amp; \frac{i-1}{2} &amp; \frac{i+1}{2} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_U2 = 290</tt></font></summary><div style="margin-left: 16px">
Any two-qubit unitary gate, parameterized as a full unitary matrix.
<p>The full matrix is specified or returned through the first binary string
argument of the parameterization ArbData object. It is represented as an
array of little-endian double floating point values, structured as
real/imag pairs, with the pairs in row-major order.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_U3 = 390</tt></font></summary><div style="margin-left: 16px">
Any three-qubit unitary gate, parameterized as a full unitary matrix.
<p>The full matrix is specified or returned through the first binary string
argument of the parameterization ArbData object. It is represented as an
array of little-endian double floating point values, structured as
real/imag pairs, with the pairs in row-major order.</p>
</div></details>
</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_qbset_contains()</tt></font><div style="margin-left: 16px">
<p>Returns whether the given qubit set contains the given qubit.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_qbset_contains(
    dqcs_handle_t qbset,
    dqcs_qubit_t qubit
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_qbset_copy()</tt></font><div style="margin-left: 16px">
<p>Returns a copy of the given qubit set, intended for non-destructive
iteration.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_qbset_copy(dqcs_handle_t qbset)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_qbset_len()</tt></font><div style="margin-left: 16px">
<p>Returns the number of qubits in the given set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_qbset_len(dqcs_handle_t qbset)
</code></pre>
<p>This function returns -1 to indicate failure.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_qbset_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new set of qubit references.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_qbset_new(void)
</code></pre>
<p>Returns the handle of the newly created set. The set is initially empty.
Qubit sets are ordered, meaning that the order in which qubits are popped
from the set equals the order in which they were pushed. To iterate over a
set, simply make a copy and drain the copy using pop.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_qbset_pop()</tt></font><div style="margin-left: 16px">
<p>Pops a qubit reference off of a qubit reference set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_qubit_t dqcs_qbset_pop(dqcs_handle_t qbset)
</code></pre>
<p>Qubits are popped in the same order in which they were pushed. That is,
they are FIFO-ordered.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_qbset_push()</tt></font><div style="margin-left: 16px">
<p>Pushes a qubit reference into a qubit reference set.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_qbset_push(
    dqcs_handle_t qbset,
    dqcs_qubit_t qubit
)
</code></pre>
<p>This function will fail if the specified qubit was already part of the set.</p>
</div></details>
<details><summary><font color="purple"><tt>dqcs_qubit_t</tt></font><div style="margin-left: 16px">
<p>Type for a qubit reference.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef unsigned long long dqcs_qubit_t;
</code></pre>
<p>Qubit references are exchanged between the frontend, operator, and backend
plugins to indicate which qubits a gate operates on. Note that this makes
them fundamentally different from handles, which are thread-local.</p>
<p>Qubit references are always positive integers, counting upwards from 1 upon
allocation, and they are not reused even after the qubit is deallocated.
Thus, every subsequent allocation returns a qubit reference one greater
than the previous. This is guaranteed behavior that external code can rely
upon. The value zero is reserved for invalid references or error
propagation.</p>
</div></details>
<details><summary><font color="purple"><tt>dqcs_return_t</tt></font><div style="margin-left: 16px">
<p>Default return type for functions that don't need to return anything.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_return_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_FAILURE = -1</tt></font></summary><div style="margin-left: 16px">
The function has failed. More information may be obtained through
`dqcsim_explain()`.
</div></details>
<details><summary><font color="blue"><tt>DQCS_SUCCESS = 0</tt></font></summary><div style="margin-left: 16px">
The function did what it was supposed to.
</div></details>
</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_dqcsim_verbosity_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured verbosity for DQCsim's own messages.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_loglevel_t dqcs_scfg_dqcsim_verbosity_get(dqcs_handle_t scfg)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_dqcsim_verbosity_set()</tt></font><div style="margin-left: 16px">
<p>Configures the logging verbosity for DQCsim's own messages.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_dqcsim_verbosity_set(
    dqcs_handle_t scfg,
    dqcs_loglevel_t level
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_log_callback()</tt></font><div style="margin-left: 16px">
<p>Configures DQCsim to also output its log messages to callback function.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_log_callback(
    dqcs_handle_t scfg,
    dqcs_loglevel_t verbosity,
    void (*callback)(
        void *user_data,
        const char *message,
        const char *logger,
        dqcs_loglevel_t level,
        const char *module,
        const char *file,
        uint32_t line,
        uint64_t time_s,
        uint32_t time_ns,
        uint32_t pid,
        uint64_t tid
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p><code>verbosity</code> specifies the minimum importance of a message required for the
callback to be called.</p>
<p><code>callback</code> is the callback function to install. It is always called with
the <code>user_data</code> pointer to make calling stuff like class member functions
or closures possible. The <code>user_free</code> function, if non-null, will be called
when the callback is uninstalled in any way. If <code>callback</code> is null, any
current callback is uninstalled instead. For consistency, if <code>user_free</code> is
non-null while <code>callback</code> is null, <code>user_free</code> is called immediately, under
the assumption that the caller has allocated resources unbeknownst that the
callback it's trying to install is null.</p>
<p><strong>NOTE: both <code>callback</code> and <code>user_free</code> may be called from a thread spawned
by the simulator. Calling any API calls from the callback is therefore
undefined behavior!</strong></p>
<p>The callback takes the following arguments:</p>
<ul>
<li><code>void*</code>: user defined data.</li>
<li><code>const char*</code>: log message string, excluding metadata.</li>
<li><code>const char*</code>: name assigned to the logger that was used to produce the
message (= &quot;dqcsim&quot; or a plugin name).</li>
<li><code>dqcs_loglevel_t</code>: the verbosity level that the message was logged with.</li>
<li><code>const char*</code>: string representing the source of the log message, or
<code>NULL</code> when no source is known.</li>
<li><code>const char*</code>: string containing the filename of the source that
generated the message, or <code>NULL</code> when no source is known.</li>
<li><code>uint32_t</code>: line number within the aforementioned file, or 0 if not
known.</li>
<li><code>uint64_t</code>: Time in seconds since the Unix epoch.</li>
<li><code>uint32_t</code>: Additional time in nanoseconds since the aforementioned.</li>
<li><code>uint32_t</code>: PID of the generating process.</li>
<li><code>uint64_t</code>: TID of the generating thread.</li>
</ul>
<p>If an internal log record is particularly malformed and cannot be coerced
into the above (nul bytes in the strings, invalid timestamp, whatever) the
message is silently ignored.</p>
<p>The primary use of this callback is to pipe DQCsim's messages to an
external logging framework. When you do this, you probably also want to
call <code>dqcs_scfg_stderr_verbosity_set(handle, DQCS_LOG_OFF)</code> to prevent
DQCsim from writing the messages to stderr itself.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_new()</tt></font><div style="margin-left: 16px">
<p>Constructs an empty simulation configuration.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_scfg_new(void)
</code></pre>
<p>Before the configuration can be used, at least a frontend and a backend
plugin configuration must be pushed into it. This can be done with
<code>dqcs_scfg_push_plugin()</code>. Failing to do this will result in an error when
you try to start the simulation.</p>
<p>The default settings correspond to the defaults of the <code>dqcsim</code> command
line interface. Refer to its help for more information.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_push_plugin()</tt></font><div style="margin-left: 16px">
<p>Appends a plugin to a simulation configuration.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_push_plugin(
    dqcs_handle_t scfg,
    dqcs_handle_t xcfg
)
</code></pre>
<p>Both plugin process and plugin thread configuration objects may be used.
The handle is consumed by this function, and is thus invalidated, if and
only if it is successful.</p>
<p>Frontend and backend plugins will automatically be inserted at the front
and back of the pipeline when the simulation is created. Operators are
inserted in front to back order. This function does not provide safeguards
against multiple frontends/backends; such errors will only be reported when
the simulation is started.</p>
<p>Note that it is not possible to observe or mutate a plugin configuration
once it has been added to a simulator configuration handle. If you want to
do this for some reason, you should maintain your own data structures, and
only build the DQCsim structures from them when you're done.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_repro_disable()</tt></font><div style="margin-left: 16px">
<p>Disables the reproduction logging system.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_repro_disable(dqcs_handle_t scfg)
</code></pre>
<p>Calling this will disable the warnings printed when a simulation that
cannot be reproduced is constructed.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_repro_path_style_get()</tt></font><div style="margin-left: 16px">
<p>Returns the path style used when writing reproduction files.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_path_style_t dqcs_scfg_repro_path_style_get(dqcs_handle_t scfg)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_repro_path_style_set()</tt></font><div style="margin-left: 16px">
<p>Sets the path style used when writing reproduction files.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_repro_path_style_set(
    dqcs_handle_t scfg,
    dqcs_path_style_t path_style
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_seed_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured random seed.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">uint64_t dqcs_scfg_seed_get(dqcs_handle_t scfg)
</code></pre>
<p>This function will return 0 when it fails, but this can unfortunately not
be reliably distinguished from a seed that was set to 0.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_seed_set()</tt></font><div style="margin-left: 16px">
<p>Configures the random seed that the simulation should use.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_seed_set(
    dqcs_handle_t scfg,
    uint64_t seed
)
</code></pre>
<p>Note that the seed is randomized by default.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_stderr_verbosity_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured stderr sink verbosity for a simulation.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_loglevel_t dqcs_scfg_stderr_verbosity_get(dqcs_handle_t scfg)
</code></pre>
<p>That is, the minimum loglevel that a messages needs to have for it to be
printed to stderr.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_stderr_verbosity_set()</tt></font><div style="margin-left: 16px">
<p>Configures the stderr sink verbosity for a simulation.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_stderr_verbosity_set(
    dqcs_handle_t scfg,
    dqcs_loglevel_t level
)
</code></pre>
<p>That is, the minimum loglevel that a messages needs to have for it to be
printed to stderr.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_scfg_tee()</tt></font><div style="margin-left: 16px">
<p>Configures DQCsim to also output its log messages to a file.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_scfg_tee(
    dqcs_handle_t scfg,
    dqcs_loglevel_t verbosity,
    const char *filename
)
</code></pre>
<p><code>verbosity</code> configures the verbosity level for the file only.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_arb()</tt></font><div style="margin-left: 16px">
<p>Sends an <code>ArbCmd</code> message to one of the plugins, referenced by name.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_sim_arb(
    dqcs_handle_t sim,
    const char *name,
    dqcs_handle_t cmd
)
</code></pre>
<p><code>ArbCmd</code>s are executed immediately after yielding to the simulator, so
all pending asynchronous calls are flushed and executed <em>before</em> the
<code>ArbCmd</code>.</p>
<p>When this succeeds, the received data is returned in the form of a new
handle. When it fails, 0 is returned.</p>
<p>The <code>ArbCmd</code> handle is consumed if and only if the API call succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_arb_idx()</tt></font><div style="margin-left: 16px">
<p>Sends an <code>ArbCmd</code> message to one of the plugins, referenced by index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_sim_arb_idx(
    dqcs_handle_t sim,
    ssize_t index,
    dqcs_handle_t cmd
)
</code></pre>
<p>The frontend always has index 0. 1 through N are used for the operators
in front to back order (where N is the number of operators). The
backend is at index N+1.</p>
<p>Python-style negative indices are supported. That is, -1 can be used to
refer to the backend, -2 to the last operator, and so on.</p>
<p><code>ArbCmd</code>s are executed immediately after yielding to the simulator, so
all pending asynchronous calls are flushed and executed <em>before</em> the
<code>ArbCmd</code>.</p>
<p>When this succeeds, the received data is returned in the form of a new
handle. When it fails, 0 is returned.</p>
<p>The <code>ArbCmd</code> handle is consumed if and only if the API call succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_get_author()</tt></font><div style="margin-left: 16px">
<p>Queries the author of a plugin, referenced by instance name.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_sim_get_author(
    dqcs_handle_t sim,
    const char *name
)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
author. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_get_author_idx()</tt></font><div style="margin-left: 16px">
<p>Queries the author of a plugin, referenced by index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_sim_get_author_idx(
    dqcs_handle_t sim,
    ssize_t index
)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
author. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_get_name()</tt></font><div style="margin-left: 16px">
<p>Queries the implementation name of a plugin, referenced by instance
name.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_sim_get_name(
    dqcs_handle_t sim,
    const char *name
)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
name. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_get_name_idx()</tt></font><div style="margin-left: 16px">
<p>Queries the implementation name of a plugin, referenced by index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_sim_get_name_idx(
    dqcs_handle_t sim,
    ssize_t index
)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
name. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_get_version()</tt></font><div style="margin-left: 16px">
<p>Queries the version of a plugin, referenced by instance name.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_sim_get_version(
    dqcs_handle_t sim,
    const char *name
)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
version. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_get_version_idx()</tt></font><div style="margin-left: 16px">
<p>Queries the version of a plugin, referenced by index.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_sim_get_version_idx(
    dqcs_handle_t sim,
    ssize_t index
)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
version. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_new()</tt></font><div style="margin-left: 16px">
<p>Constructs a DQCsim simulation.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_sim_new(dqcs_handle_t scfg)
</code></pre>
<p>The provided handle is consumed if it is a simulation configuration,
regardless of whether simulation construction succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_recv()</tt></font><div style="margin-left: 16px">
<p>Waits for the simulated accelerator to send a message to us.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_sim_recv(dqcs_handle_t sim)
</code></pre>
<p>When this succeeds, the received data is returned in the form of a new
handle. When it fails, 0 is returned.</p>
<p>Deadlocks are detected and prevented by returning an error.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_send()</tt></font><div style="margin-left: 16px">
<p>Sends a message to the simulated accelerator.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_sim_send(
    dqcs_handle_t sim,
    dqcs_handle_t data
)
</code></pre>
<p>This is an asynchronous call: nothing happens until <code>yield()</code>,
<code>recv()</code>, or <code>wait()</code> is called.</p>
<p>The <code>ArbData</code> handle is optional; if 0 is passed, an empty data object is
used. If a handle is passed, it is consumed if and only if the API call
succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_start()</tt></font><div style="margin-left: 16px">
<p>Starts a program on the simulated accelerator.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_sim_start(
    dqcs_handle_t sim,
    dqcs_handle_t data
)
</code></pre>
<p>This is an asynchronous call: nothing happens until <code>yield()</code>,
<code>recv()</code>, or <code>wait()</code> is called.</p>
<p>The <code>ArbData</code> handle is optional; if 0 is passed, an empty data object is
used. If a handle is passed, it is consumed if and only if the API call
succeeds.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_wait()</tt></font><div style="margin-left: 16px">
<p>Waits for the simulated accelerator to finish its current program.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_sim_wait(dqcs_handle_t sim)
</code></pre>
<p>When this succeeds, the return value of the accelerator's <code>run()</code>
function is returned in the form of a new handle. When it fails, 0 is
returned.</p>
<p>Deadlocks are detected and prevented by returning an error.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_write_reproduction_file()</tt></font><div style="margin-left: 16px">
<p>Writes a reproduction file for the simulation so far.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_sim_write_reproduction_file(
    dqcs_handle_t sim,
    const char *filename
)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_sim_yield()</tt></font><div style="margin-left: 16px">
<p>Yields to the simulator.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_sim_yield(dqcs_handle_t sim)
</code></pre>
<p>The simulation runs until it blocks again. This is useful if you want an
immediate response to an otherwise asynchronous call through the logging
system or some communication channel outside of DQCsim's control.</p>
<p>This function silently returns immediately if no asynchronous data was
pending or if the simulator is waiting for something that has not been
sent yet.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_tcfg_init_cmd()</tt></font><div style="margin-left: 16px">
<p>Appends an <code>ArbCmd</code> to the list of initialization commands of a plugin
thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_tcfg_init_cmd(
    dqcs_handle_t tcfg,
    dqcs_handle_t cmd
)
</code></pre>
<p>The <code>ArbCmd</code> handle is consumed by this function, and is thus invalidated,
if and only if it is successful.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_tcfg_name()</tt></font><div style="margin-left: 16px">
<p>Returns the configured name for the given plugin thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">char *dqcs_tcfg_name(dqcs_handle_t tcfg)
</code></pre>
<p>On success, this <strong>returns a newly allocated string containing the
name. Free it with <code>free()</code> when you're done with it to avoid memory
leaks.</strong> On failure (i.e., the handle is invalid) this returns <code>NULL</code>.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_tcfg_new()</tt></font><div style="margin-left: 16px">
<p>Creates a new plugin thread configuration object from a plugin definition.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_tcfg_new(
    dqcs_handle_t pdef,
    const char *name
)
</code></pre>
<p>The plugin definition handle is consumed by this function.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_tcfg_new_raw()</tt></font><div style="margin-left: 16px">
<p>Creates a new plugin thread configuration object from a callback.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_tcfg_new_raw(
    dqcs_plugin_type_t plugin_type,
    const char *name,
    void (*callback)(
        void *user_data,
        const char *simulator
    ),
    void (*user_free)(void *user_data),
    void *user_data
)
</code></pre>
<p>The callback is called by DQCsim from a dedicated thread when DQCsim wants
to start the plugin. The callback must then in some way spawn a plugin
process that connects to the provided simulator string. The callback should
return only when the process terminates.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_tcfg_tee()</tt></font><div style="margin-left: 16px">
<p>Configures a plugin thread to also output its log messages to a file.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_tcfg_tee(
    dqcs_handle_t tcfg,
    dqcs_loglevel_t verbosity,
    const char *filename
)
</code></pre>
<p><code>verbosity</code> configures the verbosity level for the file only.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_tcfg_type()</tt></font><div style="margin-left: 16px">
<p>Returns the type of the given plugin thread configuration.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_plugin_type_t dqcs_tcfg_type(dqcs_handle_t tcfg)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_tcfg_verbosity_get()</tt></font><div style="margin-left: 16px">
<p>Returns the configured verbosity for the given plugin thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_loglevel_t dqcs_tcfg_verbosity_get(dqcs_handle_t tcfg)
</code></pre>
</div></details>
<details><summary><font color="green"><tt>dqcs_tcfg_verbosity_set()</tt></font><div style="margin-left: 16px">
<p>Configures the logging verbosity for the given plugin thread.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_tcfg_verbosity_set(
    dqcs_handle_t tcfg,
    dqcs_loglevel_t level
)
</code></pre>
</div></details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../c-api/sim.apigen.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../cpp-api/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../c-api/sim.apigen.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../cpp-api/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
