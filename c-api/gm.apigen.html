<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Gate maps: dqcs_gm_* - DQCsim</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction to DQCsim</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/components.html"><strong aria-hidden="true">1.1.</strong> The components of a simulation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/frontend.html"><strong aria-hidden="true">1.1.1.</strong> Frontend use cases</a></li><li class="chapter-item expanded "><a href="../intro/backend.html"><strong aria-hidden="true">1.1.2.</strong> Backend use cases</a></li><li class="chapter-item expanded "><a href="../intro/operator.html"><strong aria-hidden="true">1.1.3.</strong> Operator use cases</a></li><li class="chapter-item expanded "><a href="../intro/host.html"><strong aria-hidden="true">1.1.4.</strong> Host use cases</a></li></ol></li><li class="chapter-item expanded "><a href="../intro/puzzle.html"><strong aria-hidden="true">1.2.</strong> Jigsaw puzzle analogy</a></li><li class="chapter-item expanded "><a href="../intro/interfaces.html"><strong aria-hidden="true">1.3.</strong> DQCsim's interfaces</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/arbs.html"><strong aria-hidden="true">1.3.1.</strong> ArbData and ArbCmds</a></li><li class="chapter-item expanded "><a href="../intro/gatestream.html"><strong aria-hidden="true">1.3.2.</strong> Gate- and measurement streams</a></li><li class="chapter-item expanded "><a href="../intro/host-iface.html"><strong aria-hidden="true">1.3.3.</strong> The host interface</a></li><li class="chapter-item expanded "><a href="../intro/misc-iface.html"><strong aria-hidden="true">1.3.4.</strong> Miscellaneous interfaces</a></li></ol></li><li class="chapter-item expanded "><a href="../intro/reproducibility.html"><strong aria-hidden="true">1.4.</strong> Reproducibility</a></li></ol></li><li class="chapter-item expanded "><a href="../install/index.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../install/plugins.html"><strong aria-hidden="true">2.1.</strong> Plugin distribution</a></li></ol></li><li class="chapter-item expanded "><a href="../cli/index.html"><strong aria-hidden="true">3.</strong> The command-line interface</a></li><li class="chapter-item expanded "><a href="../python-api/index.html"><strong aria-hidden="true">4.</strong> Python API</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../python-api/hello-world.html"><strong aria-hidden="true">4.1.</strong> Hello, world!</a></li><li class="chapter-item expanded "><a href="../python-api/debugging.html"><strong aria-hidden="true">4.2.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="../python-api/sending-gates.html"><strong aria-hidden="true">4.3.</strong> Sending some gates</a></li><li class="chapter-item expanded "><a href="../python-api/simulations.html"><strong aria-hidden="true">4.4.</strong> Controlling simulations</a></li><li class="chapter-item expanded "><a href="../python-api/operator.html"><strong aria-hidden="true">4.5.</strong> Inserting an operator</a></li><li class="chapter-item expanded "><a href="../python-api/reference.html"><strong aria-hidden="true">4.6.</strong> Reference</a></li></ol></li><li class="chapter-item expanded "><a href="../c-api/index.html"><strong aria-hidden="true">5.</strong> C API</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../c-api/usage.html"><strong aria-hidden="true">5.1.</strong> Usage</a></li><li class="chapter-item expanded "><a href="../c-api/concepts.apigen.html"><strong aria-hidden="true">5.2.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../c-api/handle.apigen.html"><strong aria-hidden="true">5.2.1.</strong> Handles: dqcs_handle_*</a></li><li class="chapter-item expanded "><a href="../c-api/memory-management.apigen.html"><strong aria-hidden="true">5.2.2.</strong> Memory management</a></li><li class="chapter-item expanded "><a href="../c-api/error.apigen.html"><strong aria-hidden="true">5.2.3.</strong> Error handling: dqcs_error_*</a></li><li class="chapter-item expanded "><a href="../c-api/callbacks.apigen.html"><strong aria-hidden="true">5.2.4.</strong> Callbacks</a></li></ol></li><li class="chapter-item expanded "><a href="../c-api/type-definitions.apigen.html"><strong aria-hidden="true">5.3.</strong> Type definitions: dqcs_*_t</a></li><li class="chapter-item expanded "><a href="../c-api/arb-cmd-cq.apigen.html"><strong aria-hidden="true">5.4.</strong> ArbData and ArbCmd objects</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../c-api/arb.apigen.html"><strong aria-hidden="true">5.4.1.</strong> ArbData objects: dqcs_arb_*</a></li><li class="chapter-item expanded "><a href="../c-api/cmd.apigen.html"><strong aria-hidden="true">5.4.2.</strong> ArbCmd objects: dqcs_cmd_*</a></li><li class="chapter-item expanded "><a href="../c-api/cq.apigen.html"><strong aria-hidden="true">5.4.3.</strong> ArbCmd queues: dqcs_cq_*</a></li></ol></li><li class="chapter-item expanded "><a href="../c-api/qbset.apigen.html"><strong aria-hidden="true">5.5.</strong> Qubits: dqcs_qbset_*</a></li><li class="chapter-item expanded "><a href="../c-api/mat.apigen.html"><strong aria-hidden="true">5.6.</strong> Matrices: dqcs_mat_*</a></li><li class="chapter-item expanded "><a href="../c-api/gate.apigen.html"><strong aria-hidden="true">5.7.</strong> Gates: dqcs_gate_*</a></li><li class="chapter-item expanded "><a href="../c-api/gm.apigen.html" class="active"><strong aria-hidden="true">5.8.</strong> Gate maps: dqcs_gm_*</a></li><li class="chapter-item expanded "><a href="../c-api/measurements.apigen.html"><strong aria-hidden="true">5.9.</strong> Measurements</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../c-api/meas.apigen.html"><strong aria-hidden="true">5.9.1.</strong> Singular measurements: dqcs_meas_*</a></li><li class="chapter-item expanded "><a href="../c-api/mset.apigen.html"><strong aria-hidden="true">5.9.2.</strong> Measurement sets: dqcs_mset_*</a></li></ol></li><li class="chapter-item expanded "><a href="../c-api/plugins.apigen.html"><strong aria-hidden="true">5.10.</strong> Plugins</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../c-api/pdef.apigen.html"><strong aria-hidden="true">5.10.1.</strong> Defining a plugin: dqcs_pdef_*</a></li><li class="chapter-item expanded "><a href="../c-api/plugin-run.apigen.html"><strong aria-hidden="true">5.10.2.</strong> Running a plugin: dqcs_plugin_*</a></li><li class="chapter-item expanded "><a href="../c-api/plugin-interact.apigen.html"><strong aria-hidden="true">5.10.3.</strong> Interacting with DQCsim: dqcs_plugin_*</a></li><li class="chapter-item expanded "><a href="../c-api/log.apigen.html"><strong aria-hidden="true">5.10.4.</strong> Logging: dqcs_log_*</a></li></ol></li><li class="chapter-item expanded "><a href="../c-api/simulations.apigen.html"><strong aria-hidden="true">5.11.</strong> Simulations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../c-api/pcfg.apigen.html"><strong aria-hidden="true">5.11.1.</strong> Configuring plugins: dqcs_pcfg_*</a></li><li class="chapter-item expanded "><a href="../c-api/tcfg.apigen.html"><strong aria-hidden="true">5.11.2.</strong> Running local plugins: dqcs_tcfg_*</a></li><li class="chapter-item expanded "><a href="../c-api/scfg.apigen.html"><strong aria-hidden="true">5.11.3.</strong> Configuring a simulation: dqcs_scfg_*</a></li><li class="chapter-item expanded "><a href="../c-api/sim.apigen.html"><strong aria-hidden="true">5.11.4.</strong> Running a simulation: dqcs_sim_*</a></li></ol></li><li class="chapter-item expanded "><a href="../c-api/reference.apigen.html"><strong aria-hidden="true">5.12.</strong> Reference</a></li></ol></li><li class="chapter-item expanded "><a href="../cpp-api/index.html"><strong aria-hidden="true">6.</strong> C++ API</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cpp-api/usage.html"><strong aria-hidden="true">6.1.</strong> Usage</a></li><li class="chapter-item expanded "><a href="../cpp-api/ccompare.html"><strong aria-hidden="true">6.2.</strong> Comparison to the C API</a></li><li class="chapter-item expanded "><a href="../cpp-api/plugin.html"><strong aria-hidden="true">6.3.</strong> Plugin anatomy</a></li><li class="chapter-item expanded "><a href="../cpp-api/sim.html"><strong aria-hidden="true">6.4.</strong> Host/simulation anatomy</a></li><li class="chapter-item expanded "><a href="../cpp-api/reference.html"><strong aria-hidden="true">6.5.</strong> Reference</a></li></ol></li><li class="chapter-item expanded "><a href="../rust-api/index.html"><strong aria-hidden="true">7.</strong> Rust API</a></li><li class="chapter-item expanded affix "><a href="../release.html">Release</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">DQCsim</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#gate-maps" id="gate-maps">Gate maps</a></h1>
<p>Representing gates with matrices is a great way to ensure plugin compatibility;
unlike using for example names for gates, the matrix unambiguously represents
the mathematical operation that is to be performed. However, there are cases
where you may want to distinguish whether a gate is for instance one of the
Pauli gates or something else. You could do this with <code>dqcs_mat_approx_eq()</code>,
but if you have a lot of gates your code will explode, be error-prone
(especially if you want to do the reverse operation as well), and may not be
very efficient. More generally, a plugin may want to use its own higher-level
internal gate representation, and convert between that and DQCsim's
matrix-based representation.</p>
<p>Gate maps intend to solve this problem. You can define any data structure to
represent your gates as long as it can map to/from the following:</p>
<ul>
<li>any kind of key (a <code>void*</code>) defining the type of gate.</li>
<li>a number of qubit arguments.</li>
<li>optionally, an <code>ArbData</code> representing parameters if your definition of a
gate type is parameterized.</li>
</ul>
<p>You can then use a gate map to convert between that representation and DQCsim's
representation, typically in both directions. Going from DQCsim's matrix
representation to your plugin's representation is called detection, while the
opposite direction is called construction. Once you have a gate map, you can
use the following functions to do this.</p>
<details><summary><font color="green"><tt>dqcs_gm_detect()</tt></font><div style="margin-left: 16px">
<p>Uses a gate map object to convert an incoming DQCsim gate to the plugin's
representation.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_gm_detect(
    dqcs_handle_t gm,
    dqcs_handle_t gate,
    const void **key_data,
    dqcs_handle_t *qubits,
    dqcs_handle_t *param_data
)
</code></pre>
<p><code>gm</code> must be a handle to a gate map object (<code>dqcs_mm_new()</code>).
<code>gate</code> must be a handle to a gate. The handle is borrowed; it is not
mutated or deleted.
<code>key_data</code> serves as an optional return value; if non-NULL and a match is
found, the <code>key_data</code> specified when the respective detector was added is
returned here as a <code>const void *</code>. If no match is found, <code>*key_data</code> is
not assigned.
<code>qubits</code> serves as an optional return value; if non-NULL and a match
is found, it is set to a handle to a new <code>QubitSet</code> object representing the
gate's qubits. Ownership of this handle is passed to the user, so it
is up to the user to eventually delete it. If no match is found,
<code>*qubits</code> is set to 0.
<code>param_data</code> serves as an optional return value; if non-NULL and a match
is found, it is set to a handle to a new <code>ArbData</code> object representing the
gate's parameters. Ownership of this handle is passed to the user, so it
is up to the user to eventually delete it. If no match is found,
<code>*param_data</code> is set to 0.</p>
<p>This function returns <code>DQCS_TRUE</code> if a match was found, <code>DQCS_FALSE</code> if no
match was found, or <code>DQCS_BOOL_FAILURE</code> if an error occurs.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gm_construct_one()</tt></font><div style="margin-left: 16px">
<p>Uses a gate map object to construct a one-qubit DQCsim gate from the
plugin's representation.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gm_construct_one(
    dqcs_handle_t gm,
    const void *key_data,
    dqcs_qubit_t qa,
    dqcs_handle_t param_data
)
</code></pre>
<p>This function is simply a shorthand for <code>dqcs_gm_construct()</code> with
one qubit in the <code>qubits</code> set, to make constructing one-qubit gates more
ergonomic. Refer to its documentation for more information.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gm_construct_two()</tt></font><div style="margin-left: 16px">
<p>Uses a gate map object to construct a two-qubit DQCsim gate from the
plugin's representation.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gm_construct_two(
    dqcs_handle_t gm,
    const void *key_data,
    dqcs_qubit_t qa,
    dqcs_qubit_t qb,
    dqcs_handle_t param_data
)
</code></pre>
<p>This function is simply a shorthand for <code>dqcs_gm_construct()</code> with
two qubits in the <code>qubits</code> set, to make constructing two-qubit gates more
ergonomic. Refer to its documentation for more information.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gm_construct_three()</tt></font><div style="margin-left: 16px">
<p>Uses a gate map object to construct a three-qubit DQCsim gate from the
plugin's representation.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gm_construct_three(
    dqcs_handle_t gm,
    const void *key_data,
    dqcs_qubit_t qa,
    dqcs_qubit_t qb,
    dqcs_qubit_t qc,
    dqcs_handle_t param_data
)
</code></pre>
<p>This function is simply a shorthand for <code>dqcs_gm_construct()</code> with
three qubits in the <code>qubits</code> set, to make constructing three-qubit gates
more ergonomic. Refer to its documentation for more information.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gm_construct()</tt></font><div style="margin-left: 16px">
<p>Uses a gate map object to construct a multi-qubit DQCsim gate from the
plugin's representation.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gm_construct(
    dqcs_handle_t gm,
    const void *key_data,
    dqcs_handle_t qubits,
    dqcs_handle_t param_data
)
</code></pre>
<p><code>gm</code> must be a handle to a gate map object (<code>dqcs_mm_new()</code>).
<code>gate</code> must be a handle to a gate. The handle is borrowed; it is not
mutated or deleted.
<code>key_data</code> specifies the gate mapping key for the constructor to use. Note
that the <em>pointer</em> must match exactly to what was specified when the
mapping(s) was/were added.
<code>qubits</code> specifies the qubits arguments for the constructed gate. It is
up to the constructor function to determine how to interpret these. The
parameter is optional; passing 0 is equivalent to passing an empty qubit
set. The handle is deleted if the function succeeds.
<code>param_data</code> specifies the <code>ArbData</code> object used to parameterize the gate.
It is optional; if 0, an empty <code>ArbData</code> is automatically constructed by
DQCsim. The handle is deleted if the function succeeds.</p>
<p>This function returns the handle to the gate, or 0 to indicate failure.
The qubit set and parameterization data (if specified) are consumed/deleted
by this function if and only if it succeeds.</p>
</div></details>
<h2><a class="header" href="#converters" id="converters">Converters</a></h2>
<p>Conceptually, a gate map consists of a number of converter objects, each
typically consisting of a detector function and a constructor function.
In the most generic case, the detector takes a DQCsim gate as its input, and
converts it to a qubit set and an <code>ArbData</code> if it recognizes the gate, while
the constructor performs the inverse operation. Detection is usually fuzzy to
account for floating-point inaccuracies, while construction is as exact as
possible.</p>
<p>These converter objects are stored in the gate map as the values of an ordered
map, for which the key is the user-defined <code>void*</code> key defining the type of
gate. Thus, each converter represents a single gate type. When a gate is to be
detected, DQCsim will call each converter's detector function in insertion
order until one of the detectors returns a match. When a gate is to be
constructed, it simply maps the gate type key to the appropriate converter and
calls only its constructor.</p>
<p>The most generic converter described above can be added to a map with the
following function, but it is also the most complicated to implement.</p>
<details><summary><font color="green"><tt>dqcs_gm_add_custom()</tt></font><div style="margin-left: 16px">
<p>Adds a fully customizable gate mapping to the given gate map.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_gm_add_custom(
    dqcs_handle_t gm,
    void (*key_free)(void *key_data),
    void *key_data,
    dqcs_bool_return_t (*detector)(
        const void *user_data,
        dqcs_handle_t gate,
        dqcs_handle_t *qubits,
        dqcs_handle_t *param_data
    ),
    void (*detector_user_free)(void *user_data),
    void *detector_user_data,
    dqcs_handle_t (*constructor)(
        const void *user_data,
        dqcs_handle_t qubits,
        dqcs_handle_t param_data
    ),
    void (*constructor_user_free)(void *user_data),
    void *constructor_user_data
)
</code></pre>
<p>Note that this is the only type of mapping that can handle custom/named
gates.</p>
<p><code>detector</code> is the detector function pointer. It is optional; if null, this
mapping only supports construction.
<code>detector_user_free</code> is an optional callback function used to free
<code>detector_user_data</code> when the gate map is destroyed, when this function
fails, or when <code>detector</code> was null.
<code>detector_user_data</code> is a user-specified value that is passed to the
<code>detector</code> callback function. It is not used by DQCsim.
<code>constructor</code> is the constructor function pointer. It is optional; if
null, this mapping only supports detection.
<code>constructor_user_free</code> is an optional callback function used to free
<code>constructor_user_data</code> when the gate map is destroyed, when this function
fails, or when <code>constructor</code> was null.
<code>constructor_user_data</code> is a user-specified value that is passed to the
<code>constructor</code> callback function. It is not used by DQCsim.</p>
<p>If both <code>constructor</code> and <code>detector</code> are null for some reason, the
function is no-op (besides possibly calling the <code>*_free()</code> callbacks.</p>
<p>The detector callback receives the complete gate passed to the gate map
for it to match as it pleases. If the gate matches, the detector function
must return <code>DQCS_TRUE</code>. It may  assign <code>qubits</code> to a <code>qbset</code> object
representing the qubit arguments (substituted with an empty set if it
doesn't), and may assign <code>param_data</code> to an <code>arb</code> handle with the
parameterization data (if it doesn't, the data from the gate is used; if
this was modified by the callback, the modified data is used). If the gate
doesn't match, it must return <code>DQCS_FALSE</code>. If an error occurs, it must
call <code>dqcs_error_set()</code> with the error message and return
<code>DQCS_BOOL_FAILURE</code>.</p>
<p>The constructor callback performs the reverse operation. It receives an
<code>ArbData</code> handle containing the parameterization data and a qubit set, and
must construct a gate based on this information. If construction succeeds,
the constructor function must return the gate handle. If an error occurs,
it must call <code>dqcs_error_set()</code> with the error message and return 0.</p>
<p>It is up to the user how to do the matching and constructing, but the
converter functions must always return the same value for the same input.
In other words, they must be pure functions. Otherwise, the caching
behavior of the <code>GateMap</code> will make the results inconsistent.</p>
</div></details>
<p>There is also a specialized version that detects unitary gate matrices instead
of complete gates. This version deals with distinguishing between unitary,
measurement, and custom gates for you. It also converts between DQCsim's
seperate target/control qubit set and the single gate-type-sensitive qubit set
in the plugin representation for you.</p>
<details><summary><font color="green"><tt>dqcs_gm_add_custom_unitary()</tt></font><div style="margin-left: 16px">
<p>Adds a custom unitary gate mapping to the given gate map.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_gm_add_custom_unitary(
    dqcs_handle_t gm,
    void (*key_free)(void *key_data),
    void *key_data,
    dqcs_bool_return_t (*detector)(
        const void *user_data,
        dqcs_handle_t matrix,
        size_t num_controls,
        dqcs_handle_t *param_data
    ),
    void (*detector_user_free)(void *user_data),
    void *detector_user_data,
    dqcs_handle_t (*constructor)(
        const void *user_data,
        dqcs_handle_t *param_data,
        intptr_t *num_controls
    ),
    void (*constructor_user_free)(void *user_data),
    void *constructor_user_data
)
</code></pre>
<p><code>gm</code> must be a handle to a gate map object (<code>dqcs_gm_new()</code>).
<code>key_free</code> is an optional callback function used to free <code>key_data</code> when
the gate map is destroyed, or when this function fails.
<code>key_data</code> is the user-specified value used to identify this mapping.
<code>detector</code> is the detector function pointer. It is optional; if null, this
mapping only supports construction.
<code>detector_user_free</code> is an optional callback function used to free
<code>detector_user_data</code> when the gate map is destroyed, when this function
fails, or when <code>detector</code> was null.
<code>detector_user_data</code> is a user-specified value that is passed to the
<code>detector</code> callback function. It is not used by DQCsim.
<code>constructor</code> is the constructor function pointer. It is optional; if
null, this mapping only supports detection.
<code>constructor_user_free</code> is an optional callback function used to free
<code>constructor_user_data</code> when the gate map is destroyed, when this function
fails, or when <code>constructor</code> was null.
<code>constructor_user_data</code> is a user-specified value that is passed to the
<code>constructor</code> callback function. It is not used by DQCsim.</p>
<p>If both <code>constructor</code> and <code>detector</code> are null for some reason, the
function is no-op (besides possibly calling the <code>*_free()</code> callbacks.</p>
<p>The detector callback receives a matrix and control qubit information for
the user to match. The matrix is passed through the <code>matrix</code> handle.
<code>num_controls</code> is passed the number of explicit control qubits that exist
besides the matrix (that is, if nonzero, the matrix is actually only the
non-controlled submatrix of the controlled gate). <code>param_data</code> is given an
<code>ArbData</code> handle initialized with the <code>ArbData</code> attached to the gate. If
the gate matches, the detector function must return <code>DQCS_TRUE</code>. In this
case, it can mutate the <code>param_data</code> to add the detected gate parameters.
If it doesn't match, it must return <code>DQCS_FALSE</code>. If an error occurs, it
must call <code>dqcs_error_set()</code> with the error message and return
<code>DQCS_BOOL_FAILURE</code>.</p>
<p>The constructor callback performs the reverse operation. It receives an
<code>ArbData</code> handle containing the parameterization data, and must construct
the matrix, return the bound on the number of control qubits, and must
return the <code>ArbData</code> associated with the gate by mutating the <code>param_data</code>
handle. <code>num_controls</code> will point to a variable initialized to -1
representing a constraint on the number of control qubits. This works as
follows: if negative, any number of qubits is allowed; if zero or
positive, only that number is allowed. If construction succeeds, the
constructor function must return a handle to the constructed matrix. If
it fails, it must call <code>dqcs_error_set()</code> with an error message and return
0.</p>
<p>It is up to the user how to do the matching and constructing, but the
converter functions must always return the same value for the same input.
In other words, they must be pure functions. Otherwise, the caching
behavior of the <code>GateMap</code> will make the results inconsistent.</p>
</div></details>
<p>More likely, though, you just want to detect the usual gates, like X, H, swap,
and so on. To help you do this, DQCsim includes built-in converters for every
<code>dqcs_predefined_gate_t</code>, which you can add to the map with the following,
much simpler function.</p>
<details><summary><font color="green"><tt>dqcs_gm_add_predef_unitary()</tt></font><div style="margin-left: 16px">
<p>Adds a unitary gate mapping for the given DQCsim-defined gate to the
given gate map.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_gm_add_predef_unitary(
    dqcs_handle_t gm,
    void (*key_free)(void *user_data),
    void *key_data,
    dqcs_predefined_gate_t gate,
    intptr_t num_controls,
    double epsilon,
    bool ignore_gphase
)
</code></pre>
<p><code>gm</code> must be a handle to a gate map object (<code>dqcs_gm_new()</code>).
<code>key_free</code> is an optional callback function used to free <code>key_data</code> when
the gate map is destroyed, or when this function fails.
<code>key_data</code> is the user-specified value used to identify this mapping.
<code>gate</code> defines which predefined gate to use. Some of the predefined gates
are parameterized.
<code>num_controls</code> specifies the number of control qubits associated with this
gate type. If negative, the gate can have any number of control qubits.
If zero or positive, the number of control qubits must be as specified.
<code>epsilon</code> specifies the maximum element-wise root-mean-square error
between the incoming matrix and the to be detected matrix that results in a
positive match.
<code>ignore_phase</code> specifies whether the aforementioned check should ignore
global phase or not when there are no explicit control qubits.</p>
<p>For most gate types, the parameterization <code>ArbData</code> object returned by
detection and consumed by construction is mapped one-to-one to the user
data of the gate in the DQCsim-protocol. Some of the detectors however
detect parameterized gate matrices. These detectors prefix a fixed number
of binary string arguments to the <code>ArbData</code> upon detection, and pop these
when constructing. The specs for this can be found in the docs for
<code>dqcs_predefined_gate_t</code>.</p>
</div></details>
<p>You can also easily detect gates with a special, fixed matrix.</p>
<details><summary><font color="green"><tt>dqcs_gm_add_fixed_unitary()</tt></font><div style="margin-left: 16px">
<p>Adds a unitary gate mapping for the given gate matrix to the given gate
map.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_gm_add_fixed_unitary(
    dqcs_handle_t gm,
    void (*key_free)(void *key_data),
    void *key_data,
    dqcs_handle_t matrix,
    intptr_t num_controls,
    double epsilon,
    bool ignore_gphase
)
</code></pre>
<p><code>gm</code> must be a handle to a gate map object (<code>dqcs_gm_new()</code>).
<code>key_free</code> is an optional callback function used to free <code>key_data</code> when
the gate map is destroyed, or when this function fails.
<code>key_data</code> is the user-specified value used to identify this mapping.
<code>matrix</code> must be passed a handle to the matrix to detect. It is consumed
by this function.
<code>num_controls</code> specifies the number of control qubits associated with this
gate type. If negative, the gate can have any number of control qubits.
If zero or positive, the number of control qubits must be as specified.
<code>epsilon</code> specifies the maximum element-wise root-mean-square error
between the incoming matrix and the to be detected matrix that results in a
positive match.
<code>ignore_phase</code> specifies whether the aforementioned check should ignore
global phase or not when there are no explicit control qubits.</p>
<p>The parameterization <code>ArbData</code> object returned by detection and consumed
by construction is mapped one-to-one to the user data of the gate in the
DQCsim-protocol.</p>
</div></details>
<p>Finally, you can detect measurement and prep gates with the following built-in
detectors.</p>
<details><summary><font color="green"><tt>dqcs_gm_add_measure()</tt></font><div style="margin-left: 16px">
<p>Adds a measurement gate mapping to the given gate map.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_gm_add_measure(
    dqcs_handle_t gm,
    void (*key_free)(void *user_data),
    void *key_data,
    intptr_t num_measures,
    dqcs_handle_t basis,
    double epsilon
)
</code></pre>
<p><code>gm</code> must be a handle to a gate map object (<code>dqcs_gm_new()</code>).
<code>key_free</code> is an optional callback function used to free <code>key_data</code> when
the gate map is destroyed, or when this function fails.
<code>key_data</code> is the user-specified value used to identify this mapping.
<code>num_measures</code> specifies the number of measured qubits for this gate type.
If negative, the gate can have any number of measured qubits. If zero or
positive, the number of measured qubits must be as specified.
<code>basis</code> optionally specifies a handle to a 2x2 matrix specifying the
measurement basis to be detected. If not specified, the Z basis is used.
The matrix is deleted by the call iff the function succeeds.
<code>epsilon</code> specifies the maximum RMS deviation between the specified basis
(if any) and the incoming basis.</p>
<p>The parameterization <code>ArbData</code> object returned by detection and consumed
by construction is mapped one-to-one to the user data of the gate in the
DQCsim-protocol.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_gm_add_prep()</tt></font><div style="margin-left: 16px">
<p>Adds a prep gate mapping to the given gate map.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_return_t dqcs_gm_add_prep(
    dqcs_handle_t gm,
    void (*key_free)(void *user_data),
    void *key_data,
    intptr_t num_targets,
    dqcs_handle_t basis,
    double epsilon
)
</code></pre>
<p><code>gm</code> must be a handle to a gate map object (<code>dqcs_gm_new()</code>).
<code>key_free</code> is an optional callback function used to free <code>key_data</code> when
the gate map is destroyed, or when this function fails.
<code>key_data</code> is the user-specified value used to identify this mapping.
<code>num_targets</code> specifies the number of target qubits for this gate type.
If negative, the gate can have any number of targets. If zero or
positive, the number of target qubits must be as specified.
<code>basis</code> optionally specifies a handle to a 2x2 matrix specifying the
prep basis. If not specified, the Z basis is used. The matrix is deleted
by the call iff the function succeeds.
<code>epsilon</code> specifies the maximum RMS deviation between the specified basis
(if any) and the incoming basis.</p>
<p>The parameterization <code>ArbData</code> object returned by detection and consumed
by construction is mapped one-to-one to the user data of the gate in the
DQCsim-protocol.</p>
</div></details>
<h2><a class="header" href="#caching" id="caching">Caching</a></h2>
<p>The detection logic in a gate map includes a cache to improve performance
when the same gate is received a number of times. This is quite typical, as
algorithms typically use only a small subset of gates frequently. There are
four different caching strategies:</p>
<ul>
<li>
<p>The cache key is an exact copy of the incoming gate, so the cache only hits
when the exact gate is received twice. In this case, the cache maps directly
to the result of the previous detection, so no detector function needs to be
run. This is the safest option.</p>
</li>
<li>
<p>The cache ignores differing <code>ArbData</code> attachments to the incoming gates.
This is valid only if whether a detector function matches or not is not
sensitive to this <code>ArbData</code>. However, the cache only maps to the matching
detection function, and calls it again for every cache hit. Thus, the
<code>ArbData</code> returned by the detector can still depend on the gate's <code>ArbData</code>.</p>
</li>
<li>
<p>The cache key is a copy of the incoming gate, but without the qubit
references. That is, for example an X gate applied to q1 is considered equal
to an X gate applied to q2. This is valid only if whether a detector
function matches or not is not sensitive to the qubit references. It can,
however, be sensitive to the <em>amount</em> of qubits, and as with the <code>ArbData</code>
insensitivity described above, the detector is still called for each cache
hit and can thus still return a different qubit set.</p>
</li>
<li>
<p>A combination of the latter two, i.e., the cache is not sensitive to either
the gate's <code>ArbData</code> or to the qubit references.</p>
</li>
</ul>
<h2><a class="header" href="#preprocessing" id="preprocessing">Preprocessing</a></h2>
<p>To be as compatible with other plugins as possible, you may want to preprocess
the incoming gates with either <code>dqcs_gate_reduce_control()</code> or
<code>dqcs_gate_expand_control()</code>. We already went over these in the previous
section, but their description is repeated here for convenience.</p>
<p>When you apply <code>dqcs_gate_reduce_control()</code> to each incoming gate before
passing it to <code>dqcs_gm_detect()</code>, you ensure that if the upstream plugin is
sending for instance a CNOT using a complete two-qubit gate matrix and two
target qubits, it will still be detected as a controlled X gate with one
control qubit, instead of some different gate.</p>
<p>You can also choose to do the opposite, converting from for instance DQCsim's
controlled X representation to a full CNOT matrix using
<code>dqcs_gate_expand_control</code>. However, in this case you'll have to detect
controlled matrices with <code>dqcs_gm_add_fixed_unitary()</code> or a fully custom
implementation, as DQCsim only provided predefined matrices for the
non-controlled (sub)matrices.</p>
<h2><a class="header" href="#constructing-a-gate-map" id="constructing-a-gate-map">Constructing a gate map</a></h2>
<p>Having read all of the above, you should be ready to construct a new gate map.
The construction function takes the caching strategy as its parameters, as well
as two optional callback functions used to compare and hash your plugin's key
type, needed for the internal hashmap mapping from key to converter object.</p>
<details><summary><font color="green"><tt>dqcs_gm_new()</tt></font><div style="margin-left: 16px">
<p>Constructs a new gate map.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_gm_new(
    bool strip_qubit_refs,
    bool strip_data,
    bool (*key_cmp)(
        const void,
        const void
    ),
    uint64_t (*key_hash)(const void)
)
</code></pre>
<p>Returns a handle to a gate map with no mappings attached to it yet. Use
<code>dqcs_gm_add_*()</code> to do that. The mappings are queried in the order in
which they are added, so be sure to add more specific gates first. Once
added, use <code>dqcs_gm_detect()</code> to detect incoming DQCsim gates, and
<code>dqcs_gm_construct*()</code> to (re)construct gates for transmission.</p>
<p>Gate maps objects retain a cache to speed up detection of similar DQCsim
gates: if a gate is received for the second time, the cache will hit,
avoiding recomputation of the detector functions. What constitutes
&quot;similar gates&quot; is defined by the two booleans passed to this function. If
<code>strip_qubit_refs</code> is set, all qubit references associated with the gate
will be invalidated (i.e., set to 0), such that for instance an X gate
applied to qubit 1 will be considered equal to an X gate applied to qubit
2. If <code>strip_data</code> is set, the <code>ArbData</code> associated with the incoming
gate is removed.</p>
<p>Gates are identified through user-defined <code>void*</code> keys. To do the above,
however, DQCsim needs to know the following things:</p>
<ul>
<li>how to delete an owned copy of a key if your semantics are that DQCsim
owns it,</li>
<li>how to compare two keys (equality);</li>
<li>how to hash a key.</li>
</ul>
<p>The deletion function is passed when the key is passed. If the keys are
objects of different classes, this allows different constructors to be
passed here. There can only be a single comparison and hash function for
each gate map, though. They are passed here.</p>
<p><code>key_cmp</code> represents this comparison function. It takes two <code>void*</code> to
keys and must returns whether they are equal or not. If not specified,
the default is to compare the pointers themselves, instead of the values
they refer to. <code>key_cmp</code> must be a pure function, i.e., depend only on its
input values.</p>
<p><code>key_hash</code> represents the hashing function. It takes a <code>void*</code> key and
returns a 64-bit hash representative of the key. <strong>For any pair of keys
for which <code>key_cmp</code> returns true, the hashes must be equal.</strong> The default
behavior depends on whether <code>key_cmp</code> is defined: if it is, all keys will
have the same hash; if it isn't, the pointer is itself hashed. <code>key_hash</code>
must be a pure function, i.e., depend only on its input values.</p>
<p>It is recommended to first preprocess incoming gates with
<code>dqcs_gate_reduce_control()</code>. In this case, controlled unitary gate
matrices will be reduced to their non-controlled submatrix, such that the
unitary gate detectors will operate on said submatrix. The predefined
unitary gate detectors are more-or-less based on this assumption (as there
are no predefined controlled matrices).</p>
<p>Alternatively, you can preprocess with <code>dqcs_gate_expand_control()</code>. In
this case, you can use <code>dqcs_gm_add_fixed_unitary()</code> to detect the full
matrix in all cases, by specifying the CNOT matrix instead of an X matrix
with one control qubit.</p>
<p>If you don't preprocess, the upstream plugin determines the
representation. That is, it may send a CNOT as a two-qubit gate with a
CNOT matrix or as a controlled X gate with a single target and single
control qubit. The gate map will then detect these as two different kinds
of gates.</p>
</div></details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../c-api/gate.apigen.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../c-api/measurements.apigen.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../c-api/gate.apigen.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../c-api/measurements.apigen.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
