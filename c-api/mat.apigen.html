<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Matrices: dqcs_mat_* - DQCsim</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction to DQCsim</a></li><li><ol class="section"><li class="expanded "><a href="../intro/components.html"><strong aria-hidden="true">1.1.</strong> The components of a simulation</a></li><li><ol class="section"><li class="expanded "><a href="../intro/frontend.html"><strong aria-hidden="true">1.1.1.</strong> Frontend use cases</a></li><li class="expanded "><a href="../intro/backend.html"><strong aria-hidden="true">1.1.2.</strong> Backend use cases</a></li><li class="expanded "><a href="../intro/operator.html"><strong aria-hidden="true">1.1.3.</strong> Operator use cases</a></li><li class="expanded "><a href="../intro/host.html"><strong aria-hidden="true">1.1.4.</strong> Host use cases</a></li></ol></li><li class="expanded "><a href="../intro/puzzle.html"><strong aria-hidden="true">1.2.</strong> Jigsaw puzzle analogy</a></li><li class="expanded "><a href="../intro/interfaces.html"><strong aria-hidden="true">1.3.</strong> DQCsim's interfaces</a></li><li><ol class="section"><li class="expanded "><a href="../intro/arbs.html"><strong aria-hidden="true">1.3.1.</strong> ArbData and ArbCmds</a></li><li class="expanded "><a href="../intro/gatestream.html"><strong aria-hidden="true">1.3.2.</strong> Gate- and measurement streams</a></li><li class="expanded "><a href="../intro/host-iface.html"><strong aria-hidden="true">1.3.3.</strong> The host interface</a></li><li class="expanded "><a href="../intro/misc-iface.html"><strong aria-hidden="true">1.3.4.</strong> Miscellaneous interfaces</a></li></ol></li><li class="expanded "><a href="../intro/reproducibility.html"><strong aria-hidden="true">1.4.</strong> Reproducibility</a></li></ol></li><li class="expanded "><a href="../install/index.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li><ol class="section"><li class="expanded "><a href="../install/plugins.html"><strong aria-hidden="true">2.1.</strong> Plugin distribution</a></li></ol></li><li class="expanded "><a href="../cli/index.html"><strong aria-hidden="true">3.</strong> The command-line interface</a></li><li class="expanded "><a href="../python-api/index.html"><strong aria-hidden="true">4.</strong> Python API</a></li><li><ol class="section"><li class="expanded "><a href="../python-api/hello-world.html"><strong aria-hidden="true">4.1.</strong> Hello, world!</a></li><li class="expanded "><a href="../python-api/debugging.html"><strong aria-hidden="true">4.2.</strong> Debugging</a></li><li class="expanded "><a href="../python-api/sending-gates.html"><strong aria-hidden="true">4.3.</strong> Sending some gates</a></li><li class="expanded "><a href="../python-api/simulations.html"><strong aria-hidden="true">4.4.</strong> Controlling simulations</a></li><li class="expanded "><a href="../python-api/operator.html"><strong aria-hidden="true">4.5.</strong> Inserting an operator</a></li><li class="expanded "><a href="../python-api/reference.html"><strong aria-hidden="true">4.6.</strong> Reference</a></li></ol></li><li class="expanded "><a href="../c-api/index.html"><strong aria-hidden="true">5.</strong> C API</a></li><li><ol class="section"><li class="expanded "><a href="../c-api/usage.html"><strong aria-hidden="true">5.1.</strong> Usage</a></li><li class="expanded "><a href="../c-api/concepts.apigen.html"><strong aria-hidden="true">5.2.</strong> Concepts</a></li><li><ol class="section"><li class="expanded "><a href="../c-api/handle.apigen.html"><strong aria-hidden="true">5.2.1.</strong> Handles: dqcs_handle_*</a></li><li class="expanded "><a href="../c-api/memory-management.apigen.html"><strong aria-hidden="true">5.2.2.</strong> Memory management</a></li><li class="expanded "><a href="../c-api/error.apigen.html"><strong aria-hidden="true">5.2.3.</strong> Error handling: dqcs_error_*</a></li><li class="expanded "><a href="../c-api/callbacks.apigen.html"><strong aria-hidden="true">5.2.4.</strong> Callbacks</a></li></ol></li><li class="expanded "><a href="../c-api/type-definitions.apigen.html"><strong aria-hidden="true">5.3.</strong> Type definitions: dqcs_*_t</a></li><li class="expanded "><a href="../c-api/arb-cmd-cq.apigen.html"><strong aria-hidden="true">5.4.</strong> ArbData and ArbCmd objects</a></li><li><ol class="section"><li class="expanded "><a href="../c-api/arb.apigen.html"><strong aria-hidden="true">5.4.1.</strong> ArbData objects: dqcs_arb_*</a></li><li class="expanded "><a href="../c-api/cmd.apigen.html"><strong aria-hidden="true">5.4.2.</strong> ArbCmd objects: dqcs_cmd_*</a></li><li class="expanded "><a href="../c-api/cq.apigen.html"><strong aria-hidden="true">5.4.3.</strong> ArbCmd queues: dqcs_cq_*</a></li></ol></li><li class="expanded "><a href="../c-api/qbset.apigen.html"><strong aria-hidden="true">5.5.</strong> Qubits: dqcs_qbset_*</a></li><li class="expanded "><a href="../c-api/mat.apigen.html" class="active"><strong aria-hidden="true">5.6.</strong> Matrices: dqcs_mat_*</a></li><li class="expanded "><a href="../c-api/gate.apigen.html"><strong aria-hidden="true">5.7.</strong> Gates: dqcs_gate_*</a></li><li class="expanded "><a href="../c-api/gm.apigen.html"><strong aria-hidden="true">5.8.</strong> Gate maps: dqcs_gm_*</a></li><li class="expanded "><a href="../c-api/measurements.apigen.html"><strong aria-hidden="true">5.9.</strong> Measurements</a></li><li><ol class="section"><li class="expanded "><a href="../c-api/meas.apigen.html"><strong aria-hidden="true">5.9.1.</strong> Singular measurements: dqcs_meas_*</a></li><li class="expanded "><a href="../c-api/mset.apigen.html"><strong aria-hidden="true">5.9.2.</strong> Measurement sets: dqcs_mset_*</a></li></ol></li><li class="expanded "><a href="../c-api/plugins.apigen.html"><strong aria-hidden="true">5.10.</strong> Plugins</a></li><li><ol class="section"><li class="expanded "><a href="../c-api/pdef.apigen.html"><strong aria-hidden="true">5.10.1.</strong> Defining a plugin: dqcs_pdef_*</a></li><li class="expanded "><a href="../c-api/plugin-run.apigen.html"><strong aria-hidden="true">5.10.2.</strong> Running a plugin: dqcs_plugin_*</a></li><li class="expanded "><a href="../c-api/plugin-interact.apigen.html"><strong aria-hidden="true">5.10.3.</strong> Interacting with DQCsim: dqcs_plugin_*</a></li><li class="expanded "><a href="../c-api/log.apigen.html"><strong aria-hidden="true">5.10.4.</strong> Logging: dqcs_log_*</a></li></ol></li><li class="expanded "><a href="../c-api/simulations.apigen.html"><strong aria-hidden="true">5.11.</strong> Simulations</a></li><li><ol class="section"><li class="expanded "><a href="../c-api/pcfg.apigen.html"><strong aria-hidden="true">5.11.1.</strong> Configuring plugins: dqcs_pcfg_*</a></li><li class="expanded "><a href="../c-api/tcfg.apigen.html"><strong aria-hidden="true">5.11.2.</strong> Running local plugins: dqcs_tcfg_*</a></li><li class="expanded "><a href="../c-api/scfg.apigen.html"><strong aria-hidden="true">5.11.3.</strong> Configuring a simulation: dqcs_scfg_*</a></li><li class="expanded "><a href="../c-api/sim.apigen.html"><strong aria-hidden="true">5.11.4.</strong> Running a simulation: dqcs_sim_*</a></li></ol></li><li class="expanded "><a href="../c-api/reference.apigen.html"><strong aria-hidden="true">5.12.</strong> Reference</a></li></ol></li><li class="expanded "><a href="../cpp-api/index.html"><strong aria-hidden="true">6.</strong> C++ API</a></li><li><ol class="section"><li class="expanded "><a href="../cpp-api/usage.html"><strong aria-hidden="true">6.1.</strong> Usage</a></li><li class="expanded "><a href="../cpp-api/ccompare.html"><strong aria-hidden="true">6.2.</strong> Comparison to the C API</a></li><li class="expanded "><a href="../cpp-api/plugin.html"><strong aria-hidden="true">6.3.</strong> Plugin anatomy</a></li><li class="expanded "><a href="../cpp-api/sim.html"><strong aria-hidden="true">6.4.</strong> Host/simulation anatomy</a></li><li class="expanded "><a href="../cpp-api/reference.html"><strong aria-hidden="true">6.5.</strong> Reference</a></li></ol></li><li class="expanded "><a href="../rust-api/index.html"><strong aria-hidden="true">7.</strong> Rust API</a></li><li class="expanded affix "><a href="../release.html">Release</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">DQCsim</h1>

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#matrices" id="matrices">Matrices</a></h1>
<p>The last component we need to describe a quantum gate is a unitary matrix.
DQCsim internally represents all normal gates (that is, everything except
measurements and custom gates) using such matrices as a universal format that
all plugins must be able to deal with. Note that <a href="gm.apigen.html">Gate maps</a> can
help you with converting between this format and the format your plugin uses,
if they differ.</p>
<p>To prevent DQCsim from turning into a math library, its matrix API is very
basic. Matrices are constructed from a C array of its elements and are
subsequently immutable.</p>
<details><summary><font color="green"><tt>dqcs_mat_new()</tt></font><div style="margin-left: 16px">
<p>Constructs a new gate matrix.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_mat_new(
    size_t num_qubits,
    const double *matrix
)
</code></pre>
<p><code>num_qubits</code> must be set to the number of qubits mutated by this matrix.
It must be greater than or equal to zero.
<code>matrix</code> must point to an appropriately sized array of doubles. The matrix
is specified in row-major form, using pairs of doubles for the real vs.
imaginary component of each entry. The size must be <code>4**num_qubits</code> complex
numbers = <code>2*4**num_qubits</code> doubles = <code>16*4**num_qubits</code> bytes,
representing a <code>2**num_qubits</code> by <code>2**num_qubits</code> matrix.
This function returns the constructed matrix handle, or 0 if an error
occurs.</p>
<p>While not enforced at this level, the matrix is normally unitary, or
approximately so within some floating-point error margin.</p>
<p>This function returns the handle to the matrix, or 0 to indicate failure.</p>
</div></details>
<p>The following functions can be used to query the size of a matrix.</p>
<details><summary><font color="green"><tt>dqcs_mat_len()</tt></font><div style="margin-left: 16px">
<p>Returns the number of complex entries in the given matrix.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_mat_len(dqcs_handle_t mat)
</code></pre>
<p>This function returns -1 when an error occurs.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_mat_dimension()</tt></font><div style="margin-left: 16px">
<p>Returns the dimension (number of rows == number of columns) of the given
matrix.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_mat_dimension(dqcs_handle_t mat)
</code></pre>
<p>This function returns -1 when an error occurs.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_mat_num_qubits()</tt></font><div style="margin-left: 16px">
<p>Returns the number of qubits targeted by the given matrix.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">ssize_t dqcs_mat_num_qubits(dqcs_handle_t mat)
</code></pre>
<p>This function returns -1 when an error occurs.</p>
</div></details>
<p>The C array can of course also be recovered again.</p>
<details><summary><font color="green"><tt>dqcs_mat_get()</tt></font><div style="margin-left: 16px">
<p>Returns a copy of the contained matrix as a C array.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">double *dqcs_mat_get(dqcs_handle_t mat)
</code></pre>
<p>If this function succeeds, the matrix is returned in row-major form, using
pairs of doubles for the real vs. imaginary component of each entry. The
size will be <code>4**num_qubits</code> complex numbers = <code>2*4**num_qubits</code> doubles =
<code>16*4**num_qubits</code> bytes. A newly allocated matrix is returned; <strong>free it
with <code>free()</code> when you're done with it to avoid memory leaks.</strong> On failure,
this function returns <code>NULL</code>.</p>
</div></details>
<p>The primary use of this is to put all the complexity of converting between the
C and internal DQCsim representation of such a matrix in a single place. This
is particularly important for some of the gate map detector and constructor
callbacks. However, DQCsim does provide some matrix operations that are common
when dealing with gate detection and construction, but not so much anywhere
else.</p>
<h2><a class="header" href="#matrix-equality" id="matrix-equality">Matrix equality</a></h2>
<p>A very common operation in DQCsim is matrix equality. An operator plugin may
for instance want to detect whether a matrix is an X matrix. Getting this right
is unfortunately difficult, due to floating point roundoff errors, numerical
instability here and there, or (specifically to quantum gates) differences in
global phase. For this reason, DQCsim provides an equality check function.</p>
<details><summary><font color="green"><tt>dqcs_mat_approx_eq()</tt></font><div style="margin-left: 16px">
<p>Approximately compares two matrices.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_mat_approx_eq(
    dqcs_handle_t a,
    dqcs_handle_t b,
    double epsilon,
    bool ignore_gphase
)
</code></pre>
<p><code>a</code> and <code>b</code> are borrowed matrix handles.
<code>epsilon</code> specifies the maximum element-wise root-mean-square error
between the matrices that results in a positive match. <code>ignore_gphase</code>
specifies whether the check should ignore global phase.</p>
<p>If ignore_gphase is set, this checks that the following holds for some x:</p>
<p>\[
A \cdot e^{ix} \approx B
\]</p>
<p>This function returns <code>DQCS_TRUE</code> if the matrices match according to the
aforementioned criteria, or <code>DQCS_FALSE</code> if not. <code>DQCS_BOOL_ERROR</code> is used
when either handle is invalid or not a matrix. If the matrices differ in
dimensionality, <code>DQCS_FALSE</code> is used.</p>
</div></details>
<h2><a class="header" href="#unitary-check" id="unitary-check">Unitary check</a></h2>
<p>DQCsim also exposes a unitary check, which it uses internally here and there
anyway.</p>
<details><summary><font color="green"><tt>dqcs_mat_approx_unitary()</tt></font><div style="margin-left: 16px">
<p>Returns whether the matrix is approximately unitary.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_mat_approx_unitary(
    dqcs_handle_t matrix,
    double epsilon
)
</code></pre>
<p><code>matrix</code> is a borrowed handle to the matrix to check.
<code>epsilon</code> specifies the maximum element-wise root-mean-square error
between the product of the matrix and its hermetian compared to the
identity matrix.</p>
<p>This function returns <code>DQCS_TRUE</code> if the matrix is approximately unitary,
or <code>DQCS_FALSE</code> if not. <code>DQCS_BOOL_ERROR</code> is used when either handle is
invalid or not a matrix.</p>
</div></details>
<h2><a class="header" href="#predefined-matrices" id="predefined-matrices">Predefined matrices</a></h2>
<p>DQCsim provides a number of predefined gate matrices. These are identified by
the <code>dqcs_predefined_gate_t</code> enumeration.</p>
<details><summary><font color="purple"><tt>dqcs_predefined_gate_t</tt></font><div style="margin-left: 16px">
<p>Enumeration of gates defined by DQCsim.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_predefined_gate_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_GATE_INVALID = 0</tt></font></summary><div style="margin-left: 16px">
Invalid gate. Used as an error return value.
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_PAULI_I = 100</tt></font></summary><div style="margin-left: 16px">
The identity gate for a single qubit.
<p>\[
I = \sigma_0 = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; 1
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_PAULI_X = 101</tt></font></summary><div style="margin-left: 16px">
The Pauli X matrix.
<p>\[
X = \sigma_1 = \begin{bmatrix}
0 &amp; 1 \\
1 &amp; 0
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_PAULI_Y = 102</tt></font></summary><div style="margin-left: 16px">
The Pauli Y matrix.
<p>\[
Y = \sigma_2 = \begin{bmatrix}
0 &amp; -i \\
i &amp; 0
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_PAULI_Z = 103</tt></font></summary><div style="margin-left: 16px">
The Pauli Z matrix.
<p>\[
Z = \sigma_3 = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; -1
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_H = 104</tt></font></summary><div style="margin-left: 16px">
The hadamard gate matrix. That is, a 180-degree Y rotation, followed by
a 90-degree X rotation.
<p>\[
H = \frac{1}{\sqrt{2}} \begin{bmatrix}
1 &amp; 1 \\
1 &amp; -1
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_S = 105</tt></font></summary><div style="margin-left: 16px">
The S matrix, also known as a 90 degree Z rotation.
<p>\[
S = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; i
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_S_DAG = 106</tt></font></summary><div style="margin-left: 16px">
The S-dagger matrix, also known as a negative 90 degree Z rotation.
<p>\[
S^\dagger = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; -i
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_T = 107</tt></font></summary><div style="margin-left: 16px">
The T matrix, also known as a 45 degree Z rotation.
<p>\[
T = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; e^{i\frac{\pi}{4}}
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_T_DAG = 108</tt></font></summary><div style="margin-left: 16px">
The T-dagger matrix, also known as a negative 45 degree Z rotation.
<p>\[
T^\dagger = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; e^{-i\frac{\pi}{4}}
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RX_90 = 109</tt></font></summary><div style="margin-left: 16px">
Rx(90°) gate.
<p>\[
R_x\left(\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}} \begin{bmatrix}
1 &amp; -i \\
-i &amp; 1
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RX_M90 = 110</tt></font></summary><div style="margin-left: 16px">
Rx(-90°) gate.
<p>\[
R_x\left(-\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}} \begin{bmatrix}
1 &amp; i \\
i &amp; 1
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RX_180 = 111</tt></font></summary><div style="margin-left: 16px">
Rx(180°) gate.
<p>\[
R_x(\pi) = \begin{bmatrix}
0 &amp; -i \\
-i &amp; 0
\end{bmatrix}
\]</p>
<p>This matrix is equivalent to the Pauli X gate, but differs in global
phase. Note that this difference is significant when it is used as a
submatrix for a controlled gate.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RY_90 = 112</tt></font></summary><div style="margin-left: 16px">
Ry(90°) gate.
<p>\[
R_y\left(\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}} \begin{bmatrix}
1 &amp; -1 \\
1 &amp; 1
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RY_M90 = 113</tt></font></summary><div style="margin-left: 16px">
Ry(-90°) gate.
<p>\[
R_y\left(\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}} \begin{bmatrix}
1 &amp; 1 \\
-1 &amp; 1
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RY_180 = 114</tt></font></summary><div style="margin-left: 16px">
Ry(180°) gate.
<p>\[
R_y(\pi) = \begin{bmatrix}
0 &amp; -1 \\
1 &amp; 0
\end{bmatrix}
\]</p>
<p>This matrix is equivalent to the Pauli Y gate, but differs in global
phase. Note that this difference is significant when it is used as a
submatrix for a controlled gate.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RZ_90 = 115</tt></font></summary><div style="margin-left: 16px">
Rz(90°) gate.
<p>\[
R_z\left(\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}} \begin{bmatrix}
1-i &amp; 0 \\
0 &amp; 1+i
\end{bmatrix}
\]</p>
<p>This matrix is equivalent to the S gate, but differs in global phase.
Note that this difference is significant when it is used as a submatrix
for a controlled gate.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RZ_M90 = 116</tt></font></summary><div style="margin-left: 16px">
Rz(-90°) gate.
<p>\[
R_z\left(-\frac{\pi}{2}\right) = \frac{1}{\sqrt{2}} \begin{bmatrix}
1+i &amp; 0 \\
0 &amp; 1-i
\end{bmatrix}
\]</p>
<p>This matrix is equivalent to the S-dagger gate, but differs in global
phase. Note that this difference is significant when it is used as a
submatrix for a controlled gate.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RZ_180 = 117</tt></font></summary><div style="margin-left: 16px">
Rz(180°) gate.
<p>\[
R_z(\pi) = \begin{bmatrix}
-i &amp; 0 \\
0 &amp; i
\end{bmatrix}
\]</p>
<p>This matrix is equivalent to the Pauli Z gate, but differs in global
phase. Note that this difference is significant when it is used as a
submatrix for a controlled gate.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RX = 150</tt></font></summary><div style="margin-left: 16px">
The matrix for an arbitrary X rotation.
<p>\[
R_x(\theta) = \begin{bmatrix}
\cos{\frac{\theta}{2}} &amp; -i\sin{\frac{\theta}{2}} \\
-i\sin{\frac{\theta}{2}} &amp; \cos{\frac{\theta}{2}}
\end{bmatrix}
\]</p>
<p>θ is specified or returned through the first binary string argument
of the parameterization ArbData object. It is represented as a
little-endian double floating point value, specified in radians.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RY = 151</tt></font></summary><div style="margin-left: 16px">
The matrix for an arbitrary Y rotation.
<p>\[
R_y(\theta) = \begin{bmatrix}
\cos{\frac{\theta}{2}} &amp; -\sin{\frac{\theta}{2}} \\
\sin{\frac{\theta}{2}} &amp; \cos{\frac{\theta}{2}}
\end{bmatrix}
\]</p>
<p>θ is specified or returned through the first binary string argument
of the parameterization ArbData object. It is represented as a
little-endian double floating point value, specified in radians.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_RZ = 152</tt></font></summary><div style="margin-left: 16px">
The matrix for an arbitrary Z rotation.
<p>\[
R_z(\theta) = \begin{bmatrix}
e^{-i\frac{\theta}{2}} &amp; 0 \\
0 &amp; e^{i\frac{\theta}{2}}
\end{bmatrix}
\]</p>
<p>θ is specified or returned through the first binary string argument
of the parameterization ArbData object. It is represented as a
little-endian double floating point value, specified in radians.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_PHASE_K = 153</tt></font></summary><div style="margin-left: 16px">
The matrix for a Z rotation with angle π/2^k.
<p>\[
\textit{PhaseK}(k) = \textit{Phase}\left(\frac{\pi}{2^k}\right) = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; e^{i\pi / 2^k}
\end{bmatrix}
\]</p>
<p>k is specified or returned through the first binary string argument
of the parameterization ArbData object. It is represented as a
little-endian unsigned 64-bit integer.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_PHASE = 154</tt></font></summary><div style="margin-left: 16px">
The matrix for an arbitrary Z rotation.
<p>\[
\textit{Phase}(\theta) = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; e^{i\theta}
\end{bmatrix}
\]</p>
<p>θ is specified or returned through the first binary string argument
of the parameterization ArbData object. It is represented as a
little-endian double floating point value, specified in radians.</p>
<p>This matrix is equivalent to the Rz gate, but differs in global phase.
Note that this difference is significant when it is used as a submatrix
for a controlled gate. Specifically, controlled phase gates use the
phase as specified by this gate, whereas Rz follows the usual algebraic
notation.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_U1 = 190</tt></font></summary><div style="margin-left: 16px">
Any single-qubit unitary gate, parameterized as a full unitary matrix.
<p>The full matrix is specified or returned through the first binary string
argument of the parameterization ArbData object. It is represented as an
array of little-endian double floating point values, structured as
real/imag pairs, with the pairs in row-major order.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_R = 191</tt></font></summary><div style="margin-left: 16px">
Arbitrary rotation matrix.
<p>\[
R(\theta, \phi, \lambda) = \begin{bmatrix}
\cos{\frac{\theta}{2}} &amp; -\sin{\frac{\theta}{2}} e^{i\lambda} \\
\sin{\frac{\theta}{2}} e^{i\phi} &amp; \cos{\frac{\theta}{2}} e^{i\phi + i\lambda}
\end{bmatrix}
\]</p>
<p>This is equivalent to the following:</p>
<p>\[
R(\theta, \phi, \lambda) = \textit{Phase}(\phi) \cdot R_y(\theta) \cdot \textit{Phase}(\lambda)
\]</p>
<p>The rotation order and phase is taken from Qiskit's U3 gate. Ignoring
global phase, any unitary single-qubit gate can be represented with this
notation.</p>
<p>θ, φ, and λ are specified or returned through the first three binary
string arguments of the parameterization ArbData object. They are
represented as little-endian double floating point values, specified in
radians.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_SWAP = 200</tt></font></summary><div style="margin-left: 16px">
The swap gate matrix.
<p>\[
\textit{SWAP} = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_SQRT_SWAP = 201</tt></font></summary><div style="margin-left: 16px">
The square-root of a swap gate matrix.
<p>\[
\sqrt{\textit{SWAP}} = \begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \frac{i+1}{2} &amp; \frac{i-1}{2} &amp; 0 \\
0 &amp; \frac{i-1}{2} &amp; \frac{i+1}{2} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_U2 = 290</tt></font></summary><div style="margin-left: 16px">
Any two-qubit unitary gate, parameterized as a full unitary matrix.
<p>The full matrix is specified or returned through the first binary string
argument of the parameterization ArbData object. It is represented as an
array of little-endian double floating point values, structured as
real/imag pairs, with the pairs in row-major order.</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_GATE_U3 = 390</tt></font></summary><div style="margin-left: 16px">
Any three-qubit unitary gate, parameterized as a full unitary matrix.
<p>The full matrix is specified or returned through the first binary string
argument of the parameterization ArbData object. It is represented as an
array of little-endian double floating point values, structured as
real/imag pairs, with the pairs in row-major order.</p>
</div></details>
</p>
</div></details>
<p>Given such a variant and an <code>ArbData</code> object with the parameters described in
the enum variant documentation, a matrix can be constructed.</p>
<details><summary><font color="green"><tt>dqcs_mat_predef()</tt></font><div style="margin-left: 16px">
<p>Constructs a new gate matrix for one of DQCsim's predefined gates.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_mat_predef(
    dqcs_predefined_gate_t gate_type,
    dqcs_handle_t param_data
)
</code></pre>
<p><code>gate_type</code> specifies which kind of gate should be constructed.</p>
<p><code>param_data</code> takes an optional <code>ArbData</code> object used to parameterize the
matrix if necessary. If not specified, an empty object is used. The
<code>ArbData</code> representation for each gate can be found in the docs for
<code>dqcs_predefined_gate_t</code>. If nothing is specified, no <code>ArbData</code> is used.</p>
<p>This function returns the handle to the matrix, or 0 to indicate failure.
The parameterization data (if specified) is consumed/deleted by this
function if and only if it succeeds.</p>
</div></details>
<p>DQCsim also provides the reverse operation: going from a matrix matching a
given gate type to its parameterization. This matrix detection uses the
internal equivalent of <code>dqcs_mat_approx_eq</code>, so its parameters are also needed
here.</p>
<details><summary><font color="green"><tt>dqcs_mat_is_predef()</tt></font><div style="margin-left: 16px">
<p>Returns whether this matrix is of the given predefined form and, if it is,
any parameters needed to describe it.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_mat_is_predef(
    dqcs_handle_t mat,
    dqcs_predefined_gate_t gate_type,
    dqcs_handle_t *param_data,
    double epsilon,
    bool ignore_gphase
)
</code></pre>
<p><code>mat</code> is a borrowed handle to the matrix to check.
<code>gate_type</code> specifies which kind of gate should be detected.
<code>param_data</code>, if non-null, receives a new <code>ArbData</code> handle with
parameterization data, or an empty <code>ArbData</code> if the gate is not
parameterized; the caller must delete this object when it is done with
it. This function always writes the 0 handle to this return parameter if
it fails. The <code>ArbData</code> representation can be found in the documentation
for <code>dqcs_predefined_gate_t</code>.</p>
<p><code>epsilon</code> specifies the maximum element-wise root-mean-square error
between the matrices that results in a positive match. <code>ignore_gphase</code>
specifies whether the check should ignore global phase.</p>
<p>This function returns <code>DQCS_TRUE</code> if the matrices match according to the
aforementioned criteria, or <code>DQCS_FALSE</code> if not. <code>DQCS_BOOL_ERROR</code> is used
when either handle is invalid or not a matrix. If the matrices differ in
dimensionality, <code>DQCS_FALSE</code> is used.</p>
</div></details>
<p>Note that these two functions are only the most basic form for constructing and
detecting gates using some higher abstraction level. If you feel like you're
using these functions a lot, you should probably use a <a href="gm.apigen.html">gate map</a>
instead.</p>
<h2><a class="header" href="#control-normalization" id="control-normalization">Control normalization</a></h2>
<p>DQCsim allows controlled quantum gates to be specified either with an explicit
set of control qubits and the non-controlled submatrix, or the full controlled
matrix. The canonical form within DQCsim is the former, as operating on only
the submatrices may improve performance, and gives you controlled gates for
free. In some cases however, the user may wish to convert between the two
representations. DQCsim provides higher-level functions to do this as part of
the gate API, but you can also call the low-level matrix conversion functions
manually as follows.</p>
<details><summary><font color="green"><tt>dqcs_mat_add_controls()</tt></font><div style="margin-left: 16px">
<p>Constructs a controlled matrix from the given matrix.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_mat_add_controls(
    dqcs_handle_t mat,
    size_t number_of_controls
)
</code></pre>
<p><code>mat</code> specifies the matrix to use as the non-controlled submatrix. This
is a borrowed handle. <code>number_of_controls</code> specifies the number of control
qubits to add. This function returns a new matrix handle with the
constructed matrix, or 0 if it fails.</p>
</div></details>
<details><summary><font color="green"><tt>dqcs_mat_strip_control()</tt></font><div style="margin-left: 16px">
<p>Splits a controlled matrix into its non-controlled submatrix and the
indices of the control qubits.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_mat_strip_control(
    dqcs_handle_t mat,
    double epsilon,
    bool ignore_global_phase,
    ssize_t **control_indices
)
</code></pre>
<p><code>mat</code> specifies the matrix to modify. This is a borrowed handle.
<code>epsilon</code> specifies the maximum magitude of the difference between the
column vectors of the input matrix and the identity matrix (after
dephasing if <code>ignore_gphase</code> is set) for the column vector to be
considered to not affect the respective entry in the quantum state
vector. Note that if this is greater than zero, the resulting gate may
not be exactly equivalent. If <code>ignore_global_phase</code> is set, any global
phase in the matrix is ignored, but note that if control qubits are
stripped the &quot;global&quot; phase of the resulting submatrix is always
significant.
<code>control_indices</code> is a return argument through which DQCsim will pass
the indices of the qubits that were removed in the process of constructing
the submatrix. This is represented as an array of indices terminated by
a -1 entry. The returned matrix <strong>must be freed using <code>free()</code> when you
are done with it to avoid memory leaks.</strong> This function returns a new
matrix handle with the submatrix, or 0 if it fails. In this case,
<code>control_indices</code> is not mutated.</p>
<p>This function assumes that the incoming matrix is unitary (within
<code>epsilon</code>) without verifying that this is the case. The results may
thus be invalid if it was not.</p>
</div></details>
<h2><a class="header" href="#basis-matrices" id="basis-matrices">Basis matrices</a></h2>
<p>TODO: someone who knows what they're talking about should check/correct this
section at some point. I'm mostly working off of hunches. - Jeroen</p>
<p>DQCsim uses 2x2 matrices to represent the basis for a measurement or prep gate
to operate on. The intuitive nature of these matrices is as follows for
measurements:</p>
<ul>
<li>apply the Hermetian/conjugate transpose/inverse of the basis matrix as a
gate to each measured qubit;</li>
<li>do a Z-basis measurement;</li>
<li>apply the basis matrix as a gate to each measured qubit.</li>
</ul>
<p>Basically, the application of the inverse of the matrix rotates the state of
the qubits from the desired basis to the Z basis, then a Z measurement is
applied, then the application of the basis matrix rotates the state back to
the desired basis.</p>
<p>The semantics for prep gates are basically the same:</p>
<ul>
<li>initialize the state of each qubit to |0&gt;;</li>
<li>apply the basis matrix as a gate to each targeted qubit.</li>
</ul>
<p>With this definition, the basis matrices can be written as follows.</p>
<details><summary><font color="purple"><tt>dqcs_basis_t</tt></font><div style="margin-left: 16px">
<p>Enumeration of Pauli bases.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">typedef enum { ... } dqcs_basis_t;
</code></pre>
<p>Variants:</p>
<p>
<details><summary><font color="blue"><tt>DQCS_BASIS_INVALID = 0</tt></font></summary><div style="margin-left: 16px">
Invalid basis. Used as an error return value.
</div></details>
<details><summary><font color="blue"><tt>DQCS_BASIS_X = 1</tt></font></summary><div style="margin-left: 16px">
The X basis.
<p>\[
\psi_X = \frac{1}{\sqrt{2}} \begin{bmatrix}
1 &amp; -1 \\
1 &amp; 1
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_BASIS_Y = 2</tt></font></summary><div style="margin-left: 16px">
The Y basis.
<p>\[
\psi_Y = \frac{1}{\sqrt{2}} \begin{bmatrix}
1 &amp; i \\
i &amp; 1
\end{bmatrix}
\]</p>
</div></details>
<details><summary><font color="blue"><tt>DQCS_BASIS_Z = 3</tt></font></summary><div style="margin-left: 16px">
The Z basis.
<p>\[
\psi_Z = \begin{bmatrix}
1 &amp; 0 \\
0 &amp; 1
\end{bmatrix}
\]</p>
</div></details>
</p>
</div></details>
<p>... and constructed as follows:</p>
<details><summary><font color="green"><tt>dqcs_mat_basis()</tt></font><div style="margin-left: 16px">
<p>Constructs a matrix with the eigenvectors of one of the Pauli matrices
as column vectors.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_handle_t dqcs_mat_basis(dqcs_basis_t basis)
</code></pre>
<p>This can be used for constructing measurement or prep gates with the
given basis. Returns a new handle to the constructed matrix or returns
0 if an error occurs.</p>
</div></details>
<p>Basis matrices can be compared with the following function. This function
ignores any of the phase differences that don't affect the basis in its
approximate equality function.</p>
<details><summary><font color="green"><tt>dqcs_mat_basis_approx_eq()</tt></font><div style="margin-left: 16px">
<p>Approximately compares two basis matrices.</p>
</div></summary><div style="margin-left: 16px">
<pre><code class="language-C">dqcs_bool_return_t dqcs_mat_basis_approx_eq(
    dqcs_handle_t a,
    dqcs_handle_t b,
    double epsilon
)
</code></pre>
<p><code>a</code> and <code>b</code> are borrowed matrix handles.
<code>epsilon</code> specifies the maximum element-wise root-mean-square error
between the matrices that results in a positive match.</p>
<p>This checks that the following holds for some x and y:</p>
<p>\[
A \cdot \begin{bmatrix}
e^{ix} &amp; 0 \\
0 &amp; e^{iy}
\end{bmatrix} \approx B
\]</p>
<p>This function returns <code>DQCS_TRUE</code> if the matrices match according to the
aforementioned criteria, or <code>DQCS_FALSE</code> if not. <code>DQCS_BOOL_ERROR</code> is used
when either handle is invalid or not a matrix. If either matrix is not
2x2, <code>DQCS_FALSE</code> is used.</p>
</div></details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../c-api/qbset.apigen.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../c-api/gate.apigen.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../c-api/qbset.apigen.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../c-api/gate.apigen.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
