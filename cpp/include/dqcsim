// <dqcsim> -*- C++ -*-

#ifndef _DQCSIM_INCLUDED_
#define _DQCSIM_INCLUDED_

#include <stdexcept>
#include <string>
#include <vector>
#include <cstring>
#include <iostream>
#include <cdqcsim>

namespace dqcsim {

/**
 * Namespace containing thin wrapper objects around the handles exposed by
 * the raw C interface.
 */
namespace wrap {

  /**
   * Checks a `dqcs_return_t` return value; if failure, throws a runtime error
   * with DQCsim's error message.
   */
  inline void check(raw::dqcs_return_t code) {
    if (code == raw::dqcs_return_t::DQCS_FAILURE) {
      throw std::runtime_error(raw::dqcs_error_get());
    }
  }

  /**
   * Checks a `dqcs_bool_return_t` return value; if failure, throws a runtime
   * error with DQCsim's error message.
   */
  inline bool check(raw::dqcs_bool_return_t code) {
    if (code == raw::dqcs_bool_return_t::DQCS_BOOL_FAILURE) {
      throw std::runtime_error(raw::dqcs_error_get());
    } else if (code == raw::dqcs_bool_return_t::DQCS_TRUE) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * Checks a `dqcs_handle_t` or `dqcs_qubit_t` return value; if failure,
   * throws a runtime error with DQCsim's error message.
   */
  inline unsigned long long check(unsigned long long handle) {
    if (handle == 0) {
      throw std::runtime_error(raw::dqcs_error_get());
    }
    return handle;
  }

  /**
   * Checks a `dqcs_cycle_t` return value; if failure, throws a runtime error
   * with DQCsim's error message.
   */
  inline raw::dqcs_cycle_t check(raw::dqcs_cycle_t cycle) {
    if (cycle == -1) {
      throw std::runtime_error(raw::dqcs_error_get());
    }
    return cycle;
  }

  /**
   * Checks a size return value; if failure, throws a runtime error
   * with DQCsim's error message.
   */
  inline size_t check(ssize_t size) {
    if (size < 0) {
      throw std::runtime_error(raw::dqcs_error_get());
    }
    return static_cast<size_t>(size);
  }

  /**
   * Checks a `dqcs_handle_type_t` return value; if failure, throws a runtime
   * error with DQCsim's error message.
   */
  inline raw::dqcs_handle_type_t check(raw::dqcs_handle_type_t type) {
    if (type == raw::dqcs_handle_type_t::DQCS_HTYPE_INVALID) {
      throw std::runtime_error(raw::dqcs_error_get());
    }
    return type;
  }

  /**
   * Checks a `dqcs_loglevel_t` return value; if failure, throws a runtime
   * error with DQCsim's error message.
   */
  inline raw::dqcs_loglevel_t check(raw::dqcs_loglevel_t level) {
    if (level == raw::dqcs_loglevel_t::DQCS_LOG_INVALID) {
      throw std::runtime_error(raw::dqcs_error_get());
    }
    return level;
  }

  /**
   * Checks a `dqcs_measurement_t` return value; if failure, throws a runtime
   * error with DQCsim's error message.
   */
  inline raw::dqcs_measurement_t check(raw::dqcs_measurement_t measurement) {
    if (measurement == raw::dqcs_measurement_t::DQCS_MEAS_INVALID) {
      throw std::runtime_error(raw::dqcs_error_get());
    }
    return measurement;
  }

  /**
   * Checks a `dqcs_path_style_t` return value; if failure, throws a runtime
   * error with DQCsim's error message.
   */
  inline raw::dqcs_path_style_t check(raw::dqcs_path_style_t style) {
    if (style == raw::dqcs_path_style_t::DQCS_PATH_STYLE_INVALID) {
      throw std::runtime_error(raw::dqcs_error_get());
    }
    return style;
  }

  /**
   * Checks a `dqcs_plugin_type_t` return value; if failure, throws a runtime
   * error with DQCsim's error message.
   */
  inline raw::dqcs_plugin_type_t check(raw::dqcs_plugin_type_t type) {
    if (type == raw::dqcs_plugin_type_t::DQCS_PTYPE_INVALID) {
      throw std::runtime_error(raw::dqcs_error_get());
    }
    return type;
  }

  /**
   * Checks a pointer return value; if failure, throws a runtime error with
   * DQCsim's error message.
   */
  template <typename T>
  inline T *check(T *pointer) {
    if (pointer == nullptr) {
      throw std::runtime_error(raw::dqcs_error_get());
    }
    return pointer;
  }

  /**
   * Base class for wrapping any handle.
   */
  class Handle {
  protected:

    /**
     * The wrapped handle.
     */
    raw::dqcs_handle_t handle;

  public:

    /**
     * Wrap the given raw handle.
     */
    Handle(raw::dqcs_handle_t handle) : handle(handle) {
    }

    /**
     * Delete the handle and its wrapper.
     */
    virtual ~Handle() noexcept {
      if (handle) {
        raw::dqcs_handle_delete(handle);
      }
    }

    /**
     * Explicitly delete the handle, allowing errors to be caught.
     */
    void free() {
      check(raw::dqcs_handle_delete(handle));
      handle = 0;
    }

    /**
     * Returns whether this wrapper (still) contains a valid handle.
     */
    bool is_valid() const noexcept {
      return raw::dqcs_handle_type(handle)
        != raw::dqcs_handle_type_t::DQCS_HTYPE_INVALID;
    }

    /**
     * Returns the raw handle without relinquishing ownership.
     */
    raw::dqcs_handle_t get() const noexcept {
      return handle;
    }

    /**
     * Unwrap the raw handle; that is, without deleting it. By moving the
     * wrapper into the static function (in conjunction with the lack of a copy
     * constructor) the compiler can statically check that the wrapper object
     * is not reused.
     */
    raw::dqcs_handle_t take() noexcept {
      raw::dqcs_handle_t h = handle;
      handle = 0;
      return h;
    }

    // Handles cannot usually be copied, so delete the copy constructor and
    // copy assignment operator. Moving is fine, though.
    Handle(const Handle&) = delete;
    void operator=(const Handle&) = delete;
    Handle(Handle &&handle) = default;
    Handle &operator=(Handle&&) = default;

    /**
     * Returns a string containing a debug dump of the handle.
     */
    std::string dump() const {
      char *dump_c = check(raw::dqcs_handle_dump(handle));
      std::string dump(dump_c);
      std::free(dump_c);
      return dump;
    }

    /**
     * Write the debug dump string of the handle to the given output stream.
     */
    friend std::ostream& operator<<(std::ostream &out, const Handle &handle) {
      out << handle.dump();
      return out;
    }

    /**
     * Return the raw handle type for the given handle.
     */
    raw::dqcs_handle_type_t type() const {
      return check(raw::dqcs_handle_type(handle));
    }

  };

  /**
   * Class wrapper for handles that support the `arb` interface.
   */
  class Arb : virtual public Handle {
  public:

    /**
     * Wrap the given `arb` handle.
     */
    Arb(raw::dqcs_handle_t handle) : Handle(handle) {
    }

    /**
     * Returns the current arbitrary JSON data as a serialized JSON string.
     */
    std::string get_arb_json_string() const {
      char *json_c = check(raw::dqcs_arb_json_get(handle));
      std::string json(json_c);
      std::free(json_c);
      return json;
    }

    /**
     * Sets the arbitrary JSON data to the given serialized JSON string.
     */
    void set_arb_json_string(const std::string &json) {
      check(raw::dqcs_arb_json_set(handle, json.c_str()));
    }

    /**
     * Returns the current arbitrary JSON data as a serialized CBOR string.
     */
    std::string get_arb_cbor_string() const {
      size_t size = check(raw::dqcs_arb_cbor_get(handle, nullptr, 0));
      std::string cbor;
      cbor.resize(size);
      check(raw::dqcs_arb_cbor_get(handle, &cbor.front(), size));
      return cbor;
    }

    /**
     * Sets the arbitrary JSON data to the given serialized CBOR string.
     */
    void set_arb_cbor_string(const std::string &cbor) {
      check(raw::dqcs_arb_cbor_set(handle, cbor.data(), cbor.size()));
    }

    /**
     * Returns the current arbitrary JSON data as a JSON object from
     * `nlohmann::json`. Since that is a header-only library that isn't usually
     * installed system-wide and be using a specific version in your project
     * already, you need to specify the `nlohmann::json` type as a generic to
     * this function.
     *
     * WARNING: this function returns a *copy* of the JSON data embedded in the
     * `ArbData`. Therefore, modifying the returned JSON object does *not*
     * modify the original `ArbData`. To modify, you need to pass the modified
     * JSON object to `set_arb_json()`.
     */
    template <class JSON>
    JSON get_arb_json() const {
      size_t size = check(raw::dqcs_arb_cbor_get(handle, nullptr, 0));
      std::vector<uint8_t> cbor;
      cbor.resize(size);
      check(raw::dqcs_arb_cbor_get(handle, &cbor.front(), size));
      return JSON::from_cbor(cbor);
    }

    /**
     * Sets the arbitrary JSON data to the given JSON object from
     * `nlohmann::json`. Since that is a header-only library that isn't usually
     * installed system-wide and be using a specific version in your project
     * already, you need to specify the `nlohmann::json` type as a generic to
     * this function.
     */
    template <class JSON>
    void set_arb_json(const JSON &json) {
      std::vector<uint8_t> cbor = JSON::to_cbor(json);
      check(raw::dqcs_arb_cbor_set(handle, cbor.data(), cbor.size()));
    }

    /**
     * Returns the arbitrary argument at the given index as a (binary) string.
     * Negative indices are relative to the back of the list, as in Python.
     */
    std::string get_arb_arg_string(ssize_t index) const {
      size_t size = check(raw::dqcs_arb_get_size(handle, index));
      std::string data;
      data.resize(size);
      check(raw::dqcs_arb_get_raw(handle, index, &data.front(), size));
      return data;
    }

    /**
     * Returns the arbitrary argument at the given index as the given type.
     * Negative indices are relative to the back of the list, as in Python.
     *
     * WARNING: type `T` must be a primitive value (like an `int`) or a struct
     * thereof, without pointers or any other "complicated" constructs. DQCsim
     * just copies the bytes over. It is up to you to ensure that that's what
     * you want to happen; unfortunately C++11 does not provide a way to
     * statically ensure that this is the case.
     */
    template <typename T>
    T get_arb_arg_as(ssize_t index) const {
      size_t size = check(raw::dqcs_arb_get_size(handle, index));
      if (size != sizeof(T)) {
        throw std::runtime_error(
          "Arbitrary argument has incorrect size: "
          "found " + std::to_string(size) + " bytes, "
          "expected " + std::to_string(sizeof(T)) + " bytes");
      }
      T data;
      check(raw::dqcs_arb_get_raw(handle, index, &data, sizeof(data)));
      return data;
    }

    /**
     * Sets the arbitrary argument list to the given iterable of
     * `std::string`s.
     */
    template <typename T>
    void set_arb_arg_strings(const T &strings) {
      clear_arb_args();
      for (const std::string &string : strings) {
        push_arb_arg_string(string);
      }
    }

    /**
     * Sets the arbitrary argument at the given index to a (binary) string.
     * Negative indices are relative to the back of the list, as in Python.
     */
    void set_arb_arg_string(ssize_t index, const std::string &data) {
      check(raw::dqcs_arb_set_raw(handle, index, data.data(), data.size()));
    }

    /**
     * Sets the arbitrary argument at the given index to a value of type `T`.
     * Negative indices are relative to the back of the list, as in Python.
     *
     * WARNING: type `T` must be a primitive value (like an `int`) or a struct
     * thereof, without pointers or any other "complicated" constructs. DQCsim
     * just copies the bytes over. It is up to you to ensure that that's what
     * you want to happen; unfortunately C++11 does not provide a way to
     * statically ensure that this is the case.
     */
    template <typename T>
    void set_arb_arg(ssize_t index, const T &data) {
      check(raw::dqcs_arb_set_raw(handle, index, &data, sizeof(data)));
    }

    /**
     * Pushes a (binary) string to the back of the arbitrary argument list.
     */
    void push_arb_arg_string(const std::string &data) {
      check(raw::dqcs_arb_push_raw(handle, data.data(), data.size()));
    }

    /**
     * Pushes a value of type `T` to the back of the arbitrary argument list.
     *
     * WARNING: type `T` must be a primitive value (like an `int`) or a struct
     * thereof, without pointers or any other "complicated" constructs. DQCsim
     * just copies the bytes over. It is up to you to ensure that that's what
     * you want to happen; unfortunately C++11 does not provide a way to
     * statically ensure that this is the case.
     */
    template <typename T>
    void push_arb_arg(const T &data) {
      check(raw::dqcs_arb_push_raw(handle, &data, sizeof(data)));
    }

    /**
     * Pops from the back of the arbitrary argument list as a (binary) string.
     */
    std::string pop_arb_arg_string() {
      size_t size = check(raw::dqcs_arb_get_size(handle, -1));
      std::string data;
      data.resize(size);
      check(raw::dqcs_arb_pop_raw(handle, &data.front(), size));
      return data;
    }

    /**
     * Pops from the back of the arbitrary argument list as a value of type
     * `T`.
     *
     * WARNING: type `T` must be a primitive value (like an `int`) or a struct
     * thereof, without pointers or any other "complicated" constructs. DQCsim
     * just copies the bytes over. It is up to you to ensure that that's what
     * you want to happen; unfortunately C++11 does not provide a way to
     * statically ensure that this is the case.
     */
    template <typename T>
    T pop_arb_arg_as() const {
      size_t size = check(raw::dqcs_arb_get_size(handle, -1));
      if (size != sizeof(T)) {
        throw std::runtime_error(
          "Arbitrary argument has incorrect size: "
          "found " + std::to_string(size) + " bytes, "
          "expected " + std::to_string(sizeof(T)) + " bytes");
      }
      T data;
      check(raw::dqcs_arb_pop_raw(handle, &data, sizeof(data)));
      return data;
    }

    /**
     * Inserts an arbitrary argument at the given index using a (binary)
     * string. Negative indices are relative to the back of the list, as in
     * Python.
     */
    void insert_arb_arg_string(ssize_t index, const std::string &data) {
      check(raw::dqcs_arb_insert_raw(handle, index, data.data(), data.size()));
    }

    /**
     * Inserts an arbitrary argument at the given index using a value of type
     * `T`. Negative indices are relative to the back of the list, as in
     * Python.
     *
     * WARNING: type `T` must be a primitive value (like an `int`) or a struct
     * thereof, without pointers or any other "complicated" constructs. DQCsim
     * just copies the bytes over. It is up to you to ensure that that's what
     * you want to happen; unfortunately C++11 does not provide a way to
     * statically ensure that this is the case.
     */
    template <typename T>
    void insert_arb_arg(ssize_t index, const T &data) {
      check(raw::dqcs_arb_insert_raw(handle, index, &data, sizeof(data)));
    }

    /**
     * Removes the arbitrary argument at the given index. Negative indices are
     * relative to the back of the list, as in Python.
     */
    void remove_arb_arg(ssize_t index) {
      check(raw::dqcs_arb_remove(handle, index));
    }

    /**
     * Returns the number of arbitrary arguments.
     */
    size_t get_arb_arg_count() const {
      return check(raw::dqcs_arb_len(handle));
    }

    /**
     * Clears the arbitrary argument list.
     */
    void clear_arb_args() {
      check(raw::dqcs_arb_clear(handle));
    }

  };

  /**
   * Class wrapper for `ArbData` handles.
   */
  class ArbData : public Arb {
  public:

    /**
     * Constructs an empty `ArbData` object.
     */
    ArbData() : Handle(check(raw::dqcs_arb_new())), Arb(/*unused*/0) {
    }

    /**
     * Copy-constructs an `ArbData` object from any object supporting the `Arb`
     * interface.
     */
    ArbData(const Arb &src) : Handle(check(raw::dqcs_arb_new())), Arb(/*unused*/0) {
      check(raw::dqcs_arb_assign(handle, src.get()));
    }

    /**
     * Copy-constructs an `ArbData` object from another `ArbData` object.
     */
    ArbData(const ArbData &src) : Handle(check(raw::dqcs_arb_new())), Arb(/*unused*/0) {
      check(raw::dqcs_arb_assign(handle, src.get()));
    }

    /**
     * Copy assignment operator for `ArbData` objects.
     */
    void operator=(const ArbData &src) {
      check(raw::dqcs_arb_assign(handle, src.get()));
    }

  };

  /**
   * Class wrapper for handles that support the `cmd` interface.
   */
  class Cmd : virtual public Arb {
  public:

    /**
     * Wrap the given `cmd` handle.
     */
    Cmd(raw::dqcs_handle_t handle) : Handle(handle), Arb(/*unused*/0) {
    }

    /**
     * Returns the interface identifier of this command.
     */
    std::string get_iface() const {
      char *iface_c = check(raw::dqcs_cmd_iface_get(handle));
      std::string iface(iface_c);
      std::free(iface_c);
      return iface;
    }

    /**
     * Returns whether this command has the given interface identifier.
     */
    bool is_iface(const std::string &iface) const {
      return check(raw::dqcs_cmd_iface_cmp(handle, iface.c_str()));
    }

    /**
     * Returns the operation identifier of this command.
     */
    std::string get_oper() const {
      char *oper_c = check(raw::dqcs_cmd_oper_get(handle));
      std::string oper(oper_c);
      std::free(oper_c);
      return oper;
    }

    /**
     * Returns whether this command has the given operation identifier.
     */
    bool is_oper(const std::string &oper) const {
      return check(raw::dqcs_cmd_oper_cmp(handle, oper.c_str()));
    }

  };

  /**
   * Class wrapper for `ArbCmd` handles.
   */
  class ArbCmd : public Cmd {
  public:

    /**
     * Constructs an `ArbCmd` object.
     */
    ArbCmd(const std::string &iface, const std::string &oper) : Handle(check(raw::dqcs_cmd_new(
      iface.c_str(), oper.c_str()
    ))), Cmd(/*unused*/0), Arb(/*unused*/0) {
    }

    /**
     * Copy-constructs an `ArbCmd` object from any object supporting the `Cmd`
     * interface.
     */
    ArbCmd(const Cmd &src) : Handle(check(raw::dqcs_cmd_new(
      src.get_iface().c_str(), src.get_oper().c_str()
    ))), Cmd(/*unused*/0), Arb(/*unused*/0) {
      check(raw::dqcs_arb_assign(handle, src.get()));
    }

    /**
     * Copy-constructs an `ArbCmd` object from another `ArbCmd` object.
     */
    ArbCmd(const ArbCmd &src) : Handle(check(raw::dqcs_cmd_new(
      src.get_iface().c_str(), src.get_oper().c_str()
    ))), Cmd(/*unused*/0), Arb(/*unused*/0) {
      check(raw::dqcs_arb_assign(handle, src.get()));
    }

    /**
     * Copy assignment operator for `ArbCmd` objects.
     */
    void operator=(const ArbCmd &src) {
      // The C API doesn't allow `ArbCmd`s to be copied natively, so we need to
      // make a new one and drop the old handle. We make the copy before
      // exchanging the handles to avoid changing our state if the copy
      // operation throws an error for some reason.
      ArbCmd copy(src);
      free();
      handle = copy.take();
    }

  };

  /**
   * Class wrapper for `ArbCmd` queue handles.
   *
   * To construct an `ArbCmd` queue iteratively, create a new queue using the
   * default constructor and push `ArbCmd`s into it using `push()`. Note that
   * there is an rvalue reference `push()` operation that entirely avoids
   * copying the `ArbCmd`. You can also construct the queue from an iterable of
   * `ArbCmd`s directly; again, including a zero-copy function using an rvalue
   * reference.
   *
   * To iterate over an existing `ArbCmd` queue (destructively!) in the most
   * efficient way, use the following code:
   *
   * ```
   * for (; queue.size() > 0; queue.next()) {
   *   // queue can be used as the current cmd/arb without any copies now
   * }
   * ```
   *
   * You can also drain it into a `std::vector` of `ArbCmd`s, or (if you must)
   * copy it into one.
   */
  class ArbCmdQueue : public Cmd {
  public:

    /**
     * Constructs an empty `ArbCmd` queue object.
     */
    ArbCmdQueue() : Handle(check(raw::dqcs_cq_new())), Cmd(/*unused*/0), Arb(/*unused*/0) {
    }

    /**
     * Constructs an `ArbCmd` queue object from an iterable of `ArbCmd`s by
     * copying.
     */
    template <class T>
    ArbCmdQueue(const T &cmds) : Handle(check(raw::dqcs_cq_new())), Cmd(/*unused*/0), Arb(/*unused*/0) {
      for (const Cmd &cmd : cmds) {
        push(cmd);
      }
    }

    /**
     * Constructs an `ArbCmd` queue object from an iterable of `ArbCmd`s by
     * moving.
     */
    template <class T>
    ArbCmdQueue(T &&cmds) : Handle(check(raw::dqcs_cq_new())), Cmd(/*unused*/0), Arb(/*unused*/0) {
      for (const Cmd &cmd : cmds) {
        push(std::move(cmd));
      }
    }

    /**
     * Pushes an `ArbCmd` into the queue by copying.
     */
    void push(const Cmd &cmd) {
      ArbCmd copy(cmd);
      check(raw::dqcs_cq_push(handle, copy.take()));
    }

    /**
     * Pushes an `ArbCmd` into the queue by moving.
     */
    void push(ArbCmd &&cmd) {
      check(raw::dqcs_cq_push(handle, cmd.take()));
    }

    /**
     * Pops the first `ArbCmd` from the queue, allowing the next one to be
     * accessed.
     */
    void next() {
      check(raw::dqcs_cq_next(handle));
    }

    /**
     * Returns the number of `ArbCmd`s in the queue.
     */
    size_t size() const {
      return check(raw::dqcs_cq_len(handle));
    }

    /**
     * Drains the queue into a vector of `ArbCmd`s. This is less performant
     * than iterating over the queue manually, because it requires copies.
     */
    std::vector<ArbCmd> drain_into_vector() {
      std::vector<ArbCmd> cmds;
      for (; size() > 0; next()) {
        cmds.emplace_back(*this);
      }
      return cmds;
    }

    /**
     * Copies the queue into a vector of `ArbCmd`s. This is less performant
     * than iterating over the queue manually or using `drain_into_vector()`,
     * because it requires (additional) copies.
     *
     * NOTE: this function is not `const`, because exceptions during the copy
     * operation can change its value, and the underlying handle is changed.
     * However, under normal conditions, the contents appear to be unchanged.
     */
    std::vector<ArbCmd> copy_into_vector() {
      std::vector<ArbCmd> cmds = drain_into_vector();
      free();
      ArbCmdQueue copy(cmds);
      handle = copy.take();
      return cmds;
    }

  };

} // namespace wrap

} // namespace dqcsim

#endif

