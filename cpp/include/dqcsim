// <dqcsim> -*- C++ -*-

#ifndef _DQCSIM_INCLUDED_
#define _DQCSIM_INCLUDED_

#include <stdexcept>
#include <string>
#include <vector>
#include <cstring>
#include <iostream>
#include <complex>
#include <cdqcsim>

namespace dqcsim {

/**
 * Namespace containing thin wrapper objects around the handles exposed by
 * the raw C interface.
 */
namespace wrap {

  /**
   * Checks a `dqcs_return_t` return value; if failure, throws a runtime error
   * with DQCsim's error message.
   */
  inline void check(raw::dqcs_return_t code) {
    if (code == raw::dqcs_return_t::DQCS_FAILURE) {
      throw std::runtime_error(raw::dqcs_error_get());
    }
  }

  /**
   * Checks a `dqcs_bool_return_t` return value; if failure, throws a runtime
   * error with DQCsim's error message.
   */
  inline bool check(raw::dqcs_bool_return_t code) {
    if (code == raw::dqcs_bool_return_t::DQCS_BOOL_FAILURE) {
      throw std::runtime_error(raw::dqcs_error_get());
    } else if (code == raw::dqcs_bool_return_t::DQCS_TRUE) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * Checks a `dqcs_handle_t` or `dqcs_qubit_t` return value; if failure,
   * throws a runtime error with DQCsim's error message.
   */
  inline unsigned long long check(unsigned long long handle) {
    if (handle == 0) {
      throw std::runtime_error(raw::dqcs_error_get());
    }
    return handle;
  }

  /**
   * Checks a `dqcs_cycle_t` return value; if failure, throws a runtime error
   * with DQCsim's error message.
   */
  inline raw::dqcs_cycle_t check(raw::dqcs_cycle_t cycle) {
    if (cycle == -1) {
      throw std::runtime_error(raw::dqcs_error_get());
    }
    return cycle;
  }

  /**
   * Checks a size return value; if failure, throws a runtime error
   * with DQCsim's error message.
   */
  inline size_t check(ssize_t size) {
    if (size < 0) {
      throw std::runtime_error(raw::dqcs_error_get());
    }
    return static_cast<size_t>(size);
  }

  /**
   * Checks a `dqcs_handle_type_t` return value; if failure, throws a runtime
   * error with DQCsim's error message.
   */
  inline raw::dqcs_handle_type_t check(raw::dqcs_handle_type_t type) {
    if (type == raw::dqcs_handle_type_t::DQCS_HTYPE_INVALID) {
      throw std::runtime_error(raw::dqcs_error_get());
    }
    return type;
  }

  /**
   * Checks a `dqcs_loglevel_t` return value; if failure, throws a runtime
   * error with DQCsim's error message.
   */
  inline raw::dqcs_loglevel_t check(raw::dqcs_loglevel_t level) {
    if (level == raw::dqcs_loglevel_t::DQCS_LOG_INVALID) {
      throw std::runtime_error(raw::dqcs_error_get());
    }
    return level;
  }

  /**
   * More C++-like wrapper for `raw::dqcs_measurement_t`, not including the
   * `invalid` option (since we use exceptions to communicate failure).
   */
  enum class MeasurementValue {
    Zero = 0,
    One = 1,
    Undefined = 2
  };

  /**
   * Converts a `MeasurementValue` to its raw C enum.
   */
  inline raw::dqcs_measurement_t measurement_value_to_raw(MeasurementValue measurement) {
    switch (measurement) {
      case MeasurementValue::Zero:      return raw::dqcs_measurement_t::DQCS_MEAS_ZERO;
      case MeasurementValue::One:       return raw::dqcs_measurement_t::DQCS_MEAS_ONE;
      case MeasurementValue::Undefined: return raw::dqcs_measurement_t::DQCS_MEAS_UNDEFINED;
    }
  }

  /**
   * Checks a `dqcs_measurement_t` return value and converts it to its C++
   * enum representation; if failure, throws a runtime error with DQCsim's
   * error message.
   */
  inline MeasurementValue check(raw::dqcs_measurement_t measurement) {
    switch (measurement) {
      case raw::dqcs_measurement_t::DQCS_MEAS_ZERO:      return MeasurementValue::Zero;
      case raw::dqcs_measurement_t::DQCS_MEAS_ONE:       return MeasurementValue::One;
      case raw::dqcs_measurement_t::DQCS_MEAS_UNDEFINED: return MeasurementValue::Undefined;
    }
    throw std::runtime_error(raw::dqcs_error_get());
  }

  /**
   * Checks a `dqcs_path_style_t` return value; if failure, throws a runtime
   * error with DQCsim's error message.
   */
  inline raw::dqcs_path_style_t check(raw::dqcs_path_style_t style) {
    if (style == raw::dqcs_path_style_t::DQCS_PATH_STYLE_INVALID) {
      throw std::runtime_error(raw::dqcs_error_get());
    }
    return style;
  }

  /**
   * Checks a `dqcs_plugin_type_t` return value; if failure, throws a runtime
   * error with DQCsim's error message.
   */
  inline raw::dqcs_plugin_type_t check(raw::dqcs_plugin_type_t type) {
    if (type == raw::dqcs_plugin_type_t::DQCS_PTYPE_INVALID) {
      throw std::runtime_error(raw::dqcs_error_get());
    }
    return type;
  }

  /**
   * Checks a pointer return value; if failure, throws a runtime error with
   * DQCsim's error message.
   */
  template <typename T>
  inline T *check(T *pointer) {
    if (pointer == nullptr) {
      throw std::runtime_error(raw::dqcs_error_get());
    }
    return pointer;
  }

  /**
   * Base class for wrapping any handle.
   */
  class Handle {
  protected:

    /**
     * The wrapped handle.
     */
    raw::dqcs_handle_t handle;

  public:

    /**
     * Wrap the given raw handle.
     */
    Handle(raw::dqcs_handle_t handle) : handle(handle) {
    }

    /**
     * Delete the handle and its wrapper.
     */
    virtual ~Handle() noexcept {
      if (handle) {
        raw::dqcs_handle_delete(handle);
      }
    }

    /**
     * Explicitly delete the handle, allowing errors to be caught.
     */
    void free() {
      check(raw::dqcs_handle_delete(handle));
      handle = 0;
    }

    /**
     * Returns whether this wrapper (still) contains a valid handle.
     */
    bool is_valid() const noexcept {
      return raw::dqcs_handle_type(handle)
        != raw::dqcs_handle_type_t::DQCS_HTYPE_INVALID;
    }

    /**
     * Returns the raw handle without relinquishing ownership.
     */
    raw::dqcs_handle_t get_handle() const noexcept {
      return handle;
    }

    /**
     * Unwrap the raw handle; that is, without deleting it. By moving the
     * wrapper into the static function (in conjunction with the lack of a copy
     * constructor) the compiler can statically check that the wrapper object
     * is not reused.
     */
    raw::dqcs_handle_t take_handle() noexcept {
      raw::dqcs_handle_t h = handle;
      handle = 0;
      return h;
    }

    // Handles cannot usually be copied, so delete the copy constructor and
    // copy assignment operator.
    Handle(const Handle&) = delete;
    void operator=(const Handle&) = delete;

    /**
     * Move constructor; simply move ownership of the handle.
     */
    Handle(Handle &&src) : handle(src.handle) {
      src.handle = 0;
    }

    /**
     * Move assignment; simply move ownership of the handle.
     */
    Handle &operator=(Handle &&src) {
      handle = src.handle;
      src.handle = 0;
      return *this;
    }

    /**
     * Returns a string containing a debug dump of the handle.
     */
    std::string dump() const {
      char *dump_c = check(raw::dqcs_handle_dump(handle));
      std::string dump(dump_c);
      std::free(dump_c);
      return dump;
    }

    /**
     * Write the debug dump string of the handle to the given output stream.
     */
    friend std::ostream& operator<<(std::ostream &out, const Handle &handle) {
      out << handle.dump();
      return out;
    }

    /**
     * Return the raw handle type for the given handle.
     */
    raw::dqcs_handle_type_t type() const {
      return check(raw::dqcs_handle_type(handle));
    }

  };

  /**
   * Class wrapper for handles that support the `arb` interface.
   */
  class Arb : public Handle {
  public:

    /**
     * Wrap the given `arb` handle.
     */
    Arb(raw::dqcs_handle_t handle) : Handle(handle) {
    }

    /**
     * Returns the current arbitrary JSON data as a serialized JSON string.
     */
    std::string get_arb_json_string() const {
      char *json_c = check(raw::dqcs_arb_json_get(handle));
      std::string json(json_c);
      std::free(json_c);
      return json;
    }

    /**
     * Sets the arbitrary JSON data to the given serialized JSON string.
     */
    void set_arb_json_string(const std::string &json) {
      check(raw::dqcs_arb_json_set(handle, json.c_str()));
    }

    /**
     * Returns the current arbitrary JSON data as a serialized CBOR string.
     */
    std::string get_arb_cbor_string() const {
      size_t size = check(raw::dqcs_arb_cbor_get(handle, nullptr, 0));
      std::string cbor;
      cbor.resize(size);
      check(raw::dqcs_arb_cbor_get(handle, &cbor.front(), size));
      return cbor;
    }

    /**
     * Sets the arbitrary JSON data to the given serialized CBOR string.
     */
    void set_arb_cbor_string(const std::string &cbor) {
      check(raw::dqcs_arb_cbor_set(handle, cbor.data(), cbor.size()));
    }

    /**
     * Returns the current arbitrary JSON data as a JSON object from
     * `nlohmann::json`. Since that is a header-only library that isn't usually
     * installed system-wide and be using a specific version in your project
     * already, you need to specify the `nlohmann::json` type as a generic to
     * this function.
     *
     * WARNING: this function returns a *copy* of the JSON data embedded in the
     * `ArbData`. Therefore, modifying the returned JSON object does *not*
     * modify the original `ArbData`. To modify, you need to pass the modified
     * JSON object to `set_arb_json()`.
     */
    template <class JSON>
    JSON get_arb_json() const {
      size_t size = check(raw::dqcs_arb_cbor_get(handle, nullptr, 0));
      std::vector<uint8_t> cbor;
      cbor.resize(size);
      check(raw::dqcs_arb_cbor_get(handle, &cbor.front(), size));
      return JSON::from_cbor(cbor);
    }

    /**
     * Sets the arbitrary JSON data to the given JSON object from
     * `nlohmann::json`. Since that is a header-only library that isn't usually
     * installed system-wide and be using a specific version in your project
     * already, you need to specify the `nlohmann::json` type as a generic to
     * this function.
     */
    template <class JSON>
    void set_arb_json(const JSON &json) {
      std::vector<uint8_t> cbor = JSON::to_cbor(json);
      check(raw::dqcs_arb_cbor_set(handle, cbor.data(), cbor.size()));
    }

    /**
     * Returns the arbitrary argument at the given index as a (binary) string.
     * Negative indices are relative to the back of the list, as in Python.
     */
    std::string get_arb_arg_string(ssize_t index) const {
      size_t size = check(raw::dqcs_arb_get_size(handle, index));
      std::string data;
      data.resize(size);
      check(raw::dqcs_arb_get_raw(handle, index, &data.front(), size));
      return data;
    }

    /**
     * Returns the arbitrary argument at the given index as the given type.
     * Negative indices are relative to the back of the list, as in Python.
     *
     * WARNING: type `T` must be a primitive value (like an `int`) or a struct
     * thereof, without pointers or any other "complicated" constructs. DQCsim
     * just copies the bytes over. It is up to you to ensure that that's what
     * you want to happen; unfortunately C++11 does not provide a way to
     * statically ensure that this is the case.
     */
    template <typename T>
    T get_arb_arg_as(ssize_t index) const {
      size_t size = check(raw::dqcs_arb_get_size(handle, index));
      if (size != sizeof(T)) {
        throw std::runtime_error(
          "Arbitrary argument has incorrect size: "
          "found " + std::to_string(size) + " bytes, "
          "expected " + std::to_string(sizeof(T)) + " bytes");
      }
      T data;
      check(raw::dqcs_arb_get_raw(handle, index, &data, sizeof(data)));
      return data;
    }

    /**
     * Sets the arbitrary argument list to the given iterable of
     * `std::string`s.
     */
    template <typename T>
    void set_arb_arg_strings(const T &strings) {
      clear_arb_args();
      for (const std::string &string : strings) {
        push_arb_arg_string(string);
      }
    }

    /**
     * Sets the arbitrary argument at the given index to a (binary) string.
     * Negative indices are relative to the back of the list, as in Python.
     */
    void set_arb_arg_string(ssize_t index, const std::string &data) {
      check(raw::dqcs_arb_set_raw(handle, index, data.data(), data.size()));
    }

    /**
     * Sets the arbitrary argument at the given index to a value of type `T`.
     * Negative indices are relative to the back of the list, as in Python.
     *
     * WARNING: type `T` must be a primitive value (like an `int`) or a struct
     * thereof, without pointers or any other "complicated" constructs. DQCsim
     * just copies the bytes over. It is up to you to ensure that that's what
     * you want to happen; unfortunately C++11 does not provide a way to
     * statically ensure that this is the case.
     */
    template <typename T>
    void set_arb_arg(ssize_t index, const T &data) {
      check(raw::dqcs_arb_set_raw(handle, index, &data, sizeof(data)));
    }

    /**
     * Pushes a (binary) string to the back of the arbitrary argument list.
     */
    void push_arb_arg_string(const std::string &data) {
      check(raw::dqcs_arb_push_raw(handle, data.data(), data.size()));
    }

    /**
     * Pushes a value of type `T` to the back of the arbitrary argument list.
     *
     * WARNING: type `T` must be a primitive value (like an `int`) or a struct
     * thereof, without pointers or any other "complicated" constructs. DQCsim
     * just copies the bytes over. It is up to you to ensure that that's what
     * you want to happen; unfortunately C++11 does not provide a way to
     * statically ensure that this is the case.
     */
    template <typename T>
    void push_arb_arg(const T &data) {
      check(raw::dqcs_arb_push_raw(handle, &data, sizeof(data)));
    }

    /**
     * Pops from the back of the arbitrary argument list as a (binary) string.
     */
    std::string pop_arb_arg_string() {
      size_t size = check(raw::dqcs_arb_get_size(handle, -1));
      std::string data;
      data.resize(size);
      check(raw::dqcs_arb_pop_raw(handle, &data.front(), size));
      return data;
    }

    /**
     * Pops from the back of the arbitrary argument list as a value of type
     * `T`.
     *
     * WARNING: type `T` must be a primitive value (like an `int`) or a struct
     * thereof, without pointers or any other "complicated" constructs. DQCsim
     * just copies the bytes over. It is up to you to ensure that that's what
     * you want to happen; unfortunately C++11 does not provide a way to
     * statically ensure that this is the case.
     */
    template <typename T>
    T pop_arb_arg_as() const {
      size_t size = check(raw::dqcs_arb_get_size(handle, -1));
      if (size != sizeof(T)) {
        throw std::runtime_error(
          "Arbitrary argument has incorrect size: "
          "found " + std::to_string(size) + " bytes, "
          "expected " + std::to_string(sizeof(T)) + " bytes");
      }
      T data;
      check(raw::dqcs_arb_pop_raw(handle, &data, sizeof(data)));
      return data;
    }

    /**
     * Inserts an arbitrary argument at the given index using a (binary)
     * string. Negative indices are relative to the back of the list, as in
     * Python.
     */
    void insert_arb_arg_string(ssize_t index, const std::string &data) {
      check(raw::dqcs_arb_insert_raw(handle, index, data.data(), data.size()));
    }

    /**
     * Inserts an arbitrary argument at the given index using a value of type
     * `T`. Negative indices are relative to the back of the list, as in
     * Python.
     *
     * WARNING: type `T` must be a primitive value (like an `int`) or a struct
     * thereof, without pointers or any other "complicated" constructs. DQCsim
     * just copies the bytes over. It is up to you to ensure that that's what
     * you want to happen; unfortunately C++11 does not provide a way to
     * statically ensure that this is the case.
     */
    template <typename T>
    void insert_arb_arg(ssize_t index, const T &data) {
      check(raw::dqcs_arb_insert_raw(handle, index, &data, sizeof(data)));
    }

    /**
     * Removes the arbitrary argument at the given index. Negative indices are
     * relative to the back of the list, as in Python.
     */
    void remove_arb_arg(ssize_t index) {
      check(raw::dqcs_arb_remove(handle, index));
    }

    /**
     * Returns the number of arbitrary arguments.
     */
    size_t get_arb_arg_count() const {
      return check(raw::dqcs_arb_len(handle));
    }

    /**
     * Clears the arbitrary argument list.
     */
    void clear_arb_args() {
      check(raw::dqcs_arb_clear(handle));
    }

    /**
     * Assigns all arb data from the given arb to this one.
     */
    void set_arb(const Arb &src) {
      check(raw::dqcs_arb_assign(handle, src.get_handle()));
    }

  };

  /**
   * Class wrapper for `ArbData` handles.
   */
  class ArbData : public Arb {
  public:

    /**
     * Wrap the given `ArbData` handle.
     */
    ArbData(raw::dqcs_handle_t handle) : Arb(handle) {
    }

    /**
     * Constructs an empty `ArbData` object.
     */
    ArbData() : Arb(check(raw::dqcs_arb_new())) {
    }

    /**
     * Copy-constructs an `ArbData` object from any object supporting the `Arb`
     * interface.
     */
    ArbData(const Arb &src) : Arb(check(raw::dqcs_arb_new())) {
      set_arb(src);
    }

    /**
     * Copy-constructs an `ArbData` object from another `ArbData` object.
     */
    ArbData(const ArbData &src) : Arb(check(raw::dqcs_arb_new())) {
      set_arb(src);
    }

    /**
     * Copy assignment operator for `ArbData` objects.
     */
    void operator=(const ArbData &src) {
      set_arb(src);
    }

  };

  /**
   * Class wrapper for handles that support the `cmd` interface.
   */
  class Cmd : public Arb {
  public:

    /**
     * Wrap the given `cmd` handle.
     */
    Cmd(raw::dqcs_handle_t handle) : Arb(handle) {
    }

    /**
     * Returns the interface identifier of this command.
     */
    std::string get_iface() const {
      char *iface_c = check(raw::dqcs_cmd_iface_get(handle));
      std::string iface(iface_c);
      std::free(iface_c);
      return iface;
    }

    /**
     * Returns whether this command has the given interface identifier.
     */
    bool is_iface(const std::string &iface) const {
      return check(raw::dqcs_cmd_iface_cmp(handle, iface.c_str()));
    }

    /**
     * Returns the operation identifier of this command.
     */
    std::string get_oper() const {
      char *oper_c = check(raw::dqcs_cmd_oper_get(handle));
      std::string oper(oper_c);
      std::free(oper_c);
      return oper;
    }

    /**
     * Returns whether this command has the given operation identifier.
     */
    bool is_oper(const std::string &oper) const {
      return check(raw::dqcs_cmd_oper_cmp(handle, oper.c_str()));
    }

  };

  /**
   * Class wrapper for `ArbCmd` handles.
   */
  class ArbCmd : public Cmd {
  public:

    /**
     * Wrap the given `ArbCmd` handle.
     */
    ArbCmd(raw::dqcs_handle_t handle) : Cmd(handle) {
    }

    /**
     * Constructs an `ArbCmd` object.
     */
    ArbCmd(const std::string &iface, const std::string &oper) : Cmd(check(raw::dqcs_cmd_new(
      iface.c_str(), oper.c_str()
    ))) {
    }

    /**
     * Copy-constructs an `ArbCmd` object from any object supporting the `Cmd`
     * interface.
     */
    ArbCmd(const Cmd &src) : Cmd(check(raw::dqcs_cmd_new(
      src.get_iface().c_str(), src.get_oper().c_str()
    ))) {
      set_arb(src);
    }

    /**
     * Copy-constructs an `ArbCmd` object from another `ArbCmd` object.
     */
    ArbCmd(const ArbCmd &src) : Cmd(check(raw::dqcs_cmd_new(
      src.get_iface().c_str(), src.get_oper().c_str()
    ))) {
      set_arb(src);
    }

    /**
     * Copy assignment operator for `ArbCmd` objects.
     */
    void operator=(const ArbCmd &src) {
      // The C API doesn't allow `ArbCmd`s to be copied natively, so we need to
      // make a new one and drop the old handle. We make the copy before
      // exchanging the handles to avoid changing our state if the copy
      // operation throws an error for some reason.
      ArbCmd copy(src);
      free();
      handle = copy.take_handle();
    }

  };

  /**
   * Class wrapper for `ArbCmd` queue handles.
   *
   * To construct an `ArbCmd` queue iteratively, create a new queue using the
   * default constructor and push `ArbCmd`s into it using `push()`. Note that
   * there is an rvalue reference `push()` operation that entirely avoids
   * copying the `ArbCmd`. You can also construct the queue from an iterable of
   * `ArbCmd`s directly; again, including a zero-copy function using an rvalue
   * reference.
   *
   * To iterate over an existing `ArbCmd` queue (destructively!) in the most
   * efficient way, use the following code:
   *
   * ```
   * for (; queue.size() > 0; queue.next()) {
   *   // queue can be used as the current cmd/arb without any copies now
   * }
   * ```
   *
   * You can also drain it into a `std::vector` of `ArbCmd`s, or (if you must)
   * copy it into one.
   */
  class ArbCmdQueue : public Cmd {
  public:

    /**
     * Wrap the given `ArbCmd` handle.
     */
    ArbCmdQueue(raw::dqcs_handle_t handle) : Cmd(handle) {
    }

    /**
     * Constructs an empty `ArbCmd` queue object.
     */
    ArbCmdQueue() : Cmd(check(raw::dqcs_cq_new())) {
    }

    /**
     * Constructs an `ArbCmd` queue object from an iterable of `ArbCmd`s by
     * copying.
     */
    template <class T>
    ArbCmdQueue(const T &cmds) : Cmd(check(raw::dqcs_cq_new())) {
      for (const Cmd &cmd : cmds) {
        push(cmd);
      }
    }

    /**
     * Constructs an `ArbCmd` queue object from an iterable of `ArbCmd`s by
     * moving.
     */
    template <class T>
    ArbCmdQueue(T &&cmds) : Cmd(check(raw::dqcs_cq_new())) {
      for (const Cmd &cmd : cmds) {
        push(std::move(cmd));
      }
    }

    /**
     * Pushes an `ArbCmd` into the queue by copying.
     */
    void push(const Cmd &cmd) {
      ArbCmd copy(cmd);
      check(raw::dqcs_cq_push(handle, copy.take_handle()));
    }

    /**
     * Pushes an `ArbCmd` into the queue by moving.
     */
    void push(ArbCmd &&cmd) {
      check(raw::dqcs_cq_push(handle, cmd.take_handle()));
    }

    /**
     * Pops the first `ArbCmd` from the queue, allowing the next one to be
     * accessed.
     */
    void next() {
      check(raw::dqcs_cq_next(handle));
    }

    /**
     * Returns the number of `ArbCmd`s in the queue.
     */
    size_t size() const {
      return check(raw::dqcs_cq_len(handle));
    }

    /**
     * Drains the queue into a vector of `ArbCmd`s. This is less performant
     * than iterating over the queue manually, because it requires copies.
     */
    std::vector<ArbCmd> drain_into_vector() {
      std::vector<ArbCmd> cmds;
      for (; size() > 0; next()) {
        cmds.emplace_back(*this);
      }
      return cmds;
    }

    /**
     * Copies the queue into a vector of `ArbCmd`s. This is less performant
     * than iterating over the queue manually or using `drain_into_vector()`,
     * because it requires (additional) copies.
     *
     * NOTE: this function is not `const`, because exceptions during the copy
     * operation can change its value, and the underlying handle is changed.
     * However, under normal conditions, the contents appear to be unchanged.
     */
    std::vector<ArbCmd> copy_into_vector() {
      std::vector<ArbCmd> cmds = drain_into_vector();
      free();
      ArbCmdQueue copy(cmds);
      handle = copy.take_handle();
      return cmds;
    }

  };

  /**
   * Wrapper around the qubit reference typedef in the raw C bindings. This
   * prevents mutation and mathematical operations that don't make sense.
   */
  class QubitRef {
  private:

    /**
     * The raw qubit index wrapped by this reference.
     */
    raw::dqcs_qubit_t index;

  public:

    /**
     * Wraps a raw reference.
     */
    QubitRef(raw::dqcs_qubit_t index) : index(index) {
      if (index == 0) {
        throw std::runtime_error("Qubit indices cannot be zero in DQCsim");
      }
    }

    // The default assignment, copy, and move operators are fine and need not
    // be restricted.
    QubitRef(const QubitRef&) = default;
    QubitRef &operator=(const QubitRef&) = default;
    QubitRef(QubitRef &&handle) = default;
    QubitRef &operator=(QubitRef&&) = default;

    /**
     * Qubit reference equality operator.
     */
    bool operator==(const QubitRef &other) const {
      return index == other.index;
    }

    /**
     * Qubit reference inequality operator.
     */
    bool operator!=(const QubitRef &other) const {
      return index != other.index;
    }

    /**
     * Allow qubit references to be printed.
     */
    friend std::ostream& operator<<(std::ostream &out, const QubitRef &qubit) {
      out << 'q' << qubit.index;
      return out;
    }

    /**
     * Returns the raw qubit index.
     */
    raw::dqcs_qubit_t get_index() const {
      return index;
    }

  };

  /**
   * Literal operator for qubits, so for instance `15_q` returns qubit 15.
   */
  inline QubitRef operator "" _q(unsigned long long int qubit) {
    return QubitRef(qubit);
  }

  /**
   * Wrapper around qubit set handles.
   */
  class QubitSet : public Handle {
  public:

    /**
     * Wrap the given qubit set handle.
     */
    QubitSet(raw::dqcs_handle_t handle) : Handle(handle) {
    }

    /**
     * Constructs an empty qubit set.
     */
    QubitSet() : Handle(check(raw::dqcs_qbset_new())) {
    }

    /**
     * Constructs a qubit set object from an iterable of qubit references.
     */
    template <class T>
    QubitSet(const T &qubits) : Handle(check(raw::dqcs_qbset_new())) {
      for (const QubitRef &qubit : qubits) {
        push(qubit);
      }
    }

    /**
     * Copy-constructs a qubit set.
     */
    QubitSet(const QubitSet &src) : Handle(check(raw::dqcs_qbset_copy(src.handle))) {
    }

    /**
     * Copy assignment operator for qubit sets.
     */
    void operator=(const QubitSet &src) {
      QubitSet copy(src);
      free();
      handle = copy.take_handle();
    }

    /**
     * Pushes a qubit into the set. Note that qubit sets are ordered. An
     * exception is thrown if the qubit is already in the set.
     */
    void push(const QubitRef &qubit) {
      check(raw::dqcs_qbset_push(handle, qubit.get_index()));
    }

    /**
     * Pops a qubit from the set. Qubits are popped in the same order in which
     * they are pushed (like a FIFO).
     */
    QubitRef pop() {
      return QubitRef(check(raw::dqcs_qbset_pop(handle)));
    }

    /**
     * Returns the number of qubits in the set.
     */
    size_t size() const {
      return check(raw::dqcs_qbset_len(handle));
    }

    /**
     * Returns whether the given qubit is contained in the set.
     */
    bool contains(const QubitRef &qubit) const {
      return check(raw::dqcs_qbset_contains(handle, qubit.get_index()));
    }

    /**
     * Drains the qubit set into a vector.
     */
    std::vector<QubitRef> drain_into_vector() {
      std::vector<QubitRef> qubits;
      while (size()) {
        qubits.emplace_back(pop());
      }
      return qubits;
    }

    /**
     * Copies the qubit set into a vector.
     */
    std::vector<QubitRef> copy_into_vector() const {
      QubitSet copy(*this);
      return copy.drain_into_vector();
    }

  };

  /**
   * Convenience class for the square complex matrices used to express the
   * qubit gates.
   */
  class Matrix {
  private:

    /**
     * Row-major data storage.
     */
    std::vector<std::complex<double>> d;

    /**
     * Number of rows == number of columns. So we don't have to compute the
     * sqrt of the vector size all the time.
     */
    const size_t n;

  public:

    /**
     * Delete the default constructor, as it's nonsensical with no size
     * parameter.
     */
    Matrix() = delete;

    /**
     * Constructs an identity matrix of the given size.
     */
    Matrix(size_t size) : d(size * size, std::complex<double>(0.0, 0.0)), n(size) {
      for (size_t i = 0; i < n; i++) {
        (*this)(i, i) = std::complex<double>(1.0, 0.0);
      }
    }

    /**
     * Constructs a matrix from a row-major flattened array of `size` x `size`
     * `std::complex<double>`s.
     */
    Matrix(size_t size, const std::complex<double> *data) : d(size*size), n(size) {
      std::memcpy(d.data(), data, d.size() * sizeof(std::complex<double>));
    }

    /**
     * Constructs a matrix from a row-major, real-first flattened array of
     * 2 x `size` x `size` `double`s.
     */
    Matrix(size_t size, const double *data) : d(size*size), n(size) {
      std::memcpy(d.data(), data, d.size() * sizeof(std::complex<double>));
    }

    /**
     * Mutable matrix element accessor.
     */
    std::complex<double>& operator()(size_t row, size_t column) {
      if (row >= n || column >= n) {
        throw std::invalid_argument("matrix subscript out of bounds");
      }
      return d[n*row + column];
    }

    /**
     * Const matrix element accessor.
     */
    const std::complex<double>& operator()(size_t row, size_t column) const {
      if (row >= n || column >= n) {
        throw std::invalid_argument("matrix subscript out of bounds");
      }
      return d[n*row + column];
    }

    /**
     * Mutable matrix flattened data accessor.
     */
    std::complex<double> *data() {
      return d.data();
    }

    /**
     * Const matrix flattened data accessor.
     */
    const std::complex<double> *data() const {
      return d.data();
    }

    /**
     * Returns the size of the matrix (number of rows = number of columns).
     */
    size_t size() const {
      return n;
    }

    /**
     * Allow matrices to be printed.
     */
    friend std::ostream& operator<<(std::ostream &out, const Matrix &matrix) {
      out << '{';
      for (size_t row = 0; row < matrix.size(); row++) {
        if (row) out << ", ";
        out << '[';
        for (size_t col = 0; col < matrix.size(); col++) {
          if (col) out << ", ";
          auto e = matrix(row, col);
          if (e.real() != 0.0) {
            out << e.real();
            if (e.imag() < 0.0) {
              out << '-' << -e.imag() << 'i';
            } else if (e.imag() > 0.0) {
              out << '+' << e.imag() << 'i';
            }
          } else if (e.imag()) {
            out << e.imag() << 'i';
          } else {
            out << '0';
          }
        }
        out << ']';
      }
      out << '}';
      return out;
    }

    /**
     * Matrix equality operator.
     */
    bool operator==(const Matrix &other) const {
      return d == other.d;
    }

    /**
     * Matrix inequality operator.
     */
    bool operator!=(const Matrix &other) const {
      return d != other.d;
    }

  };

  /**
   * Class wrapper for `Gate` handles.
   */
  class Gate : public Arb {
  private:

    /**
     * Integer square root.
     */
    template <typename T>
    static T isqrt(T n) {
      T c = (T)1 << (sizeof(T) * 4 - 1);
      if (c < 0) {
        c = (T)1 << (sizeof(T) * 4 - 2);
      }
      T g = c;
      while (true) {
        if (g*g > n) {
          g ^= c;
        }
        c >>= 1;
        if (c == 0) {
          return g;
        }
        g |= c;
      }
    }

  public:

    /**
     * Wrap the given `Gate` handle.
     */
    Gate(raw::dqcs_handle_t handle) : Arb(handle) {
    }

    /**
     * Constructs a new unitary gate with no control qubits.
     */
    static Gate new_unitary(QubitSet &&targets, const Matrix &matrix) {
      return Gate(check(raw::dqcs_gate_new_unitary(
        targets.take_handle(),
        0,
        reinterpret_cast<const double*>(matrix.data()),
        matrix.size() * matrix.size()
      )));
    }

    /**
     * Constructs a new unitary gate with no control qubits.
     */
    static Gate new_unitary(const QubitSet &targets, const Matrix &matrix) {
      QubitSet targets_copy(targets);
      return new_unitary(std::move(targets_copy), matrix);
    }

    /**
     * Constructs a new unitary gate with control qubits.
     */
    static Gate new_unitary(QubitSet &&targets, QubitSet &&controls, const Matrix &matrix) {
      return Gate(check(raw::dqcs_gate_new_unitary(
        targets.take_handle(),
        controls.take_handle(),
        reinterpret_cast<const double*>(matrix.data()),
        matrix.size() * matrix.size()
      )));
    }

    /**
     * Constructs a new unitary gate with control qubits.
     */
    static Gate new_unitary(const QubitSet &targets, const QubitSet &controls, const Matrix &matrix) {
      QubitSet targets_copy(targets);
      QubitSet controls_copy(controls);
      return new_unitary(std::move(targets_copy), std::move(controls_copy), matrix);
    }

    /**
     * Constructs a new Z-axis measurement gate.
     */
    static Gate new_measure(QubitSet &&measures) {
      return Gate(check(raw::dqcs_gate_new_measurement(measures.take_handle())));
    }

    /**
     * Constructs a new Z-axis measurement gate.
     */
    static Gate new_measure(const QubitSet &measures) {
      QubitSet measures_copy(measures);
      return new_measure(std::move(measures_copy));
    }

    /**
     * Constructs a new custom gate with a matrix.
     */
    static Gate new_custom(
      const std::string &name,
      QubitSet &&targets,
      QubitSet &&controls,
      QubitSet &&measures,
      const Matrix &matrix
    ) {
      return Gate(check(raw::dqcs_gate_new_custom(
        name.c_str(),
        targets.take_handle(),
        controls.take_handle(),
        measures.take_handle(),
        reinterpret_cast<const double*>(matrix.data()),
        matrix.size() * matrix.size()
      )));
    }

    /**
     * Constructs a new custom gate with a matrix.
     */
    static Gate new_custom(
      const std::string &name,
      const QubitSet &targets,
      const QubitSet &controls,
      const QubitSet &measures,
      const Matrix &matrix
    ) {
      QubitSet targets_copy(targets);
      QubitSet controls_copy(controls);
      QubitSet measures_copy(measures);
      return new_custom(name, std::move(targets_copy), std::move(controls_copy), std::move(measures_copy), matrix);
    }

    /**
     * Constructs a new custom gate without a matrix.
     */
    static Gate new_custom(
      const std::string &name,
      QubitSet &&targets,
      QubitSet &&controls,
      QubitSet &&measures
    ) {
      return Gate(check(raw::dqcs_gate_new_custom(
        name.c_str(),
        targets.take_handle(),
        controls.take_handle(),
        measures.take_handle(),
        nullptr,
        0
      )));
    }

    /**
     * Constructs a new custom gate without a matrix.
     */
    static Gate new_custom(
      const std::string &name,
      const QubitSet &targets,
      const QubitSet &controls,
      const QubitSet &measures
    ) {
      QubitSet targets_copy(targets);
      QubitSet controls_copy(controls);
      QubitSet measures_copy(measures);
      return new_custom(name, std::move(targets_copy), std::move(controls_copy), std::move(measures_copy));
    }

    /**
     * Returns a new qubit reference set with the target qubits for this gate.
     */
    QubitSet get_targets() const {
      return QubitSet(check(raw::dqcs_gate_targets(handle)));
    }

    /**
     * Returns whether this gate has target qubits.
     */
    bool has_targets() const {
      return check(raw::dqcs_gate_has_targets(handle));
    }

    /**
     * Returns a new qubit reference set with the control qubits for this gate.
     */
    QubitSet get_controls() const {
      return QubitSet(check(raw::dqcs_gate_controls(handle)));
    }

    /**
     * Returns whether this gate has control qubits.
     */
    bool has_controls() const {
      return check(raw::dqcs_gate_has_controls(handle));
    }

    /**
     * Returns a new qubit reference set with the measurement qubits for this
     * gate.
     */
    QubitSet get_measures() const {
      return QubitSet(check(raw::dqcs_gate_measures(handle)));
    }

    /**
     * Returns whether this gate has measurement qubits.
     */
    bool has_measures() const {
      return check(raw::dqcs_gate_has_measures(handle));
    }

    /**
     * Returns the matrix that belongs to this gate.
     */
    Matrix get_matrix() const {
      double *data = check(raw::dqcs_gate_matrix(handle));
      Matrix matrix(isqrt(check(raw::dqcs_gate_matrix_len(handle))), data);
      std::free(data);
      return matrix;
    }

    /**
     * Returns whether this gate has a matrix.
     */
    bool has_matrix() const {
      return check(raw::dqcs_gate_has_matrix(handle));
    }

    /**
     * Returns the name of a custom gate.
     */
    std::string get_name() const {
      char *data = check(raw::dqcs_gate_name(handle));
      std::string name(data);
      std::free(data);
      return name;
    }

    /**
     * Returns whether this gate is a custom gate.
     */
    bool is_custom() const {
      return check(raw::dqcs_gate_is_custom(handle));
    }

  };

  /**
   * Class wrapper for measurement handles.
   */
  class Measurement : public Arb {
  public:

    /**
     * Wrap the given measurement handle.
     */
    Measurement(raw::dqcs_handle_t handle) : Arb(handle) {
    }

    /**
     * Constructs a measurement object.
     */
    Measurement(const QubitRef &qubit, MeasurementValue value) : Arb(check(
      raw::dqcs_meas_new(qubit.get_index(), measurement_value_to_raw(value))
    )) {
    }

    /**
     * Copy-constructs a `Measurement` object.
     */
    Measurement(const Measurement &src) : Arb(check(
      raw::dqcs_meas_new(src.get_qubit().get_index(), measurement_value_to_raw(src.get_value()))
    )) {
      set_arb(src);
    }

    /**
     * Copy assignment operator for `Measurement` objects.
     */
    void operator=(const Measurement &src) {
      set_qubit(src.get_qubit());
      set_value(src.get_value());
      set_arb(src);
    }

    /**
     * Returns the measurement value.
     */
    MeasurementValue get_value() const {
      return check(raw::dqcs_meas_value_get(handle));
    }

    /**
     * Sets the measurement value.
     */
    void set_value(MeasurementValue value) {
      check(raw::dqcs_meas_value_set(handle, measurement_value_to_raw(value)));
    }

    /**
     * Returns the qubit reference associated with this measurement.
     */
    QubitRef get_qubit() const {
      return QubitRef(check(raw::dqcs_meas_qubit_get(handle)));
    }

    /**
     * Sets the qubit reference associated with this measurement.
     */
    void set_qubit(QubitRef qubit) {
      check(raw::dqcs_meas_qubit_set(handle, qubit.get_index()));
    }

  };

  /**
   * Wrapper around measurement set handles.
   */
  class MeasurementSet : public Handle {
  public:

    /**
     * Wrap the given measurement set handle.
     */
    MeasurementSet(raw::dqcs_handle_t handle) : Handle(handle) {
    }

    /**
     * Constructs an empty measurement set.
     */
    MeasurementSet() : Handle(check(raw::dqcs_mset_new())) {
    }

    /**
     * Constructs a measurement set object from an iterable of measurements.
     */
    template <class T>
    MeasurementSet(const T &measurements) : Handle(check(raw::dqcs_mset_new())) {
      for (const Measurement &measurement : measurements) {
        set(measurement);
      }
    }

    /**
     * Copies the given measurement object into the set. If the set already
     * contained measurement data for the qubit associated with the measurement
     * object, the previous measurement data is overwritten.
     */
    void set(const Measurement &measurement) {
      Measurement copy = measurement;
      check(raw::dqcs_mset_set(handle, copy.take_handle()));
    }

    /**
     * Moves the given measurement object into the set. If the set already
     * contained measurement data for the qubit associated with the measurement
     * object, the previous measurement data is overwritten.
     */
    void set(Measurement &&measurement) {
      check(raw::dqcs_mset_set(handle, measurement.take_handle()));
    }

    /**
     * Returns a copy of the measurement object for the given qubit. An
     * exception is thrown if no data is available for this qubit.
     */
    Measurement get(const QubitRef &qubit) const {
      return Measurement(check(raw::dqcs_mset_get(handle, qubit.get_index())));
    }

    /**
     * Moves the measurement object for the given qubit out of the set. An
     * exception is thrown if no data is available for this qubit.
     */
    Measurement take(const QubitRef &qubit) {
      return Measurement(check(raw::dqcs_mset_take(handle, qubit.get_index())));
    }

    /**
     * Moves any measurement object out of the set. An exception is thrown if
     * the set is empty.
     */
    Measurement take_any() {
      return Measurement(check(raw::dqcs_mset_take_any(handle)));
    }

    /**
     * Removes the measurement object for the given qubit from the set.
     */
    void remove(const QubitRef &qubit) {
      check(raw::dqcs_mset_remove(handle, qubit.get_index()));
    }

    /**
     * Returns the number of measurements in the set.
     */
    size_t size() const {
      return check(raw::dqcs_mset_len(handle));
    }

    /**
     * Returns whether the set contains measurement data for the given qubit.
     */
    bool contains(const QubitRef &qubit) const {
      return check(raw::dqcs_mset_contains(handle, qubit.get_index()));
    }

    /**
     * Drains the measurement set into a vector.
     */
    std::vector<Measurement> drain_into_vector() {
      std::vector<Measurement> measurements;
      while (size()) {
        measurements.emplace_back(take_any());
      }
      return measurements;
    }

    /**
     * Copies the qubit set into a vector. This requires destructive iteration,
     * so the function is not const; if an exception occurs, the state of the
     * measurement set may be changed.
     */
    std::vector<Measurement> copy_into_vector() {
      std::vector<Measurement> vector = drain_into_vector();
      MeasurementSet copy(vector);
      free();
      handle = copy.take_handle();
      return vector;
    }

    /**
     * Copy-constructs a measurement set object. This requires destructive
     * iteration of the source object, so it isn't not const; if an exception
     * occurs, the state of the source object may be changed.
     */
    MeasurementSet(MeasurementSet &src) : Handle(0) {
      MeasurementSet copy(src.copy_into_vector());
      handle = copy.take_handle();
    }

  };

} // namespace wrap

} // namespace dqcsim

#endif

