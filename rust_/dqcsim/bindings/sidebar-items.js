initSidebarItems({"enum":[["dqcs_basis_t","Enumeration of Pauli bases."],["dqcs_bool_return_t","Return type for functions that normally return a boolean but can also fail."],["dqcs_gate_type_t","Types of DQCsim gates."],["dqcs_handle_type_t","Enumeration of types that can be associated with a handle."],["dqcs_loglevel_t","Enumeration of loglevels and logging modes."],["dqcs_measurement_t","Qubit measurement value."],["dqcs_path_style_t","Reproduction file path style."],["dqcs_plugin_type_t","Enumeration of the three types of plugins."],["dqcs_predefined_gate_t","Enumeration of gates defined by DQCsim."],["dqcs_return_t","Default return type for functions that don't need to return anything."]],"fn":[["dqcs_arb_assign","Copies the data from one object to another."],["dqcs_arb_cbor_get","Returns the JSON/CBOR object of an `ArbData` object in the form of a CBOR object."],["dqcs_arb_cbor_set","Sets the JSON/CBOR object of an `ArbData` object by means of a CBOR object."],["dqcs_arb_clear","Clears the unstructured argument list."],["dqcs_arb_get_raw","Returns the unstructured string argument at the specified index."],["dqcs_arb_get_size","Returns the size in bytes of the unstructured string argument at the specified index."],["dqcs_arb_get_str","Returns the unstructured string argument at the specified index."],["dqcs_arb_insert_raw","Inserts an unstructured raw argument into the list at the specified index."],["dqcs_arb_insert_str","Inserts an unstructured string argument into the list at the specified index."],["dqcs_arb_json_get","Returns the JSON/CBOR object of an `ArbData` object in the form of a JSON string."],["dqcs_arb_json_set","Sets the JSON/CBOR object of an `ArbData` object by means of a JSON string."],["dqcs_arb_len","Returns the number of unstructured arguments, or -1 to indicate failure."],["dqcs_arb_new","Creates a new `ArbData` object."],["dqcs_arb_pop","Pops an unstructured argument from the back of the list without returning it."],["dqcs_arb_pop_raw","Pops an unstructured raw argument from the back of the list."],["dqcs_arb_pop_str","Pops an unstructured string argument from the back of the list."],["dqcs_arb_push_raw","Pushes an unstructured raw argument to the back of the list."],["dqcs_arb_push_str","Pushes an unstructured string argument to the back of the list."],["dqcs_arb_remove","Removes the specified unstructured string argument from the list."],["dqcs_arb_set_raw","Replaces the unstructured argument at the specified index with the specified raw object."],["dqcs_arb_set_str","Replaces the unstructured argument at the specified index with the specified string."],["dqcs_cmd_iface_cmp","Compares the interface ID of an `ArbCmd` with the given string."],["dqcs_cmd_iface_get","Returns the interface ID of an `ArbCmd`."],["dqcs_cmd_new","Creates a new `ArbCmd` object."],["dqcs_cmd_oper_cmp","Compares the operation ID of an `ArbCmd` with the given string."],["dqcs_cmd_oper_get","Returns the operation ID of an `ArbCmd`."],["dqcs_cq_len","Returns the number of `ArbCmd` objects in the given `ArbCmd` queue."],["dqcs_cq_new","Creates a new `ArbCmd` queue object."],["dqcs_cq_next","Advances an `ArbCmd` queue to the next command."],["dqcs_cq_push","Pushes an `ArbCmd` object into the given `ArbCmd` queue."],["dqcs_error_get","Returns a pointer to the latest error message."],["dqcs_error_set","Sets the latest error message string."],["dqcs_gate_controls","Returns a handle to a new qubit reference set containing the qubits that control this gate."],["dqcs_gate_expand_control","Utility function that expands a gate matrix to account for all control  qubits. > > This function borrows a handle to any gate with a matrix, and returns an > equivalent copy of said gate with any control qubits in the `controls` set > moved to the `targets` set. The associated gate matrix is extended > accordingly. The control qubits are added at the front of the `targets` > set in the same order they appeared in the `controls` qubit set. > > This function returns a new gate handle with the modified gate, or a copy > of the input gate if the matrix could not be reduced. If the input gate > does not have a matrix (measurement gate, or custom gate without matrix) an > error is returned instead."],["dqcs_gate_has_controls","Returns whether the specified gate has control qubits."],["dqcs_gate_has_matrix","Returns whether a unitary matrix is associated with this gate."],["dqcs_gate_has_measures","Returns whether the specified gate measures any qubits."],["dqcs_gate_has_name","Returns whether the specified gate has a name."],["dqcs_gate_has_targets","Returns whether the specified gate has target qubits."],["dqcs_gate_matrix","Returns a copy of the unitary matrix associated with this gate, if one exists."],["dqcs_gate_measures","Returns a handle to a new qubit reference set containing the qubits measured by this gate."],["dqcs_gate_name","Returns the name of a custom gate."],["dqcs_gate_new_custom","Constructs a new custom gate."],["dqcs_gate_new_measurement","Constructs a new measurement gate."],["dqcs_gate_new_predef","Constructs a new predefined unitary gate."],["dqcs_gate_new_predef_one","Constructs a new predefined unitary one-qubit gate."],["dqcs_gate_new_predef_three","Constructs a new predefined unitary three-qubit gate."],["dqcs_gate_new_predef_two","Constructs a new predefined unitary two-qubit gate."],["dqcs_gate_new_prep","Constructs a new prep gate."],["dqcs_gate_new_unitary","Constructs a new unitary gate."],["dqcs_gate_reduce_control","Utility function that detects control qubits in the `targets` list of the  gate by means of the gate matrix, and reduces them into `controls` qubits. > > This function borrows a handle to any gate with a matrix, and returns an > equivalent copy of said gate with any control qubits in the `targets` set > moved to the `controls` set. The associated gate matrix is accordingly > reduced in size. The control qubits are added at the end of the `controls` > set in the same order they appeared in the `targets` qubit set. > > `epsilon` specifies the maximum element-wise deviation from the identity > matrix for the relevant array elements for a qubit to be considered a > control qubit. Note that if this is greater than zero, the resulting gate > may not be exactly equivalent. If `ignore_gphase` is set, any global phase > in the matrix is ignored, but the global phase of the non-control submatrix > is not changed. > > This function returns a new gate handle with the modified gate, or a copy > of the input gate if the matrix could not be reduced. If the input gate > does not have a matrix (measurement gate, or custom gate without matrix) an > error is returned instead."],["dqcs_gate_targets","Returns a handle to a new qubit reference set containing the qubits targeted by this gate."],["dqcs_gate_type","Returns the gate type of the given gate."],["dqcs_gm_add_custom","Adds a fully customizable gate mapping to the given gate map. > > Note that this is the only type of mapping that can handle custom/named > gates. > > `detector` is the detector function pointer. It is optional; if null, this > mapping only supports construction. > `detector_user_free` is an optional callback function used to free > `detector_user_data` when the gate map is destroyed, when this function > fails, or when `detector` was null. > `detector_user_data` is a user-specified value that is passed to the > `detector` callback function. It is not used by DQCsim. > `constructor` is the constructor function pointer. It is optional; if > null, this mapping only supports detection. > `constructor_user_free` is an optional callback function used to free > `constructor_user_data` when the gate map is destroyed, when this function > fails, or when `constructor` was null. > `constructor_user_data` is a user-specified value that is passed to the > `constructor` callback function. It is not used by DQCsim. > > If both `constructor` and `detector` are null for some reason, the > function is no-op (besides possibly calling the `*_free()` callbacks. > > The detector callback receives the complete gate passed to the gate map > for it to match as it pleases. If the gate matches, the detector function > must return `DQCS_TRUE`. It may  assign `qubits` to a `qbset` object > representing the qubit arguments (substituted with an empty set if it > doesn't), and may assign `param_data` to an `arb` handle with the > parameterization data (if it doesn't, the data from the gate is used; if > this was modified by the callback, the modified data is used). If the gate > doesn't match, it must return `DQCS_FALSE`. If an error occurs, it must > call `dqcs_error_set()` with the error message and return > `DQCS_BOOL_FAILURE`. > > The constructor callback performs the reverse operation. It receives an > `ArbData` handle containing the parameterization data and a qubit set, and > must construct a gate based on this information. If construction succeeds, > the constructor function must return the gate handle. If an error occurs, > it must call `dqcs_error_set()` with the error message and return 0. > > It is up to the user how to do the matching and constructing, but the > converter functions must always return the same value for the same input. > In other words, they must be pure functions. Otherwise, the caching > behavior of the `GateMap` will make the results inconsistent."],["dqcs_gm_add_custom_unitary","Adds a custom unitary gate mapping to the given gate map. > > `gm` must be a handle to a gate map object (`dqcs_gm_new()`). > `key_free` is an optional callback function used to free `key_data` when > the gate map is destroyed, or when this function fails. > `key_data` is the user-specified value used to identify this mapping. > `detector` is the detector function pointer. It is optional; if null, this > mapping only supports construction. > `detector_user_free` is an optional callback function used to free > `detector_user_data` when the gate map is destroyed, when this function > fails, or when `detector` was null. > `detector_user_data` is a user-specified value that is passed to the > `detector` callback function. It is not used by DQCsim. > `constructor` is the constructor function pointer. It is optional; if > null, this mapping only supports detection. > `constructor_user_free` is an optional callback function used to free > `constructor_user_data` when the gate map is destroyed, when this function > fails, or when `constructor` was null. > `constructor_user_data` is a user-specified value that is passed to the > `constructor` callback function. It is not used by DQCsim. > > If both `constructor` and `detector` are null for some reason, the > function is no-op (besides possibly calling the `*_free()` callbacks. > > The detector callback receives a matrix and control qubit information for > the user to match. The matrix is passed through the `matrix` handle. > `num_controls` is passed the number of explicit control qubits that exist > besides the matrix (that is, if nonzero, the matrix is actually only the > non-controlled submatrix of the controlled gate). `param_data` is given an > `ArbData` handle initialized with the `ArbData` attached to the gate. If > the gate matches, the detector function must return `DQCS_TRUE`. In this > case, it can mutate the `param_data` to add the detected gate parameters. > If it doesn't match, it must return `DQCS_FALSE`. If an error occurs, it > must call `dqcs_error_set()` with the error message and return > `DQCS_BOOL_FAILURE`. > > The constructor callback performs the reverse operation. It receives an > `ArbData` handle containing the parameterization data, and must construct > the matrix, return the bound on the number of control qubits, and must > return the `ArbData` associated with the gate by mutating the `param_data` > handle. `num_controls` will point to a variable initialized to -1 > representing a constraint on the number of control qubits. This works as > follows: if negative, any number of qubits is allowed; if zero or > positive, only that number is allowed. If construction succeeds, the > constructor function must return a handle to the constructed matrix. If > it fails, it must call `dqcs_error_set()` with an error message and return > 0. > > It is up to the user how to do the matching and constructing, but the > converter functions must always return the same value for the same input. > In other words, they must be pure functions. Otherwise, the caching > behavior of the `GateMap` will make the results inconsistent."],["dqcs_gm_add_fixed_unitary","Adds a unitary gate mapping for the given gate matrix to the given gate  map. > > `gm` must be a handle to a gate map object (`dqcs_gm_new()`). > `key_free` is an optional callback function used to free `key_data` when > the gate map is destroyed, or when this function fails. > `key_data` is the user-specified value used to identify this mapping. > `matrix` must be passed a handle to the matrix to detect. It is consumed > by this function. > `num_controls` specifies the number of control qubits associated with this > gate type. If negative, the gate can have any number of control qubits. > If zero or positive, the number of control qubits must be as specified. > `epsilon` specifies the maximum element-wise root-mean-square error > between the incoming matrix and the to be detected matrix that results in a > positive match. > `ignore_phase` specifies whether the aforementioned check should ignore > global phase or not when there are no explicit control qubits. > > The parameterization `ArbData` object returned by detection and consumed > by construction is mapped one-to-one to the user data of the gate in the > DQCsim-protocol."],["dqcs_gm_add_measure","Adds a measurement gate mapping to the given gate map. > > `gm` must be a handle to a gate map object (`dqcs_gm_new()`). > `key_free` is an optional callback function used to free `key_data` when > the gate map is destroyed, or when this function fails. > `key_data` is the user-specified value used to identify this mapping. > `num_measures` specifies the number of measured qubits for this gate type. > If negative, the gate can have any number of measured qubits. If zero or > positive, the number of measured qubits must be as specified. > `basis` optionally specifies a handle to a 2x2 matrix specifying the > measurement basis to be detected. If not specified, the Z basis is used. > The matrix is deleted by the call iff the function succeeds. > `epsilon` specifies the maximum RMS deviation between the specified basis > (if any) and the incoming basis. > > The parameterization `ArbData` object returned by detection and consumed > by construction is mapped one-to-one to the user data of the gate in the > DQCsim-protocol."],["dqcs_gm_add_predef_unitary","Adds a unitary gate mapping for the given DQCsim-defined gate to the  given gate map. > > `gm` must be a handle to a gate map object (`dqcs_gm_new()`). > `key_free` is an optional callback function used to free `key_data` when > the gate map is destroyed, or when this function fails. > `key_data` is the user-specified value used to identify this mapping. > `gate` defines which predefined gate to use. Some of the predefined gates > are parameterized. > `num_controls` specifies the number of control qubits associated with this > gate type. If negative, the gate can have any number of control qubits. > If zero or positive, the number of control qubits must be as specified. > `epsilon` specifies the maximum element-wise root-mean-square error > between the incoming matrix and the to be detected matrix that results in a > positive match. > `ignore_phase` specifies whether the aforementioned check should ignore > global phase or not when there are no explicit control qubits. > > For most gate types, the parameterization `ArbData` object returned by > detection and consumed by construction is mapped one-to-one to the user > data of the gate in the DQCsim-protocol. Some of the detectors however > detect parameterized gate matrices. These detectors prefix a fixed number > of binary string arguments to the `ArbData` upon detection, and pop these > when constructing. The specs for this can be found in the docs for > `dqcs_predefined_gate_t`."],["dqcs_gm_add_prep","Adds a prep gate mapping to the given gate map. > > `gm` must be a handle to a gate map object (`dqcs_gm_new()`). > `key_free` is an optional callback function used to free `key_data` when > the gate map is destroyed, or when this function fails. > `key_data` is the user-specified value used to identify this mapping. > `num_targets` specifies the number of target qubits for this gate type. > If negative, the gate can have any number of targets. If zero or > positive, the number of target qubits must be as specified. > `basis` optionally specifies a handle to a 2x2 matrix specifying the > prep basis. If not specified, the Z basis is used. The matrix is deleted > by the call iff the function succeeds. > `epsilon` specifies the maximum RMS deviation between the specified basis > (if any) and the incoming basis. > > The parameterization `ArbData` object returned by detection and consumed > by construction is mapped one-to-one to the user data of the gate in the > DQCsim-protocol."],["dqcs_gm_construct","Uses a gate map object to construct a multi-qubit DQCsim gate from the  plugin's representation. > > `gm` must be a handle to a gate map object (`dqcs_mm_new()`). > `gate` must be a handle to a gate. The handle is borrowed; it is not > mutated or deleted. > `key_data` specifies the gate mapping key for the constructor to use. Note > that the pointer must match exactly to what was specified when the > mapping(s) was/were added. > `qubits` specifies the qubits arguments for the constructed gate. It is > up to the constructor function to determine how to interpret these. The > parameter is optional; passing 0 is equivalent to passing an empty qubit > set. The handle is deleted if the function succeeds. > `param_data` specifies the `ArbData` object used to parameterize the gate. > It is optional; if 0, an empty `ArbData` is automatically constructed by > DQCsim. The handle is deleted if the function succeeds. >  This function returns the handle to the gate, or 0 to indicate failure.  The qubit set and parameterization data (if specified) are consumed/deleted  by this function if and only if it succeeds."],["dqcs_gm_construct_one","Uses a gate map object to construct a one-qubit DQCsim gate from the  plugin's representation. > > This function is simply a shorthand for `dqcs_gm_construct()` with > one qubit in the `qubits` set, to make constructing one-qubit gates more > ergonomic. Refer to its documentation for more information."],["dqcs_gm_construct_three","Uses a gate map object to construct a three-qubit DQCsim gate from the  plugin's representation. > > This function is simply a shorthand for `dqcs_gm_construct()` with > three qubits in the `qubits` set, to make constructing three-qubit gates > more ergonomic. Refer to its documentation for more information."],["dqcs_gm_construct_two","Uses a gate map object to construct a two-qubit DQCsim gate from the  plugin's representation. > > This function is simply a shorthand for `dqcs_gm_construct()` with > two qubits in the `qubits` set, to make constructing two-qubit gates more > ergonomic. Refer to its documentation for more information."],["dqcs_gm_detect","Uses a gate map object to convert an incoming DQCsim gate to the plugin's  representation. > > `gm` must be a handle to a gate map object (`dqcs_mm_new()`). > `gate` must be a handle to a gate. The handle is borrowed; it is not > mutated or deleted. > `key_data` serves as an optional return value; if non-NULL and a match is > found, the `key_data` specified when the respective detector was added is > returned here as a `const void *`. If no match is found, `*key_data` is > not assigned. > `qubits` serves as an optional return value; if non-NULL and a match > is found, it is set to a handle to a new `QubitSet` object representing the > gate's qubits. Ownership of this handle is passed to the user, so it > is up to the user to eventually delete it. If no match is found, > `*qubits` is set to 0. > `param_data` serves as an optional return value; if non-NULL and a match > is found, it is set to a handle to a new `ArbData` object representing the > gate's parameters. Ownership of this handle is passed to the user, so it > is up to the user to eventually delete it. If no match is found, > `*param_data` is set to 0. > > This function returns `DQCS_TRUE` if a match was found, `DQCS_FALSE` if no > match was found, or `DQCS_BOOL_FAILURE` if an error occurs."],["dqcs_gm_new","Constructs a new gate map. > > Returns a handle to a gate map with no mappings attached to it yet. Use > `dqcs_gm_add_*()` to do that. The mappings are queried in the order in > which they are added, so be sure to add more specific gates first. Once > added, use `dqcs_gm_detect()` to detect incoming DQCsim gates, and > `dqcs_gm_construct*()` to (re)construct gates for transmission. > > Gate maps objects retain a cache to speed up detection of similar DQCsim > gates: if a gate is received for the second time, the cache will hit, > avoiding recomputation of the detector functions. What constitutes > \"similar gates\" is defined by the two booleans passed to this function. If > `strip_qubit_refs` is set, all qubit references associated with the gate > will be invalidated (i.e., set to 0), such that for instance an X gate > applied to qubit 1 will be considered equal to an X gate applied to qubit > 2. If `strip_data` is set, the `ArbData` associated with the incoming > gate is removed. > > Gates are identified through user-defined `void*` keys. To do the above, > however, DQCsim needs to know the following things: > >  - how to delete an owned copy of a key if your semantics are that DQCsim >    owns it, >  - how to compare two keys (equality); >  - how to hash a key. > > The deletion function is passed when the key is passed. If the keys are > objects of different classes, this allows different constructors to be > passed here. There can only be a single comparison and hash function for > each gate map, though. They are passed here. > > `key_cmp` represents this comparison function. It takes two `void*` to > keys and must returns whether they are equal or not. If not specified, > the default is to compare the pointers themselves, instead of the values > they refer to. `key_cmp` must be a pure function, i.e., depend only on its > input values. > > `key_hash` represents the hashing function. It takes a `void*` key and > returns a 64-bit hash representative of the key. For any pair of keys > for which `key_cmp` returns true, the hashes must be equal. The default > behavior depends on whether `key_cmp` is defined: if it is, all keys will > have the same hash; if it isn't, the pointer is itself hashed. `key_hash` > must be a pure function, i.e., depend only on its input values. > > It is recommended to first preprocess incoming gates with > `dqcs_gate_reduce_control()`. In this case, controlled unitary gate > matrices will be reduced to their non-controlled submatrix, such that the > unitary gate detectors will operate on said submatrix. The predefined > unitary gate detectors are more-or-less based on this assumption (as there > are no predefined controlled matrices). > > Alternatively, you can preprocess with `dqcs_gate_expand_control()`. In > this case, you can use `dqcs_gm_add_fixed_unitary()` to detect the full > matrix in all cases, by specifying the CNOT matrix instead of an X matrix > with one control qubit. > > If you don't preprocess, the upstream plugin determines the > representation. That is, it may send a CNOT as a two-qubit gate with a > CNOT matrix or as a controlled X gate with a single target and single > control qubit. The gate map will then detect these as two different kinds > of gates."],["dqcs_handle_delete","Destroys the object associated with a handle."],["dqcs_handle_delete_all","Deletes all handles for the current thread."],["dqcs_handle_dump","Returns a debug dump of the object associated with the given handle."],["dqcs_handle_leak_check","Succeeds only if there are no live handles in the current thread."],["dqcs_handle_type","Returns the type of object associated with the given handle."],["dqcs_log_raw","Primitive API for sending a log message using the current logger."],["dqcs_mat_add_controls","Constructs a controlled matrix from the given matrix. > > `mat` specifies the matrix to use as the non-controlled submatrix. This > is a borrowed handle. `number_of_controls` specifies the number of control > qubits to add. This function returns a new matrix handle with the > constructed matrix, or 0 if it fails."],["dqcs_mat_approx_eq","Approximately compares two matrices. > > `a` and `b` are borrowed matrix handles. > `epsilon` specifies the maximum element-wise root-mean-square error > between the matrices that results in a positive match. `ignore_gphase` > specifies whether the check should ignore global phase. > > If ignore_gphase is set, this checks that the following holds for some x: > > \\f[ > A \\cdot e^{ix} \\approx B > \\f] > > This function returns `DQCS_TRUE` if the matrices match according to the > aforementioned criteria, or `DQCS_FALSE` if not. `DQCS_BOOL_ERROR` is used > when either handle is invalid or not a matrix. If the matrices differ in > dimensionality, `DQCS_FALSE` is used."],["dqcs_mat_approx_unitary","Returns whether the matrix is approximately unitary. > > `matrix` is a borrowed handle to the matrix to check. > `epsilon` specifies the maximum element-wise root-mean-square error > between the product of the matrix and its hermetian compared to the > identity matrix. > > This function returns `DQCS_TRUE` if the matrix is approximately unitary, > or `DQCS_FALSE` if not. `DQCS_BOOL_ERROR` is used when either handle is > invalid or not a matrix."],["dqcs_mat_basis","Constructs a matrix with the eigenvectors of one of the Pauli matrices  as column vectors. > > This can be used for constructing measurement or prep gates with the > given basis. Returns a new handle to the constructed matrix or returns > 0 if an error occurs."],["dqcs_mat_basis_approx_eq","Approximately compares two basis matrices. > > `a` and `b` are borrowed matrix handles. > `epsilon` specifies the maximum element-wise root-mean-square error > between the matrices that results in a positive match. > > This checks that the following holds for some x and y: > > \\f[ > A \\cdot \\begin{bmatrix} > e^{ix} & 0 \\ > 0 & e^{iy} > \\end{bmatrix} \\approx B > \\f] > > This function returns `DQCS_TRUE` if the matrices match according to the > aforementioned criteria, or `DQCS_FALSE` if not. `DQCS_BOOL_ERROR` is used > when either handle is invalid or not a matrix. If either matrix is not > 2x2, `DQCS_FALSE` is used."],["dqcs_mat_dimension","Returns the dimension (number of rows == number of columns) of the given  matrix. > > This function returns -1 when an error occurs."],["dqcs_mat_get","Returns a copy of the contained matrix as a C array. > > If this function succeeds, the matrix is returned in row-major form, using > pairs of doubles for the real vs. imaginary component of each entry. The > size will be `4**num_qubits` complex numbers = `2*4**num_qubits` doubles = > `16*4**num_qubits` bytes. A newly allocated matrix is returned; free it > with `free()` when you're done with it to avoid memory leaks. On failure, > this function returns `NULL`."],["dqcs_mat_is_predef","Returns whether this matrix is of the given predefined form and, if it is,  any parameters needed to describe it. > > `mat` is a borrowed handle to the matrix to check. > `gate_type` specifies which kind of gate should be detected. > `param_data`, if non-null, receives a new `ArbData` handle with > parameterization data, or an empty `ArbData` if the gate is not > parameterized; the caller must delete this object when it is done with > it. This function always writes the 0 handle to this return parameter if > it fails. The `ArbData` representation can be found in the documentation > for `dqcs_predefined_gate_t`. > > `epsilon` specifies the maximum element-wise root-mean-square error > between the matrices that results in a positive match. `ignore_gphase` > specifies whether the check should ignore global phase. > > This function returns `DQCS_TRUE` if the matrices match according to the > aforementioned criteria, or `DQCS_FALSE` if not. `DQCS_BOOL_ERROR` is used > when either handle is invalid or not a matrix. If the matrices differ in > dimensionality, `DQCS_FALSE` is used."],["dqcs_mat_len","Returns the number of complex entries in the given matrix. > > This function returns -1 when an error occurs."],["dqcs_mat_new","Constructs a new gate matrix. > > `num_qubits` must be set to the number of qubits mutated by this matrix. > It must be greater than or equal to zero. > `matrix` must point to an appropriately sized array of doubles. The matrix > is specified in row-major form, using pairs of doubles for the real vs. > imaginary component of each entry. The size must be `4**num_qubits` complex > numbers = `2*4**num_qubits` doubles = `16*4**num_qubits` bytes, > representing a `2**num_qubits` by `2**num_qubits` matrix. > This function returns the constructed matrix handle, or 0 if an error > occurs. > > While not enforced at this level, the matrix is normally unitary, or > approximately so within some floating-point error margin. > > This function returns the handle to the matrix, or 0 to indicate failure."],["dqcs_mat_num_qubits","Returns the number of qubits targeted by the given matrix. > > This function returns -1 when an error occurs."],["dqcs_mat_predef","Constructs a new gate matrix for one of DQCsim's predefined gates. > > `gate_type` specifies which kind of gate should be constructed. > > `param_data` takes an optional `ArbData` object used to parameterize the > matrix if necessary. If not specified, an empty object is used. The > `ArbData` representation for each gate can be found in the docs for > `dqcs_predefined_gate_t`. If nothing is specified, no `ArbData` is used. > > This function returns the handle to the matrix, or 0 to indicate failure. > The parameterization data (if specified) is consumed/deleted by this > function if and only if it succeeds."],["dqcs_mat_strip_control","Splits a controlled matrix into its non-controlled submatrix and the  indices of the control qubits. > > `mat` specifies the matrix to modify. This is a borrowed handle. > `epsilon` specifies the maximum magitude of the difference between the > column vectors of the input matrix and the identity matrix (after > dephasing if `ignore_gphase` is set) for the column vector to be > considered to not affect the respective entry in the quantum state > vector. Note that if this is greater than zero, the resulting gate may > not be exactly equivalent. If `ignore_global_phase` is set, any global > phase in the matrix is ignored, but note that if control qubits are > stripped the \"global\" phase of the resulting submatrix is always > significant. > `control_indices` is a return argument through which DQCsim will pass > the indices of the qubits that were removed in the process of constructing > the submatrix. This is represented as an array of indices terminated by > a -1 entry. The returned matrix must be freed using `free()` when you > are done with it to avoid memory leaks. This function returns a new > matrix handle with the submatrix, or 0 if it fails. In this case, > `control_indices` is not mutated. > > This function assumes that the incoming matrix is unitary (within > `epsilon`) without verifying that this is the case. The results may > thus be invalid if it was not."],["dqcs_meas_new","Constructs a new measurement object."],["dqcs_meas_qubit_get","Returns the qubit reference associated with a measurement object."],["dqcs_meas_qubit_set","Sets the qubit reference associated with a measurement object."],["dqcs_meas_value_get","Returns the measurement value associated with a measurement object."],["dqcs_meas_value_set","Sets the measurement value associated with a measurement object."],["dqcs_mset_contains","Returns whether the given qubit measurement set contains data for the given qubit."],["dqcs_mset_get","Returns a copy of the measurement result for the given qubit from a measurement result set."],["dqcs_mset_len","Returns the number of qubits measurements in the given measurement set."],["dqcs_mset_new","Creates a new set of qubit measurement results."],["dqcs_mset_remove","Removes the measurement result for the given qubit from a measurement result set."],["dqcs_mset_set","Adds a measurement result to a measurement result set."],["dqcs_mset_take","Returns the measurement result for the given qubit from a measurement result set and removes it from the set."],["dqcs_mset_take_any","Returns the measurement result for any of the qubits contained in a measurement result set and removes it from the set."],["dqcs_pcfg_accept_timeout_get","Returns the configured timeout for the plugin process to connect to DQCsim."],["dqcs_pcfg_accept_timeout_set","Configures the timeout for the plugin process to connect to DQCsim."],["dqcs_pcfg_env_set","Overrides an environment variable for the plugin process."],["dqcs_pcfg_env_unset","Removes/unsets an environment variable for the plugin process."],["dqcs_pcfg_executable","Returns the configured executable path for the given plugin process."],["dqcs_pcfg_init_cmd","Appends an `ArbCmd` to the list of initialization commands of a plugin process."],["dqcs_pcfg_name","Returns the configured name for the given plugin process."],["dqcs_pcfg_new","Creates a new plugin process configuration object using sugared syntax."],["dqcs_pcfg_new_raw","Creates a new plugin process configuration object using raw paths."],["dqcs_pcfg_script","Returns the configured script path for the given plugin process."],["dqcs_pcfg_shutdown_timeout_get","Returns the configured timeout for the plugin process to shut down gracefully."],["dqcs_pcfg_shutdown_timeout_set","Configures the timeout for the plugin process to shut down gracefully."],["dqcs_pcfg_stderr_mode_get","Returns the configured stderr capture mode for the specified plugin process."],["dqcs_pcfg_stderr_mode_set","Configures the capture mode for the stderr stream of the specified plugin process."],["dqcs_pcfg_stdout_mode_get","Returns the configured stdout capture mode for the specified plugin process."],["dqcs_pcfg_stdout_mode_set","Configures the capture mode for the stdout stream of the specified plugin process."],["dqcs_pcfg_tee","Configures a plugin process to also output its log messages to a file."],["dqcs_pcfg_type","Returns the type of the given plugin process configuration."],["dqcs_pcfg_verbosity_get","Returns the configured verbosity for the given plugin process."],["dqcs_pcfg_verbosity_set","Configures the logging verbosity for the given plugin process."],["dqcs_pcfg_work_get","Returns the configured working directory for the given plugin process."],["dqcs_pcfg_work_set","Overrides the working directory for the plugin process."],["dqcs_pdef_author","Returns the plugin author for the given plugin definition object."],["dqcs_pdef_name","Returns the plugin name for the given plugin definition object."],["dqcs_pdef_new","Creates a new `PluginDefinition` object."],["dqcs_pdef_set_advance_cb","Sets the callback for advancing time for operators and backends."],["dqcs_pdef_set_allocate_cb","Sets the qubit allocation callback for operators and backends."],["dqcs_pdef_set_drop_cb","Sets the user logic drop/cleanup callback."],["dqcs_pdef_set_free_cb","Sets the qubit deallocation callback for operators and backends."],["dqcs_pdef_set_gate_cb","Sets the gate execution callback for operators and backends."],["dqcs_pdef_set_host_arb_cb","Sets the callback function function for handling an arb from the host."],["dqcs_pdef_set_initialize_cb","Sets the user logic initialization callback."],["dqcs_pdef_set_modify_measurement_cb","Sets the measurement modification callback for operators."],["dqcs_pdef_set_run_cb","Sets the run callback for frontends."],["dqcs_pdef_set_upstream_arb_cb","Sets the callback function for handling an arb from upstream for operators and backends."],["dqcs_pdef_type","Returns the plugin type for the given plugin definition object."],["dqcs_pdef_version","Returns the plugin version for the given plugin definition object."],["dqcs_plugin_advance","Tells the downstream plugin to run for the specified number of cycles."],["dqcs_plugin_allocate","Allocate the given number of downstream qubits."],["dqcs_plugin_arb","Sends an arbitrary command downstream."],["dqcs_plugin_free","Free the given downstream qubits."],["dqcs_plugin_gate","Tells the downstream plugin to execute a gate."],["dqcs_plugin_get_cycle","Returns the current value of the downstream cycle counter."],["dqcs_plugin_get_cycles_between_measures","Returns the number of downstream cycles between the last two measurements of the given downstream qubit."],["dqcs_plugin_get_cycles_since_measure","Returns the number of downstream cycles since the latest measurement of the given downstream qubit."],["dqcs_plugin_get_measurement","Returns the latest measurement of the given downstream qubit."],["dqcs_plugin_random_f64","Generates a random floating point number using the simulator random seed."],["dqcs_plugin_random_u64","Generates a random unsigned 64-bit number using the simulator random seed."],["dqcs_plugin_recv","Waits for a message from the host."],["dqcs_plugin_run","Executes a plugin in the current thread."],["dqcs_plugin_send","Sends a message to the host."],["dqcs_plugin_start","Executes a plugin in a worker thread."],["dqcs_plugin_wait","Waits for a plugin worker thread to finish executing."],["dqcs_qbset_contains","Returns whether the given qubit set contains the given qubit."],["dqcs_qbset_copy","Returns a copy of the given qubit set, intended for non-destructive iteration."],["dqcs_qbset_len","Returns the number of qubits in the given set."],["dqcs_qbset_new","Creates a new set of qubit references."],["dqcs_qbset_pop","Pops a qubit reference off of a qubit reference set."],["dqcs_qbset_push","Pushes a qubit reference into a qubit reference set."],["dqcs_scfg_dqcsim_verbosity_get","Returns the configured verbosity for DQCsim's own messages."],["dqcs_scfg_dqcsim_verbosity_set","Configures the logging verbosity for DQCsim's own messages."],["dqcs_scfg_log_callback","Configures DQCsim to also output its log messages to callback function."],["dqcs_scfg_new","Constructs an empty simulation configuration."],["dqcs_scfg_push_plugin","Appends a plugin to a simulation configuration."],["dqcs_scfg_repro_disable","Disables the reproduction logging system."],["dqcs_scfg_repro_path_style_get","Returns the path style used when writing reproduction files."],["dqcs_scfg_repro_path_style_set","Sets the path style used when writing reproduction files."],["dqcs_scfg_seed_get","Returns the configured random seed."],["dqcs_scfg_seed_set","Configures the random seed that the simulation should use."],["dqcs_scfg_stderr_verbosity_get","Returns the configured stderr sink verbosity for a simulation."],["dqcs_scfg_stderr_verbosity_set","Configures the stderr sink verbosity for a simulation."],["dqcs_scfg_tee","Configures DQCsim to also output its log messages to a file."],["dqcs_sim_arb","Sends an `ArbCmd` message to one of the plugins, referenced by name."],["dqcs_sim_arb_idx","Sends an `ArbCmd` message to one of the plugins, referenced by index."],["dqcs_sim_get_author","Queries the author of a plugin, referenced by instance name."],["dqcs_sim_get_author_idx","Queries the author of a plugin, referenced by index."],["dqcs_sim_get_name","Queries the implementation name of a plugin, referenced by instance name."],["dqcs_sim_get_name_idx","Queries the implementation name of a plugin, referenced by index."],["dqcs_sim_get_version","Queries the version of a plugin, referenced by instance name."],["dqcs_sim_get_version_idx","Queries the version of a plugin, referenced by index."],["dqcs_sim_new","Constructs a DQCsim simulation."],["dqcs_sim_recv","Waits for the simulated accelerator to send a message to us."],["dqcs_sim_send","Sends a message to the simulated accelerator."],["dqcs_sim_start","Starts a program on the simulated accelerator."],["dqcs_sim_wait","Waits for the simulated accelerator to finish its current program."],["dqcs_sim_write_reproduction_file","Writes a reproduction file for the simulation so far."],["dqcs_sim_yield","Yields to the simulator."],["dqcs_tcfg_init_cmd","Appends an `ArbCmd` to the list of initialization commands of a plugin thread."],["dqcs_tcfg_name","Returns the configured name for the given plugin thread."],["dqcs_tcfg_new","Creates a new plugin thread configuration object from a plugin definition."],["dqcs_tcfg_new_raw","Creates a new plugin thread configuration object from a callback."],["dqcs_tcfg_tee","Configures a plugin thread to also output its log messages to a file."],["dqcs_tcfg_type","Returns the type of the given plugin thread configuration."],["dqcs_tcfg_verbosity_get","Returns the configured verbosity for the given plugin thread."],["dqcs_tcfg_verbosity_set","Configures the logging verbosity for the given plugin thread."]],"struct":[["dqcs_plugin_state_t","Type for a plugin state."]],"type":[["dqcs_cycle_t","Type for a simulation cycle timestamp."],["dqcs_handle_t","Type for a handle."],["dqcs_qubit_t","Type for a qubit reference."]]});