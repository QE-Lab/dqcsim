initSidebarItems({"enum":[["dqcs_bool_return_t","Return type for functions that normally return a boolean but can also fail."],["dqcs_handle_type_t","Enumeration of types that can be associated with a handle."],["dqcs_loglevel_t","Enumeration of loglevels and logging modes."],["dqcs_measurement_t","Qubit measurement value."],["dqcs_path_style_t","Reproduction file path style."],["dqcs_plugin_type_t","Enumeration of the three types of plugins."],["dqcs_return_t","Default return type for functions that don't need to return anything."]],"fn":[["dqcs_arb_assign","Copies the data from one object to another."],["dqcs_arb_cbor_get","Returns the JSON/CBOR object of an `ArbData` object in the form of a CBOR  object. > > If the actual size of the object differs from the specified object size, > this function will copy the minimum of the actual and specified sizes > number of bytes, and return what the actual size was. > > If the specified object size is zero, `obj` is allowed to be `NULL`. You > can use this to query the size before allocating an object. > > This function returns -1 on failure."],["dqcs_arb_cbor_set","Sets the JSON/CBOR object of an `ArbData` object by means of a CBOR object."],["dqcs_arb_clear","Clears the unstructured argument list."],["dqcs_arb_get_raw","Returns the unstructured string argument at the specified index. > > If the actual size of the object differs from the specified object size, > this function will copy the minimum of the actual and specified sizes > number of bytes, and return what the actual size was. > > If the specified object size is zero, `obj` is allowed to be `NULL`. You > can use this to determine the size of the argument prior to actually > reading it, so you can allocate the right buffer size first. > > This function returns -1 on failure."],["dqcs_arb_get_size","Returns the size in bytes of the unstructured string argument at the  specified index. > > Returns -1 when the function fails."],["dqcs_arb_get_str","Returns the unstructured string argument at the specified index. > > On success, this returns a newly allocated string containing the JSON > string. Free it with `free()` when you're done with it to avoid memory > leaks. On failure, this returns `NULL`."],["dqcs_arb_insert_raw","Inserts an unstructured raw argument into the list at the specified index."],["dqcs_arb_insert_str","Inserts an unstructured string argument into the list at the specified index."],["dqcs_arb_json_get","Returns the JSON/CBOR object of an `ArbData` object in the form of a JSON  string. > > On success, this returns a newly allocated string containing the JSON > string. Free it with `free()` when you're done with it to avoid memory > leaks. On failure, this returns `NULL`."],["dqcs_arb_json_set","Sets the JSON/CBOR object of an `ArbData` object by means of a JSON string."],["dqcs_arb_len","Returns the number of unstructured arguments, or -1 to indicate failure."],["dqcs_arb_new","Creates a new `ArbData` object. > > Returns the handle of the newly created `ArbData`. The `ArbData` is > initialized with JSON object `{}` and an empty binary argument list. > > `ArbData` objects support the `handle` and `arb` APIs."],["dqcs_arb_pop","Pops an unstructured argument from the back of the list without returning it."],["dqcs_arb_pop_raw","Pops an unstructured raw argument from the back of the list. > > If the actual size of the object differs from the specified object size, > this function will copy the minimum of the actual and specified sizes > number of bytes, and return what the actual size was. > > If the specified object size is zero, `obj` is allowed to be `NULL`. You > can use this if you don't need the contents of the argument and just want > to delete it. > > Since this function removes the returned element, data will be lost if the > specified size is smaller than the actual size. To avoid this, first use > `dqcs_arb_get_size(handle, -1)` to query the size. > > This function returns -1 on failure. If this is due to a `NULL` buffer > being passed, the data that was popped is lost."],["dqcs_arb_pop_str","Pops an unstructured string argument from the back of the list. > > On success, this returns a newly allocated string containing the JSON > string. Free it with `free()` when you're done with it to avoid memory > leaks. On failure, this returns `NULL`. If the failure is due to the > conversion from binary object to C string (i.e., embedded nulls), the > data is still popped and is thus lost."],["dqcs_arb_push_raw","Pushes an unstructured raw argument to the back of the list."],["dqcs_arb_push_str","Pushes an unstructured string argument to the back of the list."],["dqcs_arb_remove","Removes the specified unstructured string argument from the list."],["dqcs_arb_set_raw","Replaces the unstructured argument at the specified index with the specified raw object."],["dqcs_arb_set_str","Replaces the unstructured argument at the specified index with the specified string."],["dqcs_cmd_iface_cmp","Compares the interface ID of an `ArbCmd` with the given string. > > Returns -1 for failure, 0 for no match, or 1 for a match."],["dqcs_cmd_iface_get","Returns the interface ID of an `ArbCmd`. > > On success, this returns a newly allocated string containing the JSON > string. Free it with `free()` when you're done with it to avoid memory > leaks. On failure, this returns `NULL`."],["dqcs_cmd_new","Creates a new `ArbCmd` object. > > Returns the handle of the newly created `ArbCmd`. The `ArbCmd` is > initialized with the given interface and operation IDs, JSON object `{}`, > and an empty binary argument list. Upon failure, returns 0. > > `ArbCmd` objects support the `handle`, `arb`, and `cmd` interfaces."],["dqcs_cmd_oper_cmp","Compares the operation ID of an `ArbCmd` with the given string. > > Returns -1 for failure, 0 for no match, or 1 for a match."],["dqcs_cmd_oper_get","Returns the operation ID of an `ArbCmd`. > > On success, this returns a newly allocated string containing the JSON > string. Free it with `free()` when you're done with it to avoid memory > leaks. On failure, this returns `NULL`."],["dqcs_cq_len","Returns the number of `ArbCmd` objects in the given `ArbCmd` queue. > > This function returns -1 to indicate failure."],["dqcs_cq_new","Creates a new `ArbCmd` queue object. > > Returns the handle of the newly created `ArbCmd` queue. The queue is > initially empty. Queues implement a \"first-in, first-out\" model. > > `ArbCmd` queue objects support the `handle`, `arb`, `cmd`, and `cq` APIs. > > The `arb` and `cmd` APIs refer to the `ArbCmd` at the front of the queue. > Use `dqcs_cq_next()` to remove the front entry, allowing access to the next > command."],["dqcs_cq_next","Advances an `ArbCmd` queue to the next command. > > Use the `dqcs_arb_*` and `dqcs_cmd_*` interfaces to read out the command > before calling this function. > > To iterate over a queue in C, use the following snippit: > > `C > for (; dqcs_cq_len(queue) > 0; dqcs_cq_next(queue)) { >     dqcs_cmd_...(queue, ...) >     dqcs_arb_...(queue, ...) > } > `"],["dqcs_cq_push","Pushes an `ArbCmd` object into the given `ArbCmd` queue. > > This function returns -1 to indicate failure. The `ArbCmd` object specified > by `cmd` is moved into the queue. That is, the handle is consumed if and > only if the function succeeds."],["dqcs_error_get","Returns a pointer to the latest error message. > > Call this to get extra information when another function returns a failure > code. The returned pointer is temporary and therefore should NOT be > `free()`d. It will become invalid when a new error occurs."],["dqcs_error_set","Sets the latest error message string. > > This must be called by callback functions when an error occurs within the > callback, otherwise the upstream result for `dqcs_error_get()` will be > undefined. > > If `msg` is set to `NULL`, the error string is cleared instead."],["dqcs_gate_controls","Returns a handle to a new qubit reference set containing the qubits that control this gate."],["dqcs_gate_has_controls","Returns whether the specified gate has control qubits."],["dqcs_gate_has_matrix","Returns whether a unitary matrix is associated with this gate."],["dqcs_gate_has_measures","Returns whether the specified gate measures any qubits."],["dqcs_gate_has_targets","Returns whether the specified gate has target qubits."],["dqcs_gate_is_custom","Returns whether the specified gate is a custom gate. > > If this returns true, the type of gate is to be determined by matching its > name against a set of known gate types. If this returns false, the gate is > expected to be executed as follows, in this order: > >  - if there are target qubits, extend the supplied unitary matrix to >    include the control qubits (if any), then apply it to the control + >    target qubits; >  - measure each measured qubit (if any) in the Z basis."],["dqcs_gate_matrix","Returns a copy of the unitary matrix associated with this gate, if one  exists. > > If this function succeeds, the matrix is returned in row-major form, using > pairs of doubles for the real vs. imaginary component of each entry. The > size will be `4**len(targets)` complex numbers = `2*4**len(targets)` > doubles = `16*4**len(targets)` bytes. > > On success, this returns a newly allocated array containing the matrix. > Free it with `free()` when you're done with it to avoid memory leaks. On > failure, or if no matrix is associated with this gate, this returns `NULL`. > Use `dqcs_gate_has_matrix()` to disambiguate."],["dqcs_gate_matrix_len","Returns the size of the gate matrix associated with this gate. > > The size is returned in the form of the number of complex entries. That is, > the number of doubles is two times the return value, and the size in bytes > is 8 times the return value. 0 is returned when there is no matrix. -1 is > used to report errors."],["dqcs_gate_measures","Returns a handle to a new qubit reference set containing the qubits measured by this gate."],["dqcs_gate_name","Returns the name of a custom gate. > > This function fails if the gate is not a custom gate. Query > `dqcs_gate_is_custom()` to disambiguate between a non-custom gate and a > different error. > > On success, this returns a newly allocated string containing the gate > name. Free it with `free()` when you're done with it to avoid memory > leaks. On failure, this returns `NULL`."],["dqcs_gate_new_custom","Constructs a new custom gate. > > The functionality of custom gates is not specified by DQCsim. Instead, this > is left up to the plugins. Of course, for this to work, plugins that are > connected to each other must agree on the format used. > > `name` specifies the name of the gate. The name is used to indicate which > custom operation is to be applied. > > `targets` optionally specifies the set of target qubits. You may pass 0 or > an empty qubit set if you don't need target qubits. > > `controls` optionally specifies the set of control qubits. You may pass 0 > or an empty qubit set if you don't need control qubits. > > `measures` optionally specifies the set of measured qubits. You may pass 0 > or an empty qubit set if no qubits are measured. Note that the upstream > plugin expects exactly one measurement result for each qubit specified in > this set; anything else results in a warning and the measurement result > being set to undefined. > > `matrix` can point to an appropriately sized array of doubles, or be `NULL` > if no matrix is required. If a matrix is specified, at least one target > qubit is required, and the matrix must be appropriately sized for the > number of target qubits. The matrix is specified in row-major form, using > pairs of doubles for the real vs. imaginary component of each entry. The > size must thus be `4**len(targets)` complex numbers = `2*4**len(targets)` > doubles = `16*4**len(targets)` bytes. `matrix_len` must be set to the > number of complex numbers. > > In addition to the above data, gate objects implement the `arb` interface > to allow user-specified classical information to be attached. > > This function returns the handle to the gate, or 0 to indicate failure. > The specified qubit sets are consumed/deleted by this function if and only > if it succeeds."],["dqcs_gate_new_measurement","Constructs a new measurement gate. > > `measures` must be a handle to a qubit set. The qubits in this set are > measured in the Z-basis. To measure in other bases, first apply the > respective rotation, or use a custom gate. > > This function returns the handle to the gate, or 0 to indicate failure. > The `measures` qubit set is consumed/deleted by this function if and only > if it succeeds."],["dqcs_gate_new_unitary","Constructs a new unitary gate. > > `targets` must be a handle to a non-empty qubit set. The qubits in this set > correspond with the supplied unitary matrix. > > `controls` optionally specifies a set of control qubits. You may pass 0 or > an empty qubit set if you don't need control qubits. > > `matrix` must point to an appropriately sized array of doubles, > representing the unitary matrix to be applied to the qubits in the > `targets` set. The matrix is specified in row-major form, using pairs of > doubles for the real vs. imaginary component of each entry. The size must > thus be `4**len(targets)` complex numbers = `2*4**len(targets)` doubles = > `16*4**len(targets)` bytes. `matrix_len` must be set to the number of > complex numbers. > > The supplied matrix is only applied to the target qubits if all the control > qubits are or will be determined to be set. For instance, to encode a > CCNOT/Toffoli gate, you can specify one target qubits, two control qubits, > and [0, 1; 1, 0] (X) for the matrix. This is equivalent to extending the > matrix to the full Toffoli matrix and specifying all three qubits in the > targets set, or the midway solution using a CNOT matrix, but these > solutions may be less efficient depending on whether the simulator can > optimize its calculations for controlled gates. > > Simulators are not required to apply the (hidden) global phase component of > the gate matrix in the same way it is specified; that is, if the simulator > can optimize its calculations by altering the global phase it is allowed > to. > > If is up to the user to ensure that the specified matrix is unitary. This > is NOT checked by DQCsim. The simulator backend may or may not check this. > > This function returns the handle to the gate, or 0 to indicate failure. > The `targets` qubit set and (if specified) the `controls` qubit set are > consumed/deleted by this function if and only if it succeeds."],["dqcs_gate_targets","Returns a handle to a new qubit reference set containing the qubits targetted by this gate."],["dqcs_handle_delete","Destroys the object associated with a handle. > > Returns 0 when successful, -1 otherwise."],["dqcs_handle_delete_all","Deletes all handles for the current thread. > > This can be used to clean stuff up at the end of `main()` or before an > `abort()` of some kind. If you don't clean up properly, you might get > undefined behavior or errors when DQCsim tries to do it for you."],["dqcs_handle_dump","Returns a debug dump of the object associated with the given handle. > > On success, this returns a newly allocated string containing the > description. Free it with `free()` when you're done with it to avoid memory > leaks. On failure (i.e., the handle is invalid) this returns `NULL`."],["dqcs_handle_leak_check","Succeeds only if there are no live handles in the current thread. > > This is intended for testing and for finding handle leaks. The error > message returned when handles remain contains dumps of the first 10 > remaining handles."],["dqcs_handle_type","Returns the type of object associated with the given handle."],["dqcs_log_raw","Primitive API for sending a log message using the current logger. > > Returns `DQCS_SUCCESS` if logging was successful, or `DQCS_FAILURE` if no > logger is available in the current thread or one of the arguments could not > be converted. Loggers are available in the simulation host thread and in > threads running plugins. > > ## Formatting and fallback to stderr > > As an alternative to this function, you can also use `dqcs_log_format()`. > This function differs from `dqcs_log_raw()` in two ways: > >  - Instead of the `message` string, a printf-style format string and >    associated varargs are passed to construct the message. >  - When logging fails, this function falls back to writing to `stderr` >    instead of returning the errors. > > ## Macros > > From C and C++, these functions are normally not called directly. Instead, > the following macros are used: > > `C > dqcs_log_trace(\"trace message!\"); > dqcs_log_debug(\"debug message!\"); > dqcs_log_info(\"info message!\"); > dqcs_log_note(\"notice!\"); > dqcs_log_warn(\"warning!\"); > dqcs_log_error(\"error!\"); > dqcs_log_fatal(\"fatal error!\"); > ` > > These macros automatically set `file` to the C source filename and `line` > to the line number. `module` is hardcoded to \"C\" or \"CPP\" depending on > source file language. They use `dqcs_log_format()`, so they also support > printf-style formatting. For instance: > > `C > dqcs_note(\"answer to %s: %d\", \"ultimate question\", 42); > `"],["dqcs_meas_new","Constructs a new measurement object. > > `qubit` must be set to the qubit that was measured, `value` must be set to > its value. The return value is the handle to the measurement object, or 0 > if something went wrong. > > Note that measurement objects implement the `arb` interface, so additional > data can be attached to the object."],["dqcs_meas_qubit_get","Returns the qubit reference associated with a measurement object."],["dqcs_meas_qubit_set","Sets the qubit reference associated with a measurement object."],["dqcs_meas_value_get","Returns the measurement value associated with a measurement object."],["dqcs_meas_value_set","Sets the measurement value associated with a measurement object."],["dqcs_mset_contains","Returns whether the given qubit measurement set contains data for the given qubit."],["dqcs_mset_get","Returns a copy of the measurement result for the given qubit from a measurement result set."],["dqcs_mset_len","Returns the number of qubits measurements in the given measurement set. > > This function returns -1 to indicate failure."],["dqcs_mset_new","Creates a new set of qubit measurement results. > > Returns the handle of the newly created set. The set is initially empty."],["dqcs_mset_remove","Removes the measurement result for the given qubit from a measurement result set."],["dqcs_mset_set","Adds a measurement result to a measurement result set. > > If there was already a measurement for the specified qubit, the previous > measurement result is overwritten. The measurement result object is deleted > if and only if the function succeeds."],["dqcs_mset_take","Returns the measurement result for the given qubit from a measurement result set and removes it from the set."],["dqcs_mset_take_any","Returns the measurement result for any of the qubits contained in a  measurement result set and removes it from the set. > > This is useful for iteration."],["dqcs_pcfg_accept_timeout_get","Returns the configured timeout for the plugin process to connect to DQCsim. > > The time unit is in seconds. Returns positive inifinity for an infinite > timeout. Returns -1 when the function fails."],["dqcs_pcfg_accept_timeout_set","Configures the timeout for the plugin process to connect to DQCsim. > > The default is 5 seconds, so you should normally be able to leave this > alone. > > The time unit is seconds. Use IEEE positive infinity to specify an infinite > timeout."],["dqcs_pcfg_env_set","Overrides an environment variable for the plugin process. > > The environment variable `key` is set to `value` regardless of whether it > exists in the parent environment variable scope. > > If value is `NULL`, the environment variable `key` is unset instead."],["dqcs_pcfg_env_unset","Removes/unsets an environment variable for the plugin process. > > The environment variable `key` is unset regardless of whether it exists in > the parent environment variable scope."],["dqcs_pcfg_executable","Returns the configured executable path for the given plugin process. > > On success, this returns a newly allocated string containing the > executable path. Free it with `free()` when you're done with it to avoid > memory leaks. On failure (i.e., the handle is invalid) this returns > `NULL`."],["dqcs_pcfg_init_cmd","Appends an `ArbCmd` to the list of initialization commands of a plugin  process. > > The `ArbCmd` handle is consumed by this function, and is thus invalidated, > if and only if it is successful."],["dqcs_pcfg_name","Returns the configured name for the given plugin process. > > On success, this returns a newly allocated string containing the > name. Free it with `free()` when you're done with it to avoid memory > leaks. On failure (i.e., the handle is invalid) this returns `NULL`."],["dqcs_pcfg_new","Creates a new plugin process configuration object using sugared syntax. > > `typ` specifies the type of plugin. `name` specifies the name used to refer > to the plugin later, which much be unique within a simulation; if it is > empty or `NULL`, auto-naming will be performed: \"front\" for the frontend, > \"oper<i>\" for the operators (indices starting at 1 from frontend to > backend), and \"back\" for the backend. `spec` specifies which plugin to use, > using the same syntax that the `dqcsim` command line interface uses."],["dqcs_pcfg_new_raw","Creates a new plugin process configuration object using raw paths. > > This works the same as `dqcs_pcfg_new()`, but instead of the sugared, > command-line style specification you have to specify the path to the plugin > executable and (if applicable) the script it must execute directly. This is > useful when you have a specific executable in mind and you don't want the > somewhat heuristic desugaring algorithm from doing something unexpected. > > Pass `NULL` or an empty string to `script` to specify a native plugin > executable that does not take a script argument."],["dqcs_pcfg_script","Returns the configured script path for the given plugin process. > > On success, this returns a newly allocated string containing the > script path. Free it with `free()` when you're done with it to avoid memory > leaks. On failure (i.e., the handle is invalid) this returns `NULL`. An > empty string will be returned if no script is configured to distinguish it > from failure."],["dqcs_pcfg_shutdown_timeout_get","Returns the configured timeout for the plugin process to shut down  gracefully. > > The time unit is in seconds. Returns positive inifinity for an infinite > timeout. Returns -1 when the function fails."],["dqcs_pcfg_shutdown_timeout_set","Configures the timeout for the plugin process to shut down gracefully. > > The default is 5 seconds, so you should normally be able to leave this > alone. > > The time unit is seconds. Use IEEE positive infinity to specify an infinite > timeout."],["dqcs_pcfg_stderr_mode_get","Returns the configured stderr capture mode for the specified plugin process."],["dqcs_pcfg_stderr_mode_set","Configures the capture mode for the stderr stream of the specified plugin process."],["dqcs_pcfg_stdout_mode_get","Returns the configured stdout capture mode for the specified plugin process."],["dqcs_pcfg_stdout_mode_set","Configures the capture mode for the stdout stream of the specified plugin process."],["dqcs_pcfg_tee","Configures a plugin process to also output its log messages to a file. > > `verbosity` configures the verbosity level for the file only."],["dqcs_pcfg_type","Returns the type of the given plugin process configuration."],["dqcs_pcfg_verbosity_get","Returns the configured verbosity for the given plugin process."],["dqcs_pcfg_verbosity_set","Configures the logging verbosity for the given plugin process."],["dqcs_pcfg_work_get","Returns the configured working directory for the given plugin process. > > On success, this returns a newly allocated string containing the > working directory. Free it with `free()` when you're done with it to avoid > memory leaks. On failure (i.e., the handle is invalid) this returns > `NULL`."],["dqcs_pcfg_work_set","Overrides the working directory for the plugin process."],["dqcs_pdef_author","Returns the plugin author for the given plugin definition object. > > On success, this returns a newly allocated string containing the JSON > string. Free it with `free()` when you're done with it to avoid memory > leaks. On failure, this returns `NULL`."],["dqcs_pdef_name","Returns the plugin name for the given plugin definition object. > > On success, this returns a newly allocated string containing the JSON > string. Free it with `free()` when you're done with it to avoid memory > leaks. On failure, this returns `NULL`."],["dqcs_pdef_new","Creates a new `PluginDefinition` object. > > Plugin definitions contain the callback functions/closures that define the > functionality of a plugin. They also contain some metadata to identify the > implementation, in the form of a name, author, and version string, that > must be specified when the definition is constructed. The callback > functions/closures are initialized to sane defaults for the requested > plugin type, but obviously one or more of these should be overridden to > make the plugin do something. > > Once a definition object has been built, it can be used to spawn a plugin > thread or run a plugin in the main thread, given a DQCsim server URL for it > to connect to."],["dqcs_pdef_set_advance_cb","Sets the callback for advancing time for operators and backends. > > The default behavior for operators is to pass through to > `dqcs_plugin_advance()`. The default for backends is no-op. This > callback is never called for frontend plugins. > > Besides the common arguments, the callback receives an unsigned integer > specifying the number of cycles to advance by. > > The callback can return an error by setting an error message using > `dqcs_error_set()` and returning `DQCS_FAILURE`. Otherwise, it should > return `DQCS_SUCCESS`."],["dqcs_pdef_set_allocate_cb","Sets the qubit allocation callback for operators and backends. > > The default for operators is to pass through to > `dqcs_plugin_allocate()`. The default for backends is no-op. This > callback is never called for frontend plugins. > > Besides the common arguments, the callback receives a handle to a qubit > set containing the references that are to be used for the > to-be-allocated qubits and an `ArbCmd` queue containing user-defined > commands to optionally augment the behavior of the qubits. These are > borrowed handles; the caller will delete them. > > The callback can return an error by setting an error message using > `dqcs_error_set()` and returning `DQCS_FAILURE`. Otherwise, it should > return `DQCS_SUCCESS`."],["dqcs_pdef_set_drop_cb","Sets the user logic drop/cleanup callback. > > This is called when a plugin is gracefully terminated. It is not > recommended to execute any downstream instructions at this time, but it > is supported in case this is really necessary. > > The default behavior is no-op. > > The callback can return an error by setting an error message using > `dqcs_error_set()` and returning `DQCS_FAILURE`. Otherwise, it should > return `DQCS_SUCCESS`."],["dqcs_pdef_set_free_cb","Sets the qubit deallocation callback for operators and backends. > > The default for operators is to pass through to `dqcs_plugin_free()`. > The default for backends is no-op. This callback is never called for > frontend plugins. > > Besides the common arguments, the callback receives a handle to a qubit > set containing the qubits that are to be freed. This is a borrowed > handle; the caller will delete it. > > The callback can return an error by setting an error message using > `dqcs_error_set()` and returning `DQCS_FAILURE`. Otherwise, it should > return `DQCS_SUCCESS`."],["dqcs_pdef_set_gate_cb","Sets the gate execution callback for operators and backends. > > Besides the common arguments, the callback receives a handle to the > to-be-executed gate. This is a borrowed handle; the caller will delete > it. > > The callback must return one of the following things: > >  - a valid handle to a measurement set, created using >    `dqcs_mset_new()` (this object is automatically deleted after the >    callback returns); >  - a valid handle to a single qubit measurement, created using >    `dqcs_meas_new()` (this object is automatically deleted after the >    callback returns); >  - the handle to the supplied gate, a shortcut for not returning any >    measurements (this is less clear than returning an empty measurement >    set, but slightly faster); or >  - 0 to report an error, after calling the error string using >    `dqcs_set_error()`. > > Backend plugins must return a measurement result set containing exactly > those qubits specified in the measurement set. For operators, however, > the story is more complicated. Let's say we want to make a silly > operator that inverts all measurements. The trivial way to do > this would be to forward the gate, query all the measurement results > using `dqcs_plugin_get_measurement()`, invert them, stick them in a > measurement result set, and return that result set. However, this > approach is not very efficient, because `dqcs_plugin_get_measurement()` > has to wait for all downstream plugins to finish executing the gate, > forcing the OS to switch threads, etc. Instead, operators are allowed > to return only a subset (or none) of the measured qubits, as long as > they return the measurements as they arrive through the > `modify_measurement()` callback. > > The default implementation for this callback for operators is to pass > the gate through to the downstream plugin and return an empty set of > measurements. Combined with the default implementation of > `modify_measurement()`, this behavior is sane. Backends must override > this callback; the default is to return a not-implemented error. > > Note that for our silly example operator, the default behavior for this > function is sufficient; you'd only have to override > `modify_measurement()` to, well, modify the measurements."],["dqcs_pdef_set_host_arb_cb","Sets the callback function function for handling an arb from the host. > > The default behavior for this is no-op. > > Besides the common arguments, the callback receives a handle to the > `ArbCmd` object representing the request. It must return a valid > `ArbData` handle containing the response. Both objects are deleted > automatically after invocation. > > The callback can return an error by setting an error message using > `dqcs_error_set()` and returning 0. Otherwise, it should return a valid > `ArbData` handle."],["dqcs_pdef_set_initialize_cb","Sets the user logic initialization callback. > > This is always called before any of the other callbacks are run. The > downstream plugin has already been initialized at this stage, so it is > legal to send it commands. > > The default behavior is no-op. > > Besides the common arguments, the callback receives a handle to an > `ArbCmd` queue (`dqcs_cq_*`, `dqcs_cmd_*`, and `dqcs_arb_*` interfaces) > containing user-defined initialization commands. This is a borrowed > handle; the caller will delete it. > > The callback can return an error by setting an error message using > `dqcs_error_set()` and returning `DQCS_FAILURE`. Otherwise, it should > return `DQCS_SUCCESS`."],["dqcs_pdef_set_modify_measurement_cb","Sets the measurement modification callback for operators. > > This callback is called for every measurement result received from the > downstream plugin, and returns the measurements that should be reported > to the upstream plugin. Note that the results from our plugin's > `dqcs_plugin_get_measurement()` and friends are consistent with the > results received from downstream; they are not affected by this > function. > > The callback takes a handle to a single qubit measurement object as an > argument, and must return one of the following things: > >  - a valid handle to a measurement set, created using >    `dqcs_mset_new()` (this object is automatically deleted after the >    callback returns); >  - a valid handle to a single qubit measurement object, which may or >    may not be the supplied one (this object is automatically deleted >    after the callback returns); or >  - 0 to report an error, after calling the error string using >    `dqcs_set_error()`. > > This callback is somewhat special in that it is not allowed to call > any plugin command other than logging and the pseudorandom number > generator functions. This is because this function is called > asynchronously with respect to the downstream functions, making the > timing of these calls non-deterministic based on operating system > scheduling. > > Note that while this function is called for only a single measurement > at a time, it is allowed to produce a vector of measurements. This > allows you to cancel propagation of the measurement by returning an > empty vector, to just modify the measurement data itself, or to > generate additional measurements from a single measurement. However, > if you need to modify the qubit references for operators that remap > qubits, take care to only send measurement data upstream when these > were explicitly requested through the associated upstream gate > function's `measured` list. > > The default behavior for this callback is to return the measurement > without modification."],["dqcs_pdef_set_run_cb","Sets the run callback for frontends. > > This is called in response to a `start()` host API call. The return > value is returned through the `wait()` host API call. > > The default behavior is to fail with a \"not implemented\" error; > frontends backends should always override this. This callback is never > called for operator or backend plugins. > > Besides the common arguments, the callback receives a handle to an > `ArbData` object containing the data that the host passed to `start()`. > This is a borrowed handle; the caller will delete it. > > When the run callback is successful, it should return a valid `ArbData` > handle. This can be the same as the argument, but it can also be a new > object. This `ArbData` is returned to the host through `wait()`. This > `ArbData` object is deleted after the callback completes. > > The callback can return an error by setting an error message using > `dqcs_error_set()` and returning 0. Otherwise, it should return a > valid `ArbData` handle."],["dqcs_pdef_set_upstream_arb_cb","Sets the callback function for handling an arb from upstream for  operators and backends. > > The default behavior for operators is to pass through to > `dqcs_plugin_arb()`; operators that do not support the requested > interface should always do this. The default for backends is no-op. > This callback is never called for frontend plugins. > > Besides the common arguments, the callback receives a handle to the > `ArbCmd` object representing the request. It must return a valid > `ArbData` handle containing the response. Both objects are deleted > automatically after invocation. > > The callback can return an error by setting an error message using > `dqcs_error_set()` and returning 0. Otherwise, it should return a valid > `ArbData` handle."],["dqcs_pdef_type","Returns the plugin type for the given plugin definition object."],["dqcs_pdef_version","Returns the plugin version for the given plugin definition object. > > On success, this returns a newly allocated string containing the JSON > string. Free it with `free()` when you're done with it to avoid memory > leaks. On failure, this returns `NULL`."],["dqcs_plugin_advance","Tells the downstream plugin to run for the specified number of cycles. > > Backend plugins are not allowed to call this. Doing so will result in an > error. > > The return value is the new cycle counter. This function uses -1 to signal > an error."],["dqcs_plugin_allocate","Allocate the given number of downstream qubits. > > Backend plugins are not allowed to call this. Doing so will result in an > error. > > `num_qubits` specifies the number of qubits that are to be allocated. > > `commands` must be 0 or a valid handle to an `ArbCmd` queue, containing a > list of commands that may be used to modify the behavior of the qubit > register; 0 is equivalent to zero commands. The queue is consumed by this > function, i.e. the handle becomes invalid, if and only if it succeeds. > > If the function is successful, a new handle to the set of qubit references > representing the newly allocated register is returned. When the function > fails, 0 is returned."],["dqcs_plugin_arb","Sends an arbitrary command downstream. > > Backend plugins are not allowed to call this. Doing so will result in an > error. > > This function returns a new handle to an `ArbData` object representing the > return value of the `ArbCmd` when successful. Otherwise, it returns 0."],["dqcs_plugin_free","Free the given downstream qubits. > > Backend plugins are not allowed to call this. Doing so will result in an > error. > > `qubits` must be a valid set of qubit references. The set is consumed by > this function, i.e. the handle becomes invalid, if and only if it succeeds."],["dqcs_plugin_gate","Tells the downstream plugin to execute a gate. > > Backend plugins are not allowed to call this. Doing so will result in an > error. > > `gate` must be a valid gate object. The object is consumed by this > function, i.e. the handle becomes invalid, if and only if it succeeds."],["dqcs_plugin_get_cycle","Returns the current value of the downstream cycle counter. > > Backend plugins are not allowed to call this. Doing so will result in an > error. > > This function uses -1 to signal an error."],["dqcs_plugin_get_cycles_between_measures","Returns the number of downstream cycles between the last two measurements  of the given downstream qubit. > > Backend plugins are not allowed to call this. Doing so will result in an > error. > > This function uses -1 to signal an error."],["dqcs_plugin_get_cycles_since_measure","Returns the number of downstream cycles since the latest measurement of the  given downstream qubit. > > Backend plugins are not allowed to call this. Doing so will result in an > error. > > This function uses -1 to signal an error."],["dqcs_plugin_get_measurement","Returns the latest measurement of the given downstream qubit. > > Backend plugins are not allowed to call this. Doing so will result in an > error. > > If the function succeeds, it returns a new handle to a qubit measurement > result object. Otherwise it returns 0."],["dqcs_plugin_random_f64","Generates a random floating point number using the simulator random seed. > > The generated numbers are uniformly distributed in the range `[0,1>`. > > This function only fails if the `plugin` handle is invalid, in which case > it returns 0. Of course, 0 is also a valid (if rare) random return value."],["dqcs_plugin_random_u64","Generates a random unsigned 64-bit number using the simulator random seed. > > This function only fails if the `plugin` handle is invalid, in which case > it returns 0. Of course, 0 is also a valid (if rare) random return value."],["dqcs_plugin_recv","Waits for a message from the host. > > It is only legal to call this function from within the `run()` callback. > Any other source will result in an error. > > When successful, this function returns a new handle to the received > `ArbData` object. 0 is used to indicate that an error occurred."],["dqcs_plugin_run","Executes a plugin in the current thread. > > `pdef` must be an appropriately populated plugin definition object. > Its callback functions will be called from the current thread, from within > the context of this function. > > `simulator` must be set to the address of our endpoint of the simulator > that's using the plugin; DQCsim normally passes this as the first command > line argument of the plugin process. > > If the plugin starts, the `pdef` handle is consumed by this function, > regardless of whether the plugin eventually closes normally. The handle is > only left alive if `pdef` is not a plugin definition object."],["dqcs_plugin_send","Sends a message to the host. > > It is only legal to call this function from within the `run()` callback. > Any other source will result in an error. > > The `cmd` handle is consumed by this function if and only if it succeeds."],["dqcs_plugin_start","Executes a plugin in a worker thread. > > This function behaves the same as dqcs_plugin_log(), but is asynchronous; > it always returns immediately. Of course, this means that the callbacks in > `pdef` will be called from a different thread. > > To wait for the thread to finish executing, call `dqcs_plugin_wait()` on > the returned join handle. Alternatively you can delete the join handle > object, which will detach the thread. > > Note that `dqcs_log_*()` will only be available in the thread that the > plugin actually runs in. > > This function returns 0 to indicate failure to start the plugin. Otherwise, > the join handle is returned."],["dqcs_plugin_wait","Waits for a plugin worker thread to finish executing. > > Unless the join handle is invalid, this function returns success/failure > based on the result of the plugin execution. If the plugin thread is > joined, the join handle is deleted."],["dqcs_qbset_contains","Returns whether the given qubit set contains the given qubit."],["dqcs_qbset_copy","Returns a copy of the given qubit set, intended for non-destructive iteration."],["dqcs_qbset_len","Returns the number of qubits in the given set. > > This function returns -1 to indicate failure."],["dqcs_qbset_new","Creates a new set of qubit references. > > Returns the handle of the newly created set. The set is initially empty. > Qubit sets are ordered, meaning that the order in which qubits are popped > from the set equals the order in which they were pushed. To iterate over a > set, simply make a copy and drain the copy using pop."],["dqcs_qbset_pop","Pops a qubit reference off of a qubit reference set. > > Qubits are popped in the same order in which they were pushed. That is, > they are FIFO-ordered."],["dqcs_qbset_push","Pushes a qubit reference into a qubit reference set. > > This function will fail if the specified qubit was already part of the set."],["dqcs_scfg_dqcsim_verbosity_get","Returns the configured verbosity for DQCsim's own messages."],["dqcs_scfg_dqcsim_verbosity_set","Configures the logging verbosity for DQCsim's own messages."],["dqcs_scfg_log_callback","Configures DQCsim to also output its log messages to callback function. > > `verbosity` specifies the minimum importance of a message required for the > callback to be called. > > `callback` is the callback function to install. It is always called with > the `user_data` pointer to make calling stuff like class member functions > or closures possible. The `user_free` function, if non-null, will be called > when the callback is uninstalled in any way. If `callback` is null, any > current callback is uninstalled instead. For consistency, if `user_free` is > non-null while `callback` is null, `user_free` is called immediately, under > the assumption that the caller has allocated resources unbeknownst that the > callback it's trying to install is null. > > NOTE: both `callback` and `user_free` may be called from a thread spawned > by the simulator. Calling any API calls from the callback is therefore > undefined behavior! > > The callback takes the following arguments: >  - `void*`: user defined data. >  - `const char*`: log message string, excluding metadata. >  - `const char*`: name assigned to the logger that was used to produce the >    message (= \"dqcsim\" or a plugin name). >  - `dqcs_loglevel_t`: the verbosity level that the message was logged with. >  - `const char*`: string representing the source of the log message, or >    `NULL` when no source is known. >  - `const char*`: string containing the filename of the source that >    generated the message, or `NULL` when no source is known. >  - `uint32_t`: line number within the aforementioned file, or 0 if not >    known. >  - `uint64_t`: Time in seconds since the Unix epoch. >  - `uint32_t`: Additional time in nanoseconds since the aforementioned. >  - `uint32_t`: PID of the generating process. >  - `uint64_t`: TID of the generating thread. > > If an internal log record is particularly malformed and cannot be coerced > into the above (nul bytes in the strings, invalid timestamp, whatever) the > message is silently ignored. > > The primary use of this callback is to pipe DQCsim's messages to an > external logging framework. When you do this, you probably also want to > call `dqcs_scfg_stderr_verbosity_set(handle, DQCS_LOG_OFF)` to prevent > DQCsim from writing the messages to stderr itself."],["dqcs_scfg_new","Constructs an empty simulation configuration. > > Before the configuration can be used, at least a frontend and a backend > plugin configuration must be pushed into it. This can be done with > `dqcs_scfg_push_plugin()`. Failing to do this will result in an error when > you try to start the simulation. > > The default settings correspond to the defaults of the `dqcsim` command > line interface. Refer to its help for more information."],["dqcs_scfg_push_plugin","Appends a plugin to a simulation configuration. > > Both plugin process and plugin thread configuration objects may be used. > The handle is consumed by this function, and is thus invalidated, if and > only if it is successful. > > Frontend and backend plugins will automatically be inserted at the front > and back of the pipeline when the simulation is created. Operators are > inserted in front to back order. This function does not provide safeguards > against multiple frontends/backends; such errors will only be reported when > the simulation is started. > > Note that it is not possible to observe or mutate a plugin configuration > once it has been added to a simulator configuration handle. If you want to > do this for some reason, you should maintain your own data structures, and > only build the DQCsim structures from them when you're done."],["dqcs_scfg_repro_disable","Disables the reproduction logging system. > > Calling this will disable the warnings printed when a simulation that > cannot be reproduced is constructed."],["dqcs_scfg_repro_path_style_get","Returns the path style used when writing reproduction files."],["dqcs_scfg_repro_path_style_set","Sets the path style used when writing reproduction files."],["dqcs_scfg_seed_get","Returns the configured random seed. > > This function will return 0 when it fails, but this can unfortunately not > be reliably distinguished from a seed that was set to 0."],["dqcs_scfg_seed_set","Configures the random seed that the simulation should use. > > Note that the seed is randomized by default."],["dqcs_scfg_stderr_verbosity_get","Returns the configured stderr sink verbosity for a simulation. > > That is, the minimum loglevel that a messages needs to have for it to be > printed to stderr."],["dqcs_scfg_stderr_verbosity_set","Configures the stderr sink verbosity for a simulation. > > That is, the minimum loglevel that a messages needs to have for it to be > printed to stderr."],["dqcs_scfg_tee","Configures DQCsim to also output its log messages to a file. > > `verbosity` configures the verbosity level for the file only."],["dqcs_sim_arb","Sends an `ArbCmd` message to one of the plugins, referenced by name. > > `ArbCmd`s are executed immediately after yielding to the simulator, so > all pending asynchronous calls are flushed and executed before the > `ArbCmd`. > > When this succeeds, the received data is returned in the form of a new > handle. When it fails, 0 is returned. > > The `ArbCmd` handle is consumed if and only if the API call succeeds."],["dqcs_sim_arb_idx","Sends an `ArbCmd` message to one of the plugins, referenced by index. > > The frontend always has index 0. 1 through N are used for the operators > in front to back order (where N is the number of operators). The > backend is at index N+1. > > Python-style negative indices are supported. That is, -1 can be used to > refer to the backend, -2 to the last operator, and so on. > > `ArbCmd`s are executed immediately after yielding to the simulator, so > all pending asynchronous calls are flushed and executed before the > `ArbCmd`. > > When this succeeds, the received data is returned in the form of a new > handle. When it fails, 0 is returned. > > The `ArbCmd` handle is consumed if and only if the API call succeeds."],["dqcs_sim_get_author","Queries the author of a plugin, referenced by instance name. > > On success, this returns a newly allocated string containing the > author. Free it with `free()` when you're done with it to avoid memory > leaks. On failure (i.e., the handle is invalid) this returns `NULL`."],["dqcs_sim_get_author_idx","Queries the author of a plugin, referenced by index. > > On success, this returns a newly allocated string containing the > author. Free it with `free()` when you're done with it to avoid memory > leaks. On failure (i.e., the handle is invalid) this returns `NULL`."],["dqcs_sim_get_name","Queries the implementation name of a plugin, referenced by instance  name. > > On success, this returns a newly allocated string containing the > name. Free it with `free()` when you're done with it to avoid memory > leaks. On failure (i.e., the handle is invalid) this returns `NULL`."],["dqcs_sim_get_name_idx","Queries the implementation name of a plugin, referenced by index. > > On success, this returns a newly allocated string containing the > name. Free it with `free()` when you're done with it to avoid memory > leaks. On failure (i.e., the handle is invalid) this returns `NULL`."],["dqcs_sim_get_version","Queries the version of a plugin, referenced by instance name. > > On success, this returns a newly allocated string containing the > version. Free it with `free()` when you're done with it to avoid memory > leaks. On failure (i.e., the handle is invalid) this returns `NULL`."],["dqcs_sim_get_version_idx","Queries the version of a plugin, referenced by index. > > On success, this returns a newly allocated string containing the > version. Free it with `free()` when you're done with it to avoid memory > leaks. On failure (i.e., the handle is invalid) this returns `NULL`."],["dqcs_sim_new","Constructs a DQCsim simulation. > > The provided handle is consumed if it is a simulation configuration, > regardless of whether simulation construction succeeds."],["dqcs_sim_recv","Waits for the simulated accelerator to send a message to us. > > When this succeeds, the received data is returned in the form of a new > handle. When it fails, 0 is returned. > > Deadlocks are detected and prevented by returning an error."],["dqcs_sim_send","Sends a message to the simulated accelerator. > > This is an asynchronous call: nothing happens until `yield()`, > `recv()`, or `wait()` is called. > > The `ArbData` handle is optional; if 0 is passed, an empty data object is > used. If a handle is passed, it is consumed if and only if the API call > succeeds."],["dqcs_sim_start","Starts a program on the simulated accelerator. > > This is an asynchronous call: nothing happens until `yield()`, > `recv()`, or `wait()` is called. > > The `ArbData` handle is optional; if 0 is passed, an empty data object is > used. If a handle is passed, it is consumed if and only if the API call > succeeds."],["dqcs_sim_wait","Waits for the simulated accelerator to finish its current program. > > When this succeeds, the return value of the accelerator's `run()` > function is returned in the form of a new handle. When it fails, 0 is > returned. > > Deadlocks are detected and prevented by returning an error."],["dqcs_sim_write_reproduction_file","Writes a reproduction file for the simulation so far."],["dqcs_sim_yield","Yields to the simulator. > > The simulation runs until it blocks again. This is useful if you want an > immediate response to an otherwise asynchronous call through the logging > system or some communication channel outside of DQCsim's control. > > This function silently returns immediately if no asynchronous data was > pending or if the simulator is waiting for something that has not been > sent yet."],["dqcs_tcfg_init_cmd","Appends an `ArbCmd` to the list of initialization commands of a plugin  thread. > > The `ArbCmd` handle is consumed by this function, and is thus invalidated, > if and only if it is successful."],["dqcs_tcfg_name","Returns the configured name for the given plugin thread. > > On success, this returns a newly allocated string containing the > name. Free it with `free()` when you're done with it to avoid memory > leaks. On failure (i.e., the handle is invalid) this returns `NULL`."],["dqcs_tcfg_new","Creates a new plugin thread configuration object from a plugin definition. > > The plugin definition handle is consumed by this function."],["dqcs_tcfg_new_raw","Creates a new plugin thread configuration object from a callback. > > The callback is called by DQCsim from a dedicated thread when DQCsim wants > to start the plugin. The callback must then in some way spawn a plugin > process that connects to the provided simulator string. The callback should > return only when the process terminates."],["dqcs_tcfg_tee","Configures a plugin thread to also output its log messages to a file. > > `verbosity` configures the verbosity level for the file only."],["dqcs_tcfg_type","Returns the type of the given plugin thread configuration."],["dqcs_tcfg_verbosity_get","Returns the configured verbosity for the given plugin thread."],["dqcs_tcfg_verbosity_set","Configures the logging verbosity for the given plugin thread."]],"struct":[["dqcs_plugin_state_t","Type for a plugin state. > > This is an opaque type that is passed along to plugin implementation > callback functions, which those callbacks can then use to interact with the > plugin instance. User code shall not create or modify values of this type, > and shall only use the values when calling `dqcs_plugin_*` functions."]],"type":[["dqcs_cycle_t","Type for a simulation cycle timestamp. > > Timestamps count upward from zero. The type is signed to allow usage of -1 > for errors, and to allow numerical differences to be represented."],["dqcs_handle_t","Type for a handle. > > Handles are like pointers into DQCsim's internal structures: all API calls > use these to refer to objects. Besides the object, they contain type > information. This type can be retrieved using `dqcs_handle_type()`. > > Handles are always positive integers, counting upwards from 1 upon > allocation, and they are not reused even after being deleted. Thus, every > subsequent object allocation returns a handle one greater than the > previous. Note however that DQCsim may allocate objects as well without > the user specifically requesting this, so external code should generally > not rely on this behavior unless otherwise noted. The value zero is > reserved for invalid references or error propagation. > > Note that the scope for handles is thread-local. That is, data referenced > by a handle cannot be shared or moved between threads. > > The value zero is reserved for invalid references or error propagation."],["dqcs_qubit_t","Type for a qubit reference. > > Qubit references are exchanged between the frontend, operator, and backend > plugins to indicate which qubits a gate operates on. Note that this makes > them fundamentally different from handles, which are thread-local. > > Qubit references are always positive integers, counting upwards from 1 upon > allocation, and they are not reused even after the qubit is deallocated. > Thus, every subsequent allocation returns a qubit reference one greater > than the previous. This is guaranteed behavior that external code can rely > upon. The value zero is reserved for invalid references or error > propagation."]]});