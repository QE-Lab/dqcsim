//! A log thread and proxy combination.
//!
//! This crate provides logging functionality to run a dedicated log thread.
//! The log thread provides an endpoint used by log proxy instances to send log
//! records. Log proxy instances can run in different threads or processes.
//!
//! # Usage
//!
//! Spawn a log thread from the main thread and initialize a log proxy instance
//! in another thread or process.
//! Log records can be generated using the provided macros.
//!
//! # Example
//!
//! ```rust
//! use dqcsim_log::{init, note, warn, LevelFilter, proxy::LogProxy, thread::LogThread};
//!
//! let log_thread = LogThread::spawn(LevelFilter::Trace);
//! let log_endpoint = log_thread.get_sender().unwrap();
//!
//! std::thread::spawn(move || {
//!     let proxy = LogProxy::boxed(log_endpoint);
//!     init(proxy, LevelFilter::Trace);
//!
//!     warn!("Warning from thread");
//!
//! })
//! .join();
//!
//! note!("Note from main thread");
//!
//! ```
//!
//! # Inspiration
//! * [`log`]
//! * sfackler's [comment](https://github.com/rust-lang-nursery/log/issues/57#issuecomment-143383896)
//!
//! [`log`]: https://github.com/rust-lang-nursery/log

pub mod channel;
pub mod ipc;
pub mod proxy;
pub mod stdio;
pub mod thread;

#[doc(hidden)]
pub use ref_thread_local as _ref_thread_local;

use crate::channel::Sender;
use enum_variants::EnumVariants;
use failure::Fail;
use lazy_static::lazy_static;
use ref_thread_local::ref_thread_local;
use serde::{Deserialize, Serialize};
use std::{cell::RefCell, fmt};

/// The Log trait.
pub trait Log {
    fn log(&self, record: Record);
}

#[derive(Debug, Fail)]
pub enum LogError {
    #[fail(display = "Failed to update thread-local logger ({})", _0)]
    ThreadLocalError(String),
}

thread_local! {
    /// The thread-local logger.
    static LOGGER: RefCell<Option<Box<dyn Log>>> = RefCell::new(None);
    /// The thread-local maximum log level.
    #[doc(hidden)]
    pub static LOGLEVEL: RefCell<LevelFilter> = RefCell::new(LevelFilter::Off);
}

lazy_static! {
    #[doc(hidden)]
    pub static ref PID: u32 = std::process::id();
}

ref_thread_local! {
    #[doc(hidden)]
    pub static managed TID: u64 = {
        // Don't ask.
        format!("{:?}", std::thread::current().id())
            .trim_matches(|c: char| !c.is_numeric())
            .parse::<u64>()
            .unwrap()
    };
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Serialize, Deserialize, EnumVariants)]
pub enum Level {
    /// This loglevel is to be used for reporting a fatal error, resulting from
    /// the owner of the logger getting into an illegal state from which it
    /// cannot recover. Such problems are also reported to the API caller via
    /// Result::Err if applicable.
    Fatal = 1,

    /// This loglevel is to be used for reporting or propagating a non-fatal
    /// error caused by the API caller doing something wrong. Such problems are
    /// also reported to the API caller via Result::Err if applicable.
    Error,

    /// This loglevel is to be used for reporting that a called API/function is
    /// telling us we did something wrong (that we weren't expecting), but we
    /// can recover. For instance, for a failed connection attempt to something
    /// that really should not be failing, we can still retry (and eventually
    /// report critical or error if a retry counter overflows). Since we're
    /// still trying to rectify things at this point, such problems are NOT
    /// reported to the API/function caller via Result::Err.
    Warn,

    /// This loglevel is to be used for reporting information specifically
    /// requested by the user/API caller, such as the result of an API function
    /// requested through the command line, or an explicitly captured
    /// stdout/stderr stream.
    Note,

    /// This loglevel is to be used for reporting information NOT specifically
    /// requested by the user/API caller, such as a plugin starting up or
    /// shutting down.
    Info,

    /// This loglevel is to be used for reporting debugging information useful
    /// for debugging the user of the API provided by the logged instance.
    Debug,

    /// This loglevel is to be used for reporting debugging information useful
    /// for debugging the internals of the logged instance. Such messages would
    /// normally only be generated by debug builds, to prevent them from
    /// impacting performance under normal circumstances.
    Trace,
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Serialize, Deserialize, EnumVariants)]
pub enum LevelFilter {
    /// A level lower than all log levels.
    Off = 0,
    /// Corresponds to the `Fatal` log level.
    Fatal,
    /// Corresponds to the `Error` log level.
    Error,
    /// Corresponds to the `Warn` log level.
    Warn,
    /// Corresponds to the `Note` log level.
    Note,
    /// Corresponds to the `Info` log level.
    Info,
    /// Corresponds to the `Debug` log level.
    Debug,
    /// Corresponds to the `Trace` log level.
    Trace,
}

impl From<Level> for LevelFilter {
    fn from(level: Level) -> LevelFilter {
        match level {
            Level::Fatal => LevelFilter::Fatal,
            Level::Error => LevelFilter::Error,
            Level::Warn => LevelFilter::Warn,
            Level::Note => LevelFilter::Note,
            Level::Info => LevelFilter::Info,
            Level::Debug => LevelFilter::Debug,
            Level::Trace => LevelFilter::Trace,
        }
    }
}

/// Log record metadata.
///
/// The log metadata attached to a [`Record`].
///
/// [`Record`]: ./struct.Record.html
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Metadata {
    /// Level of the log record.
    level: Level,
    module_path: Option<String>,
    file: Option<String>,
    line: Option<u32>,
    timestamp: std::time::SystemTime,
    process: u32,
    thread: u64,
}

/// A log record.
///
/// A log record consists of some metadata and a payload.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Record {
    payload: String,
    metadata: Metadata,
}

impl Record {
    pub fn payload(&self) -> &str {
        &self.payload
    }
    pub fn level(&self) -> Level {
        self.metadata.level
    }
    pub fn timestamp(&self) -> std::time::SystemTime {
        self.metadata.timestamp
    }
    pub fn process(&self) -> u32 {
        self.metadata.process
    }
    pub fn thread(&self) -> u64 {
        self.metadata.thread
    }
}

impl Record {
    pub fn build(
        payload: impl Into<String>,
        level: Level,
        module_path: impl Into<String>,
        file: impl Into<String>,
        line: u32,
        process: u32,
        thread: u64,
    ) -> Record {
        Record {
            payload: payload.into(),
            metadata: Metadata {
                level,
                module_path: Some(module_path.into()),
                file: Some(file.into()),
                line: Some(line),
                timestamp: std::time::SystemTime::now(),
                process,
                thread,
            },
        }
    }

    pub fn log(record: Record) {
        LOGGER.with(|logger| {
            if let Some(ref logger) = *logger.borrow() {
                logger.log(record);
            }
        });
    }
}

impl fmt::Display for Record {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.payload)
    }
}

/// Update the thread-local logger.
fn update(log: Option<Box<dyn Log>>, level: Option<LevelFilter>) -> Result<(), LogError> {
    LOGGER.with(|logger| match logger.try_borrow_mut() {
        Ok(mut logger) => {
            *logger = log;
            LOGLEVEL.with(|loglevel| match loglevel.try_borrow_mut() {
                Ok(mut loglevel) => {
                    *loglevel = level.unwrap_or(LevelFilter::Off);
                    Ok(())
                }
                Err(_) => Err(LogError::ThreadLocalError("log level".to_string())),
            })
        }
        Err(_) => Err(LogError::ThreadLocalError("logger".to_string())),
    })
}

/// Initialize the thread-local logger.
pub fn init(log: Box<dyn Log>, level: LevelFilter) -> Result<(), LogError> {
    update(Some(log), Some(level))
}

/// Deinitialize the thread-local logger.
pub fn deinit() -> Result<(), LogError> {
    update(None, None)
}

#[macro_export]
macro_rules! log {
    (target: $target:expr, $lvl:expr, $($arg:tt)+) => ({
        use $crate::_ref_thread_local::RefThreadLocal;
        $crate::LOGLEVEL.with(|loglevel| {
            if $crate::LevelFilter::from($lvl) <= *loglevel.borrow() {
                $crate::Record::log($crate::Record::build(
                    format!($($arg)+),
                    $lvl,
                    $target,
                    file!(),
                    line!(),
                    *$crate::PID,
                    *$crate::TID.borrow()
                ));
            }
        });
    });
    ($lvl:expr, $($arg:tt)+) => ($crate::log!(target: module_path!(), $lvl, $($arg)+))
}

#[macro_export]
macro_rules! fatal {
    (target: $target:expr, $($arg:tt)+) => (
        $crate::log!(target: $target, $crate::Level::Fatal, $($arg)+);
    );
    ($($arg:tt)+) => (
        $crate::log!($crate::Level::Fatal, $($arg)+);
    )
}

#[macro_export]
macro_rules! error {
    (target: $target:expr, $($arg:tt)+) => (
        $crate::log!(target: $target, $crate::Level::Error, $($arg)+);
    );
    ($($arg:tt)+) => (
        $crate::log!($crate::Level::Error, $($arg)+);
    )
}

#[macro_export]
macro_rules! warn {
    (target: $target:expr, $($arg:tt)+) => (
        $crate::log!(target: $target, $crate::Level::Warn, $($arg)+);
    );
    ($($arg:tt)+) => (
        $crate::log!($crate::Level::Warn, $($arg)+);
    )
}

#[macro_export]
macro_rules! note {
    (target: $target:expr, $($arg:tt)+) => (
        $crate::log!(target: $target, $crate::Level::Note, $($arg)+);
    );
    ($($arg:tt)+) => (
        $crate::log!($crate::Level::Note, $($arg)+);
    )
}

#[macro_export]
macro_rules! info {
    (target: $target:expr, $($arg:tt)+) => (
        $crate::log!(target: $target, $crate::Level::Info, $($arg)+);
    );
    ($($arg:tt)+) => (
        $crate::log!($crate::Level::Info, $($arg)+);
    )
}

#[macro_export]
macro_rules! debug {
    (target: $target:expr, $($arg:tt)+) => (
        $crate::log!(target: $target, $crate::Level::Debug, $($arg)+);
    );
    ($($arg:tt)+) => (
        $crate::log!($crate::Level::Debug, $($arg)+);
    )
}

#[macro_export]
macro_rules! trace {
    (target: $target:expr, $($arg:tt)+) => (
        $crate::log!(target: $target, $crate::Level::Trace, $($arg)+);
    );
    ($($arg:tt)+) => (
        $crate::log!($crate::Level::Trace, $($arg)+);
    )
}

#[cfg(test)]
mod tests {
    use super::{Level, LevelFilter};

    #[test]
    fn level_order() {
        assert!(Level::Debug < Level::Trace);
        assert!(Level::Info < Level::Debug);
        assert!(Level::Note < Level::Info);
        assert!(Level::Warn < Level::Note);
        assert!(Level::Error < Level::Warn);
        assert!(Level::Fatal < Level::Error);
        assert!(LevelFilter::Off < LevelFilter::from(Level::Fatal));
    }

}
